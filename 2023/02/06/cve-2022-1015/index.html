<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>CVE-2022-1015 nf_tables 提权漏洞分析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="author: 莫兴远 of IceSword Lab 一、简介CVE-2022-1015 是 Linux 内核 nf_tables 模块的一个漏洞，其成因为没有合理限制整数范围导致栈越界读写。 受该漏洞影响的内核版本范围为 5.12 ~ 5.16 。 该漏洞为此 commit 所修复。 二、漏洞相关知识Netfilter 是 Linux 内核一个非常庞大的子系统，它在内核的网络栈中置入多个钩子，">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2022-1015 nf_tables 提权漏洞分析">
<meta property="og:url" content="http://yoursite.com/2023/02/06/cve-2022-1015/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="author: 莫兴远 of IceSword Lab 一、简介CVE-2022-1015 是 Linux 内核 nf_tables 模块的一个漏洞，其成因为没有合理限制整数范围导致栈越界读写。 受该漏洞影响的内核版本范围为 5.12 ~ 5.16 。 该漏洞为此 commit 所修复。 二、漏洞相关知识Netfilter 是 Linux 内核一个非常庞大的子系统，它在内核的网络栈中置入多个钩子，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2023/02/06/cve-2022-1015/images/01.png">
<meta property="article:published_time" content="2023-02-06T14:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.309Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2023/02/06/cve-2022-1015/images/01.png">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2023/02/06/cve-2022-1015" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2023-02-06T14:00:00.000Z" itemprop="datePublished">2023-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CVE-2022-1015 nf_tables 提权漏洞分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: 莫兴远 of <a href="https://www.iceswordlab.com/about/" target="_blank" rel="noopener">IceSword Lab</a></p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>CVE-2022-1015 是 Linux 内核 nf_tables 模块的一个漏洞，其成因为没有合理限制整数范围导致栈越界读写。</p>
<p>受该漏洞影响的内核版本范围为 5.12 ~ 5.16 。</p>
<p>该漏洞为此 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e1acfa387b9ff82cfc7db8cc3b6959221a95851" target="_blank" rel="noopener">commit</a> 所修复。</p>
<h1 id="二、漏洞相关知识"><a href="#二、漏洞相关知识" class="headerlink" title="二、漏洞相关知识"></a>二、漏洞相关知识</h1><p>Netfilter 是 Linux 内核一个非常庞大的子系统，它在内核的网络栈中置入多个钩子，并允许其他模块在这些钩子处注册回调函数，当内核执行到钩子处时，所有被注册的回调函数都会被执行。</p>
<p>nf_tables 则是隶属于 Netfilter 子系统的一个模块，它在 Netfitler 的某些钩子处注册了回调函数，以提供网络数据包过滤功能，通常被用于实现防火墙等功能。本文所分析的漏洞就位于 nf_tables 模块中。</p>
<p>在用户态与 nf_tables 交互则是通过 netlink。netlink 是常见的用户态与内核态进行交互的手段，它通过向 AF_NETLINK 类型的 socket 发送数据向内核传递信息，类似地，还可通过从该类型 socket 接收数据以获取内核传递回来的信息。</p>
<h2 id="2-1-nf-tables实现"><a href="#2-1-nf-tables实现" class="headerlink" title="2.1 nf_tables实现"></a>2.1 nf_tables实现</h2><p>nf_tables 允许用户向其注册处理网络数据包的 rule，以决定针对不同类型的数据包该采取哪种行动。多条 rule 被组织在一条 chain 中，多条 chain 则被组织在一个 table 中。不同类型的 chain 会与不同的 Netfilter hook 绑定在一起。当网络数据包到达后，经过内核不同的 hook 时，所有绑定在该 hook 处的 chain 都会被执行，以完成对数据包的处理。在这里，chain 的执行是指其中所有的 rule 被依次执行，rule 的执行则又是指数据包会根据其中拟定的规则确定被采取什么行动，是丢弃、拒绝还是接受。</p>
<p>向 nf_tables 注册 rule 的方式是通过 netlink。由于通过 netlink 向内核发送的数据包过于底层，用户使用起来不方便，开发者提供了用户态工具 nft，方便用户通过更高级的语法拟定规则。</p>
<h3 id="2-1-1-rule"><a href="#2-1-1-rule" class="headerlink" title="2.1.1 rule"></a>2.1.1 rule</h3><p>rule 包含如何处理数据包的逻辑，比如检查数据包的协议、源地址、目标地址、端口等，以分别采取不同的行动。每条 rule 都和一个 verdict 绑定，即每条 rule 都有一个默认的裁定，决定对数据包采取何种行为，是丢弃、拒绝还是接受。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp dport 50001 drop</span><br></pre></td></tr></table></figure>

<p>drop 就是该 rule 的 verdict，表示所有目标端口为 50001 的 udp 数据包都会被丢弃。</p>
<h3 id="2-1-2-chain"><a href="#2-1-2-chain" class="headerlink" title="2.1.2 chain"></a>2.1.2 chain</h3><p>chain 是将 rule 组织起来的结构，一条 chain 可包含多条 rule。chain 分为 base chain 和 non-base chain，base chain 是直接绑定到 Netfilter hook 上面的，执行流只会从 base chain 开始。chain 中的 rule 一般都是依次执行完，有时候某条 rule 的 verdict 会让执行流跳转到其他的 chain，从而越过该 chain 中剩下的 rule，但只能跳转到 non-base chain。跳转分两种，一种是跳转后到某条 chain 后就不可以返回了，另一种则是跳转后还可以返回继续执行原来的 chain 剩下的 rule。</p>
<h3 id="2-1-3-table"><a href="#2-1-3-table" class="headerlink" title="2.1.3 table"></a>2.1.3 table</h3><p>table 是 nf_tables 最顶层的结构，它包含多条 chain。chain 只能跳转到同一 table 中的其他 chain。</p>
<p>每个 table 都会从属于某个族，族决定了该 table 会处理哪些种类的数据包。族包括 ip、 ip6、 inet、 arp、 bridge 和 netdev。</p>
<p>属于 ip 族的 table 只负责处理 IPv4 数据包，属于 ip6 族的 table 只负责处理 IPv6 数据包，属于 inet 族的 table 则既可处理 IPv4 又可处理 IPv6 数据包。</p>
<h3 id="2-1-4-expression"><a href="#2-1-4-expression" class="headerlink" title="2.1.4 expression"></a>2.1.4 expression</h3><p>事实上，rule 在层次结构上还可以细分为多个 expression，expression 相当于一条条应用在数据包上的具体指令。用户态工具一般不会涉及到 expression 这个抽象表示，只有内核代码会涉及到。</p>
<p>对于 udp dport 50001 drop 这个规则，需要先通过一个 expression 检查协议是不是  udp，再通过一个 expression 检查端口是不是 50001，如果前面的 expression 都通过了，最后再通过一个 expression 将 verdict 设置为 drop，以将数据包丢弃。</p>
<p>每种 expression 会和一个 struct nft_expr_ops 实例绑定，比如 immediate 这个 expression：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_imm_ops</span> = &#123;</span></span><br><span class="line">	.type		= &amp;nft_imm_type, <span class="comment">// expression 类型</span></span><br><span class="line">	.<span class="built_in">size</span>		= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_immediate_expr)),</span><br><span class="line">	.eval		= nft_immediate_eval, <span class="comment">// 当 expression 被执行时调用</span></span><br><span class="line">	.init		= nft_immediate_init, <span class="comment">// 当 expression 被初始化时调用</span></span><br><span class="line">	.activate	= nft_immediate_activate,</span><br><span class="line">	.deactivate	= nft_immediate_deactivate,</span><br><span class="line">	.destroy	= nft_immediate_destroy,</span><br><span class="line">	.dump		= nft_immediate_dump,</span><br><span class="line">	.validate	= nft_immediate_validate,</span><br><span class="line">	.reduce		= nft_immediate_reduce,</span><br><span class="line">	.offload	= nft_immediate_offload,</span><br><span class="line">	.offload_action	= nft_immediate_offload_action,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次当一条 rule 被添加进来，其所有 expression 的 init 函数都会被调用。</p>
<p>当某个 expression 被执行时，其 eval 函数会被调用。</p>
<h3 id="2-1-5-register"><a href="#2-1-5-register" class="headerlink" title="2.1.5 register"></a>2.1.5 register</h3><p>expression 在操作数据包时，需要内存来记录一些数据，这部分内存就是 register。在内核的实现中，所有 register 都在栈上，且在内存地址上是连续的。</p>
<p>expression 可以读取或修改 register 的数据，单次访问的对象既可以是单个 register，也可以是连续的多个 register，因此 register 可以看做是一块连续的缓冲区。</p>
<p>register 可通过 index 索引，以下是内核中定义的 register 的 index：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> nft_registers &#123;</span><br><span class="line">	NFT_REG_VERDICT,</span><br><span class="line">	NFT_REG_1,</span><br><span class="line">	NFT_REG_2,</span><br><span class="line">	NFT_REG_3,</span><br><span class="line">	NFT_REG_4,</span><br><span class="line">	__NFT_REG_MAX,</span><br><span class="line"></span><br><span class="line">	NFT_REG32_00	= <span class="number">8</span>,</span><br><span class="line">	NFT_REG32_01,</span><br><span class="line">	NFT_REG32_02,</span><br><span class="line">	...</span><br><span class="line">	NFT_REG32_13,</span><br><span class="line">	NFT_REG32_14,</span><br><span class="line">	NFT_REG32_15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>register 有两种索引方式。NFT_REG_1 到 NFT_REG_4 是一种，共 4 个 register，每个 16 字节；NFT_REG32_00 到 NFT_REG32_15 是另一种，共 16 个 reigster，每个 4 字节。在两种索引方式中，NFT_REG_VERDICT 都指向 verdict register，大小为 16 字节。两种索引方式针对的都是同一片内存，因此内存总数都是 16 + 4 * 16 = 16 + 16 * 4 = 80 字节。</p>
<p><img src="images/01.png" alt></p>
<p>verdict register 在内存上位于最前，每条 rule 执行完后都会设置好 verdict register，以决定下一步该怎么执行。verdict register 可以设置成以下值：</p>
<table>
<thead>
<tr>
<th>verdict</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>NFT_CONTINUE</td>
<td>默认 verdict，继续执行下一个 expression。</td>
</tr>
<tr>
<td>NFT_BREAK</td>
<td>跳过该 rule 剩下的 expression，继续执行下一条 rule。</td>
</tr>
<tr>
<td>NF_DROP</td>
<td>丢弃数据包，停止执行。</td>
</tr>
<tr>
<td>NF_ACCEPT</td>
<td>接受数据包，停止执行。</td>
</tr>
<tr>
<td>NFT_GOTO</td>
<td>跳转到另一条 chain，且不再返回。</td>
</tr>
<tr>
<td>NFT_JUMP</td>
<td>跳转到另一条 chain，执行完该 chain 后，若 verdict 为 NFT_CONTINUE，则返回原本的 chain 继续执行。</td>
</tr>
</tbody></table>
<h3 id="2-1-6-nft-do-chain"><a href="#2-1-6-nft-do-chain" class="headerlink" title="2.1.6 nft_do_chain"></a>2.1.6 nft_do_chain</h3><p>nft_do_chain 实现了依次执行所有 base chain 中所有 rule 的所有 expression 的逻辑，以下是添加了许多说明性注释的该函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nft_do_chain(struct nft_pktinfo *pkt, <span class="keyword">void</span> *priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> = <span class="title">priv</span>, *<span class="title">basechain</span> = <span class="title">chain</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>, *<span class="title">last_rule</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">nft_net</span>(<span class="title">pkt</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line">	<span class="keyword">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	info.trace = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;nft_trace_enabled))</span><br><span class="line">		nft_trace_init(&amp;info, pkt, &amp;regs.verdict, basechain);</span><br><span class="line">do_chain:</span><br><span class="line">	<span class="keyword">if</span> (genbit)</span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_1);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_0);</span><br><span class="line"></span><br><span class="line">	rule = (struct nft_rule_dp *)blob-&gt;data;</span><br><span class="line">	<span class="comment">/* 获取最后一条 rule 的位置，以确定循环的停止条件 */</span></span><br><span class="line">	last_rule = (<span class="keyword">void</span> *)blob-&gt;data + blob-&gt;<span class="built_in">size</span>;</span><br><span class="line">next_rule: <span class="comment">// 执行到一条新的 chain，或返回到原来的 chain，都从这里开始</span></span><br><span class="line">	regs.verdict.code = NFT_CONTINUE; <span class="comment">// the default verdict code = NFT_CONTINUE</span></span><br><span class="line">	<span class="keyword">for</span> (; rule &lt; last_rule; rule = nft_rule_next(rule)) &#123; <span class="comment">// iterate through the rules</span></span><br><span class="line">		<span class="comment">/* iterate through the expressions */</span></span><br><span class="line">		nft_rule_dp_for_each_expr(expr, last, rule) &#123;</span><br><span class="line">			<span class="comment">// execute the expression</span></span><br><span class="line">			<span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp_fast_ops)</span><br><span class="line">				nft_cmp_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp16_fast_ops)</span><br><span class="line">				nft_cmp16_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_bitwise_fast_ops)</span><br><span class="line">				nft_bitwise_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops != &amp;nft_payload_fast_ops ||</span><br><span class="line">				 !nft_payload_fast_eval(expr, &amp;regs, pkt))</span><br><span class="line">				expr_call_ops_eval(expr, &amp;regs, pkt);</span><br><span class="line">			<span class="comment">/* 如果 verdict 不是 NFT_CONTINUE， 停止执行该 rule 接下来的 expression */</span></span><br><span class="line">			<span class="keyword">if</span> (regs.verdict.code != NFT_CONTINUE) </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 已执行完一条 rule，检查 verdict，</span></span><br><span class="line">    <span class="comment">// 如果不是 NFT_BREAK 或 NFT_CONTINUE，停止执行该 chain 剩下的 rule</span></span><br><span class="line">		<span class="keyword">switch</span> (regs.verdict.code) &#123; </span><br><span class="line">		<span class="keyword">case</span> NFT_BREAK: </span><br><span class="line">			<span class="comment">// 若为 NFT_BREAK，则将 verdict 设置回 NFT_CONTINUE。</span></span><br><span class="line">			<span class="comment">// NFT_BREAK 和 NFT_CONTINUE 类似，都会执行下一条 rule，</span></span><br><span class="line">      <span class="comment">// 只是 NFT_BREAK 会跳过当前 rule 剩下的 expression。</span></span><br><span class="line">			regs.verdict.code = NFT_CONTINUE;</span><br><span class="line">			nft_trace_copy_nftrace(pkt, &amp;info);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">			<span class="comment">// 执行到这里代表执行完了当前 rule 的所有 expression，</span></span><br><span class="line">      <span class="comment">// 继续执行下一条 rule 即可。</span></span><br><span class="line">			nft_trace_packet(pkt, &amp;info, chain, rule,</span><br><span class="line">					 NFT_TRACETYPE_RULE);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若 verdict 不是 NFT_BREAK 或 NFT_CONTINUE，</span></span><br><span class="line">    <span class="comment">// 代表即将跳过该 chain 剩下的 rule，停止该 chain 的执行。</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_trace_verdict(&amp;info, chain, rule, &amp;regs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行到这里代表执行完了某条 chain，</span></span><br><span class="line">  <span class="comment">// 将根据 verdict 决定采取的行动</span></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">	<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">	<span class="keyword">case</span> NF_DROP:</span><br><span class="line">	<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">	<span class="keyword">case</span> NF_STOLEN:</span><br><span class="line">		<span class="comment">// 已经决定好对当前数据包的处理，退出函数即可。</span></span><br><span class="line">		<span class="keyword">return</span> regs.verdict.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尚未决定好对数据包的处理，继续执行。</span></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP: </span><br><span class="line">		<span class="comment">// 跳转到另一条 chain，将返回时需要的信息保存到 jumpstack 上</span></span><br><span class="line">    <span class="comment">// 返回后，执行的是当前 rule 的下一条 rule</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(stackptr &gt;= NFT_JUMP_STACK_SIZE))</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		jumpstack[stackptr].chain = chain;</span><br><span class="line">		jumpstack[stackptr].rule = nft_rule_next(rule);</span><br><span class="line">		jumpstack[stackptr].last_rule = last_rule;</span><br><span class="line">		stackptr++;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		<span class="comment">// 跳转到另一条 chain，不再返回</span></span><br><span class="line">		chain = regs.verdict.chain;</span><br><span class="line">		<span class="keyword">goto</span> do_chain;</span><br><span class="line">	<span class="keyword">case</span> NFT_CONTINUE: <span class="comment">// 执行下一条 chain</span></span><br><span class="line">	<span class="keyword">case</span> NFT_RETURN: <span class="comment">// 返回到上一次跳转前的 chain</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_base_chain(basechain)-&gt;policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每执行完一个 expression、一条 rule 或 一条 chain 时，都会检查 verdict register。</p>
<p>执行完一个 expression 时，非 NFT_CONTINUE 的 verdict 会阻止该条 rule 剩下的 expression 的执行。</p>
<p>执行完一条 rule 时，非 NFT_BREAK 或 NFT_CONTINUE 的 verdict 会阻止该 chain 剩下的 rule 的执行。</p>
<p>执行完一条 chain 时，如果已经决定对数据包的处理，则停止执行。否则，根据 verdict 决定流程如何跳转。</p>
<h3 id="2-1-7-expression种类"><a href="#2-1-7-expression种类" class="headerlink" title="2.1.7 expression种类"></a>2.1.7 expression种类</h3><p>以下是常见的一些 expression 类型及其功能的简单描述：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>nft_immediate_expr</td>
<td>将一个常数保存进 register。</td>
</tr>
<tr>
<td>nft_payload</td>
<td>从数据包提取数据保存进 register。</td>
</tr>
<tr>
<td>nft_payload_set</td>
<td>将数据包的某部分数据设置成 register 中的数据。</td>
</tr>
<tr>
<td>nft_cmp_expr</td>
<td>比较 register 中的数据和某个常数，根据结果决定是否修改执行流。</td>
</tr>
<tr>
<td>nft_bitwise</td>
<td>对 register 中数据进行位操作，比如左移、亦或。</td>
</tr>
<tr>
<td>nft_range_expr</td>
<td>和 nft_cmp_expr 类似，但比较的是更大范围的数据，可跨越多个 register。</td>
</tr>
</tbody></table>
<h2 id="2-2-netlink"><a href="#2-2-netlink" class="headerlink" title="2.2 netlink"></a>2.2 netlink</h2><p>和 nf_table 进行交互需要通过 netlink。netlink 是 Linux 系统中和内核通信的常用方式，特别是在网络模块中使用率很高，它的设计是为了克服 ioctl 的一些缺点。</p>
<p>和 netlink 通信需要利用 AF_NETLINK 族的 socket。所有需要使用 netlink 的内核模块都要实现一个 protocal，nf_tables 则是实现了 NETLINK_NETFILTER 这一 protocal。因此，为了和 nf_tables 通信，只需要创建以下 socket：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER);</span><br></pre></td></tr></table></figure>

<p>当创建相应的 netlink socket 时，netlink 还会自动加载相应的模块，只要 modprobe 和 .ko 文件存放在合适的位置。</p>
<p>创建 socket 之后，就可通过 sendmsg 向 socket 发送消息，通过 recvmsg 从 socket 接收消息，从而实现和 nf_tables 通信。</p>
<p>sendmsg 的消息格式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line">   <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="keyword">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line">   <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line">   <span class="keyword">int</span>           msg_flags;      <span class="comment">/* Flags (unused) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>消息的内容存放在 msg_iov 字段指向的 iovec 数组中。</p>
<p>发送 netlink 消息时，iovec 数组指向 struct nlmsghdr 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">/* Length of message including header */</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">/* Message content */</span></span><br><span class="line">	__u16		nlmsg_flags;	<span class="comment">/* Additional flags */</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct nlmsghdr 之后通常紧跟特定 protocol 定义的协议头部，不同 protocal 的协议头部差异很大。</p>
<p>协议头部之后是多个属性，属性的头部是以下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性的实际内容则紧跟在头部之后。</p>
<h1 id="三、漏洞成因"><a href="#三、漏洞成因" class="headerlink" title="三、漏洞成因"></a>三、漏洞成因</h1><p>漏洞类型是整形溢出导致的栈溢出，同时存在于 nft_validate_register_store 及 nft_validate_register_load 两个函数，以下仅通过 nft_validate_register_load 进行解释，nft_validate_register_store 处的情况大同小异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_validate_register_load</span><span class="params">(<span class="keyword">enum</span> nft_registers reg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里检查是否在读取 verdict register， 这是不被允许的</span></span><br><span class="line">	<span class="keyword">if</span> (reg &lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) <span class="comment">// len 不可以是 0</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="comment">// 由于 reg 的范围没有限制好，导致整形溢出</span></span><br><span class="line">	<span class="keyword">if</span> (reg * NFT_REG32_SIZE + len &gt; sizeof_field(struct nft_regs, data))</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 reg 的范围没有限制好，导致 reg * NFT_REG32_SIZE + len 整形溢出。</p>
<p>reg 的取值范围分析可以看 nft_validate_register_load 的调用处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_parse_register_load</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr, u8 *sreg, u32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 reg; <span class="comment">// 4 byte register variable</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	reg = nft_parse_register(attr); <span class="comment">// gets the register index from an attribute</span></span><br><span class="line">	err = nft_validate_register_load(reg, len); <span class="comment">// calls the validating function</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="comment">// if the validating function didn't return an error everything is fine</span></span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	*sreg = reg; <span class="comment">// save the register index into sreg (a pointer that is provided as an argument)</span></span><br><span class="line">	<span class="comment">// sreg = source register -&gt; the register from which we read</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_parse_register_load);</span><br></pre></td></tr></table></figure>

<p>可以看到 reg 来自 netlink 属性 attr，通过 nft_parse_register 函数解析出来，再传递给 nft_validate_register_load 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* net/netfilter/nf_tables_api.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	nft_parse_register - parse a register value from a netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@attr: netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Parse and translate a register value from a netlink attribute.</span></span><br><span class="line"><span class="comment"> *	Registers used to be 128 bit wide, these register numbers will be</span></span><br><span class="line"><span class="comment"> *	mapped to the corresponding 32 bit register numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nft_parse_register</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> reg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from include/uapi/linux/netfilter/nf_tables.h</span></span><br><span class="line">	<span class="comment">// NFT_REG_SIZE = 16 (16 bytes)</span></span><br><span class="line">	<span class="comment">// NFT_REG32_SIZE = 4 (4 bytes)</span></span><br><span class="line">	reg = ntohl(nla_get_be32(attr));</span><br><span class="line">	<span class="keyword">switch</span> (reg) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_REG_VERDICT...NFT_REG_4:</span><br><span class="line">		<span class="keyword">return</span> reg * NFT_REG_SIZE / NFT_REG32_SIZE; </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 nft_parse_register 中，明显没有对 reg 范围做任何限制，传入在 NFT_REG_VERDICT…NFT_REG_4 之外的值，函数最终都会返回 reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00，也就是 reg - 4。</p>
<p>最终，nft_parse_register_load 传回的 reg 会作为 index 用于访问 nft_do_chain 函数中的 nft_regs 局部变量，导致栈溢出。由于 nft_validate_register_store 及 nft_validate_register_load 两个函数都存在漏洞，因此可以同时越界读和写 nft_regs 之后的栈内存。</p>
<h1 id="四、EXP思路"><a href="#四、EXP思路" class="headerlink" title="四、EXP思路"></a>四、EXP思路</h1><p>EXP 中存在大量的算术运算计算各种地址位移，所针对的是特定的漏洞及特定的内核映像，在此谈论这些意义不大，因此本文只谈通用的思路。想要更细致研究的话可以参考 EXP 仓库：</p>
<p>https://github.com/pqlx/CVE-2022-1015</p>
<p>https://github.com/ysanatomic/CVE-2022-1015</p>
<p>通常，由于 canary 的存在，memcpy 等函数引发的栈内存越界写会难以利用，因为 memcpy 的起始地址通常是某个局部变量，要覆写到返回地址则必定会覆写 canary。这个漏洞可以利用的原因就是越界读写的起始地址可以通过传入的 reg 值设定，因此可以越过 canary，从 canary 之后、返回地址之前的地址开始覆写。</p>
<h2 id="4-1-泄露内核地址"><a href="#4-1-泄露内核地址" class="headerlink" title="4.1 泄露内核地址"></a>4.1 泄露内核地址</h2><p>首先通过动态调试寻找栈上的内核地址，再通过 nft_bitwise 这一 expression 越界读取该范围的内存，保存进 nft_regs 的正常范围内存内，这样才能通过 nft_payload_set 将 nft_regs 正常范围内存的内容复制到数据包中，经由用户态的 socket 接收该数据包获取到内核地址，以绕过 KASLR 保护。</p>
<h2 id="4-2-代码执行"><a href="#4-2-代码执行" class="headerlink" title="4.2 代码执行"></a>4.2 代码执行</h2><p>通过 nft_payload 将通过数据包发送的 ROP 链复制到 nft_regs 的正常范围内存内，再通过 nft_bitwise 越界写以覆盖到返回地址。为了不覆写到 canary，起始地址必须限制在 canary 之后，返回地址之前。</p>
<p>ROP 链的构造如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// clearing interrupts</span></span><br><span class="line">payload[offset++] = kbase + cli_ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preparing credentials</span></span><br><span class="line">payload[offset++] = kbase + pop_rdi_ret; </span><br><span class="line">payload[offset++] = <span class="number">0x0</span>; <span class="comment">// first argument of prepare_kernel_cred</span></span><br><span class="line">payload[offset++] = kbase + prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">// commiting credentials</span></span><br><span class="line">payload[offset++] = kbase + mov_rdi_rax_ret;</span><br><span class="line">payload[offset++] = kbase + commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switching namespaces</span></span><br><span class="line">payload[offset++] = kbase + pop_rdi_ret;</span><br><span class="line">payload[offset++] = process_id;</span><br><span class="line">payload[offset++] = kbase + find_task_by_vpid;</span><br><span class="line">payload[offset++] = kbase + mov_rdi_rax_ret;</span><br><span class="line">payload[offset++]	= kbase + pop_rsi_ret;</span><br><span class="line">payload[offset++] = kbase + ini;</span><br><span class="line">payload[offset++] = kbase + switch_task_namespaces;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returning to userland</span></span><br><span class="line">payload[offset++] = kbase + swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">payload[offset++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)spawnShell;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br></pre></td></tr></table></figure>

<p>先清空 interrupt 标志位，屏蔽可屏蔽中断，防止 ROP 被打断。</p>
<p>之后通过调用 prepare_kernel_cred(0) 准备权限为 root 的进程 cred。prepare_kernel_cred 是内核中专门用来准备进程 cred 的，进程 cred 代表了进程的各种权限。当对 prepare_kernel_cred 传入的参数为 0 时，返回的就是 root 权限的进程 cred。</p>
<p>再通过调用 switch_task_namespaces(find_task_by_vpid(process_id), &amp;init_nsproxy) 将 EXP 进程的名称空间切换到 init_nsproxy。其中 process_id 为 EXP 进程的 pid，有许多办法可在用户态获取并保存下来，find_task_by_vpid 则会返回指定 pid 的 task_struct，init_nsproxy 为 init 进程也就是第一个进程的名称空间。由于使用 nf_tables 需要切换到新的 user + network 名称空间，所以这一步是必要的。当然，也可以在获得 root 权限后返回到用户态时再切换。</p>
<p>最后是返回到用户态，通过 swapgs; iret; 这一 gadget。需要在栈上依次准备好 IP、CS、EFLAGS、SP、SS 寄存器的内容，其中，IP 指向可弹出一个 shell 的函数，该函数通过调用 system(“/bin/sh”) 获得 shell。</p>
<h2 id="4-3-离开-softirq-上下文"><a href="#4-3-离开-softirq-上下文" class="headerlink" title="4.3 离开 softirq 上下文"></a>4.3 离开 softirq 上下文</h2><p>在漏洞发现者的 <a href="https://github.com/pqlx/CVE-2022-1015" target="_blank" rel="noopener">EXP</a> 中，在上一节的清空 interrupt 标志位操作后，还增加了一步离开 softirq 上下文的操作，这是因为在 EXP 作者的利用环境中，nft_do_chain 在 NET_RX_SOFTIRQ 类型 irqsoft 上下文中被调用。这一步不是必须的，但不执行这一步会让系统变得不稳定。</p>
<p>进入 softirq 的逻辑实现在 do_softirq 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macro to invoke __do_softirq on the irq stack. This is only called from</span></span><br><span class="line"><span class="comment"> * task context when bottom halves are about to be reenabled and soft</span></span><br><span class="line"><span class="comment"> * interrupts are pending to be processed. The interrupt stack cannot be in</span></span><br><span class="line"><span class="comment"> * use here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_softirq_own_stack()						\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	__this_cpu_write(hardirq_stack_inuse, <span class="literal">true</span>);			\</span><br><span class="line">	call_on_irqstack(__do_softirq, ASM_CALL_ARG0);			\</span><br><span class="line">	__this_cpu_write(hardirq_stack_inuse, <span class="literal">false</span>);			\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending &amp;&amp; !ksoftirqd_running(pending))</span><br><span class="line">        do_softirq_own_stack();</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span> = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> old_flags = current-&gt;flags;</span><br><span class="line">    <span class="keyword">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> in_hardirq;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">int</span> softirq_bit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Mask out PF_MEMALLOC as the current task context is borrowed for the</span></span><br><span class="line"><span class="comment">     * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC</span></span><br><span class="line"><span class="comment">     * again if the socket is related to swapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    current-&gt;flags &amp;= ~PF_MEMALLOC;</span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    softirq_handle_begin();</span><br><span class="line">    in_hardirq = lockdep_softirq_start();</span><br><span class="line">	</span><br><span class="line">    account_softirq_enter(current);</span><br><span class="line"></span><br><span class="line">    restart:</span><br><span class="line">    <span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    local_irq_enable();</span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vec_nr;</span><br><span class="line">        <span class="keyword">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">        h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vec_nr = h - softirq_vec;</span><br><span class="line">        prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">        kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">        trace_softirq_entry(vec_nr);</span><br><span class="line">        h-&gt;action(h); <span class="comment">// &lt;---------- net_rx_action is called here</span></span><br><span class="line">        trace_softirq_exit(vec_nr);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">            pr_err(<span class="string">"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n"</span>,</span><br><span class="line">                    vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">                    prev_count, preempt_count());</span><br><span class="line">            preempt_count_set(prev_count);</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= softirq_bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp;</span><br><span class="line">        __this_cpu_read(ksoftirqd) == current)</span><br><span class="line">        rcu_softirq_qs();</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line"></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="keyword">if</span> (time_before(jiffies, <span class="built_in">end</span>) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">            --max_restart)</span><br><span class="line">            <span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">        wakeup_softirqd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    account_softirq_exit(current);</span><br><span class="line">    lockdep_softirq_end(in_hardirq);</span><br><span class="line">    softirq_handle_end();</span><br><span class="line">    current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 soft_irq 处理完毕后，通过 local_irq_disable() 关中断，再通过 softirq_handle_end() 调整 preempt_count，原来的系统调用栈在 do_softirq 函数中通过调用 do_softirq_own_stack 宏恢复，最后重新打开中断。</p>
<p>由于 softirq_handle_end() 被内联在 __do_softirq() 中，在此 <a href="https://github.com/pqlx/CVE-2022-1015" target="_blank" rel="noopener">EXP</a> 中，作者仅通过 ROP 将控制流引导至 __do_softirq() 调用 softirq_handle_end() 处，调整了 preempt_count，并称可以无副作用地离开 softirq 的上下文，回到进程上下文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/" target="_blank" rel="noopener">How The Tables Have Turned: An analysis of two new Linux vulnerabilities in nf_tables</a></p>
<p><a href="https://ysanatomic.github.io/cve-2022-1015/" target="_blank" rel="noopener">CVE-2022-1015: A validation flaw in Netfilter leading to Local Privilege Escalation</a></p>
<p><a href="https://ysanatomic.github.io/netfilter_nf_tables/" target="_blank" rel="noopener">Dissecting the Linux Firewall: Introduction to Netfilter’s nf_tables</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">A Deep Dive into Iptables and Netfilter Architecture</a></p>
<p><a href="https://arthurchiao.art/blog/conntrack-design-and-implementation/" target="_blank" rel="noopener">Connection Tracking (conntrack): Design and Implementation Inside Linux Kernel</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/userspace-api/netlink/intro.html" target="_blank" rel="noopener">Introduction to Netlink — The Linux Kernel documentation</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/netlink.7.html" target="_blank" rel="noopener">netlink(7) - Linux manual page</a></p>
<p><a href="https://wiki.nftables.org/wiki-nftables/index.php/Portal:DeveloperDocs/nftables_internals" target="_blank" rel="noopener">Portal:DeveloperDocs/nftables internals - nftables wiki</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/02/06/cve-2022-1015/" data-id="cmd5slr2k000m0lo18hacf0ae" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../03/10/race_windown/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux 内核利用技巧 Racing against the clock
        
      </div>
    </a>
  
  
    <a href="../../01/slabUaf-to-pageUaf/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux 内核利用技巧 Slab UAF to Page UAF</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>