<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>TLB 缓存延迟刷新漏洞 CVE-2018-18281 解析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="author: chengjia4574@gmail.com of IceSword Lab , Qihoo 360 简介最近, 业内发现了一批内存管理系统的漏洞, project 0 的  Jann Horn 放出了其中一个漏洞 CVE-2018-18281 的 writeup, CVE-2018-18281 是一个 linux kernel 的通用漏洞, 这个漏洞的模式比较罕见, 不同于常规的">
<meta property="og:type" content="article">
<meta property="og:title" content="TLB 缓存延迟刷新漏洞 CVE-2018-18281 解析">
<meta property="og:url" content="http://yoursite.com/2019/03/08/cve-2018-18281/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="author: chengjia4574@gmail.com of IceSword Lab , Qihoo 360 简介最近, 业内发现了一批内存管理系统的漏洞, project 0 的  Jann Horn 放出了其中一个漏洞 CVE-2018-18281 的 writeup, CVE-2018-18281 是一个 linux kernel 的通用漏洞, 这个漏洞的模式比较罕见, 不同于常规的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-08T16:53:40.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.305Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019/03/08/cve-2018-18281" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2019-03-08T16:53:40.000Z" itemprop="datePublished">2019-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TLB 缓存延迟刷新漏洞 CVE-2018-18281 解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: <a href="mailto:chengjia4574@gmail.com">chengjia4574@gmail.com</a> of IceSword Lab , Qihoo 360</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近, 业内发现了一批内存管理系统的漏洞, project 0 的  <a href="https://twitter.com/tehjh" target="_blank" rel="noopener">Jann Horn</a> 放出了其中一个漏洞 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1695" target="_blank" rel="noopener">CVE-2018-18281</a> 的 <a href="https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html" target="_blank" rel="noopener">writeup</a>, CVE-2018-18281 是一个 linux kernel 的通用漏洞, 这个漏洞的模式比较罕见, 不同于常规的内存溢出类漏洞, 也不是常见的 UAF 漏洞, 它是由内存管理系统的底层逻辑错误导致的, 根本原因是 TLB 缓存没有及时刷新造成虚拟地址复用, 可以实现较为稳定的提权利用. </p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>linux 内核通过 <a href="https://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">多级页表</a> 实现虚拟内存机制, 为了提高访问速度, 一些映射信息会被缓存在 <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener">TLB</a> 里, cpu 在访问一个虚拟地址的时候, 会先查找 TLB , 如果没有命中, 才去遍历主存里的多级页表, 并将查找到的映射关系填入 TLB</p>
<p>反过来, 如果某个映射关系要解除, 除了在主存里的相关表项要删除, 还需要对多个cpu core 同步执行 TLB 刷新, 使得在所有 TLB 缓存里该映射关系消除, 否则就会出现不一致. </p>
<p>上述关于 TLB 和内存映射的说明只是简化版本, 用于简单理解这个漏洞的原因, 真正的实现不同操作系统, 不同体系架构, 都不一样. 可以查阅芯片手册, 如 <a href="http://kib.kiev.ua/x86docs/SDMs/317080-002.pdf" target="_blank" rel="noopener">TLBs, Paging-Structure Caches, and Their Invalidation</a>  和一些分析, 如 <a href="https://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank" rel="noopener">Reverse Engineering Hardware Page Table Caches</a></p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>先看两个系统调用</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/mremap.2.html" target="_blank" rel="noopener">mremap</a> 系统调用用来改变虚拟内存的映射区域</li>
<li><a href="https://linux.die.net/man/2/ftruncate" target="_blank" rel="noopener">ftruncate</a> 系统调用用来改变文件的大小到指定大小</li>
</ul>
<p>这两个系统调用表面上看八竿子打不着, 但在 linux 内核的实现里, 他们的调用链条会出现一个竞态条件异常</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) sys_mremap() -&gt; mremap_to()-&gt;move_vma()-&gt;move_page_tables(). </span><br><span class="line">move_page_tables() first calls move_ptes() <span class="keyword">in</span> a loop, </span><br><span class="line"><span class="keyword">then</span> performs a TLB flush with flush_tlb_range().</span><br><span class="line"></span><br><span class="line">2) sys_ftruncate()-&gt;do_sys_ftruncate()-&gt;do_truncate()-&gt;notify_change()</span><br><span class="line">-&gt;shmem_setattr()-&gt;unmap_mapping_range()-&gt;unmap_mapping_range_tree()</span><br><span class="line">-&gt;unmap_mapping_range_vma() -&gt;zap_page_range_single()-&gt;unmap_single_vma()</span><br><span class="line">-&gt;unmap_page_range()-&gt;zap_pud_range()-&gt;zap_pmd_range()-&gt;zap_pte_range()</span><br><span class="line">can concurrently access the page tables of a process that is <span class="keyword">in</span> move_page_tables(), </span><br><span class="line">between the move_ptes() loop and the TLB flush.</span><br></pre></td></tr></table></figure>

<p>mremap 底层实现主要是 move_ptes 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">89</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move_ptes</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">pmd_t</span> *old_pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">90</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> old_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> old_end,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">91</span>                 struct vm_area_struct *new_vma, <span class="keyword">pmd_t</span> *new_pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">92</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> new_addr, <span class="keyword">bool</span> need_rmap_locks)</span></span></span><br><span class="line"><span class="function">93 </span>&#123;</span><br><span class="line"><span class="number">94</span>         <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">95</span>         <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">96</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line"><span class="number">97</span>         <span class="keyword">pte_t</span> *old_pte, *new_pte, pte;</span><br><span class="line"><span class="number">98</span>         <span class="keyword">spinlock_t</span> *old_ptl, *new_ptl;</span><br><span class="line">======================== skip ======================</span><br><span class="line"><span class="number">133</span>         old_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &amp;old_ptl);</span><br><span class="line"><span class="number">134</span>         new_pte = pte_offset_map(new_pmd, new_addr);</span><br><span class="line"><span class="number">135</span>         new_ptl = pte_lockptr(mm, new_pmd);</span><br><span class="line"><span class="number">136</span>         <span class="keyword">if</span> (new_ptl != old_ptl)</span><br><span class="line"><span class="number">137</span>                 spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);</span><br><span class="line"><span class="number">138</span>         arch_enter_lazy_mmu_mode();</span><br><span class="line"><span class="number">139</span> </span><br><span class="line"><span class="number">140</span>         <span class="keyword">for</span> (; old_addr &lt; old_end; old_pte++, old_addr += PAGE_SIZE,</span><br><span class="line"><span class="number">141</span>                                    new_pte++, new_addr += PAGE_SIZE) &#123;</span><br><span class="line"><span class="number">142</span>                 <span class="keyword">if</span> (pte_none(*old_pte))</span><br><span class="line"><span class="number">143</span>                         <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">144</span>                 pte = ptep_get_and_clear(mm, old_addr, old_pte);</span><br><span class="line"><span class="number">145</span>                 pte = move_pte(pte, new_vma-&gt;vm_page_prot, old_addr, new_addr);</span><br><span class="line"><span class="number">146</span>                 pte = move_soft_dirty_pte(pte);</span><br><span class="line"><span class="number">147</span>                 set_pte_at(mm, new_addr, new_pte, pte);</span><br><span class="line"><span class="number">148</span>         &#125;</span><br><span class="line"><span class="number">149</span> </span><br><span class="line"><span class="number">150</span>         arch_leave_lazy_mmu_mode();</span><br><span class="line"><span class="number">151</span>         <span class="keyword">if</span> (new_ptl != old_ptl)</span><br><span class="line"><span class="number">152</span>                 spin_unlock(new_ptl);</span><br><span class="line"><span class="number">153</span>         pte_unmap(new_pte - <span class="number">1</span>);</span><br><span class="line"><span class="number">154</span>         pte_unmap_unlock(old_pte - <span class="number">1</span>, old_ptl);</span><br><span class="line"><span class="number">155</span>         <span class="keyword">if</span> (anon_vma)</span><br><span class="line"><span class="number">156</span>                 anon_vma_unlock_write(anon_vma);</span><br><span class="line"><span class="number">157</span>         <span class="keyword">if</span> (mapping)</span><br><span class="line"><span class="number">158</span>                 i_mmap_unlock_write(mapping);</span><br><span class="line"><span class="number">159</span> &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面代码, 有两点需要注意</p>
<ul>
<li>锁, 133 ~ 137 这几行目的是获取 pmd (pmd 指针指向一个存满了 pte 结构的页面) 的锁 (包括旧的和新的), 151 ~ 154 这几行是释放 pmd 锁</li>
<li>ptes 拷贝, 对一个 pmd 里的所有 pte 执行拷贝操作, 144 这一行调用 ptep_get_and_clear 将 old_pte 的值赋值给临时变量 pte 并清空旧的页表项, 147 这一行调用 set_pte_at 将刚刚的 pte 赋值给 new_pte 指针</li>
</ul>
<p>简单而言, move_ptes 将旧的 pmd 页的值 ( ptes ) 拷贝到了新的 pmd 页, 这就是 mremap 函数在底层的实现, 它并不需要删除旧地址对应的 pages, 只需要将旧地址关联到的 ptes 拷贝到新地址关联的页表, 这种拷贝是按照 pmd 为单位进行的, 每处理完一个 pmd, 对应的 pmd lock 就会释放.</p>
<p>ftruncate 函数将文件大小变为指定的大小, 如果新的值比旧的值小, 则需要将文件在内存的虚存空间变小, 这需要调用到 zap_pte_range 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1107</span> <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zap_pte_range</span><span class="params">(struct mmu_gather *tlb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1108</span>                                 struct vm_area_struct *vma, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1109</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1110</span>                                 struct zap_details *details)</span></span></span><br><span class="line"><span class="function">1111 </span>&#123;          </span><br><span class="line"><span class="number">1112</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">tlb</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line"><span class="number">1113</span>         <span class="keyword">int</span> force_flush = <span class="number">0</span>;</span><br><span class="line"><span class="number">1114</span>         <span class="keyword">int</span> rss[NR_MM_COUNTERS];</span><br><span class="line"><span class="number">1115</span>         <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="number">1116</span>         <span class="keyword">pte_t</span> *start_pte;</span><br><span class="line"><span class="number">1117</span>         <span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="number">1118</span>         <span class="keyword">swp_entry_t</span> entry;</span><br><span class="line"><span class="number">1119</span> </span><br><span class="line"><span class="number">1120</span> again:</span><br><span class="line"><span class="number">1121</span>         init_rss_vec(rss);</span><br><span class="line"><span class="number">1122</span>         start_pte = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);</span><br><span class="line"><span class="number">1123</span>         pte = start_pte;</span><br><span class="line"><span class="number">1124</span>         flush_tlb_batched_pending(mm);</span><br><span class="line"><span class="number">1125</span>         arch_enter_lazy_mmu_mode();</span><br><span class="line"><span class="number">1126</span>         <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">1127</span>                 <span class="keyword">pte_t</span> ptent = *pte;</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1146</span>                         ptent = ptep_get_and_clear_full(mm, addr, pte,</span><br><span class="line"><span class="number">1147</span>                                                         tlb-&gt;fullmm);</span><br><span class="line"><span class="number">1148</span>                         tlb_remove_tlb_entry(tlb, pte, addr);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1176</span>                 entry = pte_to_swp_entry(ptent);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1185</span>                 <span class="keyword">if</span> (unlikely(!free_swap_and_cache(entry)))</span><br><span class="line"><span class="number">1186</span>                         print_bad_pte(vma, addr, ptent, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">1187</span>                 pte_clear_not_present_full(mm, addr, pte, tlb-&gt;fullmm);</span><br><span class="line"><span class="number">1188</span>         &#125; <span class="keyword">while</span> (pte++, addr += PAGE_SIZE, addr != <span class="built_in">end</span>);</span><br><span class="line"><span class="number">1189</span> </span><br><span class="line"><span class="number">1190</span>         add_mm_rss_vec(mm, rss);</span><br><span class="line"><span class="number">1191</span>         arch_leave_lazy_mmu_mode();</span><br><span class="line"><span class="number">1192</span> </span><br><span class="line"><span class="number">1193</span>         <span class="comment">/* Do the actual TLB flush before dropping ptl */</span></span><br><span class="line"><span class="number">1194</span>         <span class="keyword">if</span> (force_flush)</span><br><span class="line"><span class="number">1195</span>                 tlb_flush_mmu_tlbonly(tlb);</span><br><span class="line"><span class="number">1196</span>         pte_unmap_unlock(start_pte, ptl);</span><br><span class="line">========================== skip ==========================</span><br><span class="line"><span class="number">1212</span>         <span class="keyword">return</span> addr;</span><br><span class="line"><span class="number">1213</span> &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面代码, 有三点需要注意, </p>
<ul>
<li>锁, 1122 行获取了 pmd 的锁, 1196 行释放了 pmd 的锁, 这里的 pmd 锁跟 move_ptes 函数里的是同一个东西</li>
<li>pte, 1146 行清空了页表项</li>
<li>page, 1185 行调用函数 free_swap_and_cache 释放了 pte 对应的 page cache, 将物理页面释放, 这是与 move_ptes 不同的地方</li>
</ul>
<p>将上述两个函数的流程放到一起分析, 假设下面这种情况:</p>
<p>假设一个进程有 A,B,C 三个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, 映射条件为: PROT_READ , MAP_SHARED</li>
<li>2) C 循环读取 X 的内容</li>
<li>3) A 调用 mremap 重新映射 X 到 Y, 这个调用会执行下面两个函数:<ul>
<li>3.1) move_ptes , 该函数做如下操作:<ul>
<li>3.1.1) 获取 X 页表和 Y 页表的锁</li>
<li>3.1.2) 遍历 X 对应页表的 pte , 释放之, 并在 Y 页表重建这些 pte </li>
<li>3.1.3) 释放 Y 页表的锁</li>
<li>3.1.4) 释放 X 页表的锁</li>
</ul>
</li>
<li>3.2) flush_tlb_range : 刷新 X 对应的 TLB 缓存 </li>
</ul>
</li>
<li>4) B 调用 ftruncate 将文件 a 的文件大小改为 0, 这个调用会执行下面操作:<ul>
<li>4.1) 获取 Y 页表的锁</li>
<li>4.2) 删除 Y 对应的页表</li>
<li>4.3) 释放 Y 对应的 pages</li>
<li>4.4) 刷新 Y 对应的 TLB 缓存</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明: </span><br><span class="line"></span><br><span class="line">实际上 X 和 Y 是两块内存区域, 也就是说可能比一个 pmd 所容纳的地址范围大, </span><br><span class="line">不管是 mremap 还是 ftruncate, 底层实现会将 X 和 Y 按照 pmd 为单位循环执行上表的操作, </span><br><span class="line">即上表所说的 X 页表实际指的是 X 内存区域里的某个 pmd, 这里是为了表达方便简化处理, </span><br><span class="line">下面的描述也是一样.</span><br></pre></td></tr></table></figure>

<p>这里存在的竞态条件是当 4.3 已经执行完毕 (3.1.3 释放 Y 锁 4.1 就可以执行), 地址 Y 的内存已经释放, 物理页面已经返回给 <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">伙伴系统</a> , 并再一次分配给新的虚拟内存, 而此时 3.2 还没有执行, 这种情况下, 虽然 X 的映射关系在页表里已经被清空, 但在 TLB 缓存里没有被清空, 线程 C 依然可以访问 X 的内存, 造成地址复用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">除了可以用 ftruncate 函数来跟 mremap 竞争, 还有一个 linux 系统特有的</span><br><span class="line">系统函数 fallocate 也可以起到同样的效果, 原因很简单, </span><br><span class="line">fallocate 和 ftruncate 的底层调用链是一样的</span><br><span class="line"></span><br><span class="line">sys_fallocate()-&gt;shmem_fallocate()-&gt;shmem_truncate_range()</span><br><span class="line">-&gt;shmem_undo_range()-&gt;truncate_inode_page()-&gt;unmap_mapping_range</span><br></pre></td></tr></table></figure>

<p>v4.9 之前的内核都是上述列表显示的代码逻辑</p>
<p>v4.9 之后的内核, move_ptes 的逻辑与上述有些许不同 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">在 versions &gt; 4.9 的 linux 内核, Dirty 标记的页面会在 move_ptes 函数内部刷新 TLB , </span><br><span class="line">而不是等到 3.2 由 flush_tlb_range 函数去刷新, 因此, race 发生之后, </span><br><span class="line">线程 C 能通过 X 访问到的内存都是之前 non-Dirty 的页面, 即被写过的页面都无法复用. </span><br><span class="line"></span><br><span class="line">这点改变会对 poc 和 exploit 造成什么影响? 留给大家思考.</span><br></pre></td></tr></table></figure>

<h2 id="简单版的-poc"><a href="#简单版的-poc" class="headerlink" title="简单版的 poc"></a>简单版的 poc</h2><p>根据上述分析, 一个简单的 poc 思路就出来了, 通过不断检测线程 C 从地址 X 读取的内容是不是初始内容就可以判断 race 是否被触发, 正常情况下, C 读取 X 只会有两种结果, 一种是 mremap 彻底完成, 即 3.2 执行完毕, 此时地址 X 为无效地址, C 的读操作引发进程奔溃退出, 第二种是 mremap 还未完成, C 读取的地址返回的是 X 的初始内容, 只有这两种情况才符合 mremap 函数的定义. 但是由于漏洞的存在, 实际运行会存在第三种情况, 即 C 读取 X 不会奔溃(3.2 还没执行, 地址映射还有效), 但内容变了( 4.3 执行完毕, 物理页面已经被其他地方复用)</p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/CVE-2018-18281" target="_blank" rel="noopener">这份 poc</a> 可以清晰看出 race 是怎么发生的, 需要注意, 这份 poc 必须配合内核补丁才能稳定触发 race , 否则命中率非常低, 补丁通过在 move_page_tables 函数调用 flush_tlb_range 之前(即 3.2 之前)增加一个大循环来增大 race 条件的时间窗口以提高命中率</p>
<p>上述 poc 的运行结果是, 大部分情况下 poc 奔溃退出, 少数情况下读取 X 会返回一个被其他地方复用的页面</p>
<p>这离稳定提权还有很远的距离, 为了得到稳定利用, 至少有两个问题需要解决:</p>
<ul>
<li>如何提高 race 的命中率</li>
<li>怎么实现提权</li>
</ul>
<h2 id="如何提高-race-的命中率"><a href="#如何提高-race-的命中率" class="headerlink" title="如何提高 race 的命中率"></a>如何提高 race 的命中率</h2><p>要提高本漏洞 race 的命中率, 就是要增大 move_ptes 函数和 flush_tlb_range 函数之间的时间间隔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么才能增加这俩函数执行的时间间隔呢?</span><br></pre></td></tr></table></figure>

<p>这里要引入linux内核的 <a href="https://en.wikipedia.org/wiki/Linux_kernel#PREEMPTION" target="_blank" rel="noopener">进程抢占</a> 概念, 如果目标内核是可抢占的 (CONFIG_PREEMPT=y) , 则如果能让进程在执行 flush_tlb_range 函数之前被抢占, 那么 race 的时间窗口就够大了, 用户空间的普通程序能不能影响某个进程的调度策略呢? 答案是肯定的.</p>
<p>有两个系统函数可以影响进程的调度</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html" target="_blank" rel="noopener">sched_setaffinity</a> 函数用来绑定进程到某个 cpu core</li>
<li><a href="http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html" target="_blank" rel="noopener">sched_setscheduler</a> 函数用来设置进程的调度策略和调度参数</li>
</ul>
<p>使用这两个函数将 poc 修改为下面的方案,</p>
<p>新建 A,B,C,D 四个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE </li>
<li>2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则调用 ftruncate 将文件 a 的文件大小改为 0</li>
<li>3) A 调用 mremap 重新映射 X 到 Y, 这将执行下面两个函数:<ul>
<li>3.1) move_ptes</li>
<li>3.2) flush_tlb_range</li>
</ul>
</li>
<li>4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C</li>
<li>5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">mremap 执行 move_ptes 函数会引发内存状态变化, 这种变化可以通过</span><br><span class="line">用户态文件 /proc/pid/status 文件获取, 这就是线程 D 的作用</span><br></pre></td></tr></table></figure>

<p>此时, 通过监控线程 D 唤醒 C, 由于A 和 C 绑定在同一个核心 c1, 且 A 的调度策略被设置<br>为最低优先级 SCHED_IDLE, C 的唤醒将抢占 A 的执行, 如此一来, 3.2 的执行就可能被延迟.<br>C 被唤醒后立即执行 ftruncate 释放 Y 的内存触发漏洞.</p>
<p>通过上述方案可以理论上让线程 A 在执行 3.1 后, 执行 3.2 前被挂起,<br>从而扩大 3.1 和 3.2 的时间间隔 </p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.old.c" target="_blank" rel="noopener">这个 poc</a> 是根据上述思路写的</p>
<h2 id="改进版的-poc"><a href="#改进版的-poc" class="headerlink" title="改进版的 poc"></a>改进版的 poc</h2><p>实测发现上述 poc 触发率还是低, 借鉴 Jann Horn 的思路, 继续如下修改 poc </p>
<p>改进版方案: 新建 A,B,C,D,E 五个线程:</p>
<ul>
<li>1) A 映射一个文件 a 到地址 X, A 绑定到核 c1, A 调度策略设置为 SCHED_IDLE </li>
<li>2) C 绑定到核 c1, C 阻塞在某个 pipe, pipe 返回则立即将 A 重新绑定到核 c4, 并调用 ftruncate 将文件 a 的文件大小改为 0</li>
<li>3) A 调用 mremap 重新映射 X 到 Y<ul>
<li>3.1) move_ptes</li>
<li>3.2) flush_tlb_range</li>
</ul>
</li>
<li>4) D 绑定到核 c2, 监控进程的内存映射情况,如果发生变化则通过写 pipe 唤醒 C</li>
<li>5) B 绑定到核 c3, 循环读取 X 的内容, 并判断是否还是初始值</li>
<li>6) E 绑定到核 c4, 执行一个死循环.</li>
</ul>
<p>改进的地方有两点, 1 是增加一个 E 线程绑定到核 c4 并执行死循环, 2 是线程 C 被唤醒后立刻重绑定线程 A 到核 c4, 即让 A 和 E 在同一个核上</p>
<p>这个改变会提高 race 触发的命中率, 个人判断原因是由于当 C 的管道返回后手动执行重绑定操作会比执行其他操作更容易导致 A 立即被挂起 </p>
<p><a href="https://github.com/jiayy/android_vuln_poc-exp/blob/master/CVE-2018-18281-Android/poc.c" target="_blank" rel="noopener">改进版 poc 代码</a> 是根据上述思路写的</p>
<p>利用这个 poc, 我们可以将这个漏洞的 race 命中率提升到可以接受的程度.</p>
<h2 id="物理页面管理"><a href="#物理页面管理" class="headerlink" title="物理页面管理"></a>物理页面管理</h2><p>现在我们可以在比较短的时间内稳定触发漏洞, 得到一片已经被释放的物理页面的使用权,<br>而且可读可写, 怎么利用这一点来提权?</p>
<p>这里需要了解物理内存的分配和释放细节, 物理内存管理属于<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">伙伴系统</a>, 参考 <a href="https://github.com/pjhades/tolarian-academy/blob/master/linux-mm.md" target="_blank" rel="noopener">内存管理</a></p>
<p>物理页面的管理是分层的:</p>
<ul>
<li>node: NUMA 体系架构有 node 的概念, 不同 node 的物理内存是分开管理的</li>
<li>zone: 根据物理内存的区域分若干种 zone, 不同场景会优先向不同的 zone 分配 , 比如用户空间申请内存, 会优先从 ZONE_NORMAL 这个 zone 分配, 如果不够再从其他 zone 分配<ul>
<li>ZONE_DMA</li>
<li>ZONE_NORMAL</li>
<li>ZONE_HIGHMEM</li>
<li>其他</li>
</ul>
</li>
<li>migration-type: 内核根据可迁移性对页面进行分组管理, 用于 anti-fragmentation, 可以参考 <a href="https://www.jeanleo.com/2018/09/06/%E3%80%90linux%E5%86%85%E5%AD%98%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E9%A1%B5%E9%9D%A2%E8%BF%81%E7%A7%BB/" target="_blank" rel="noopener">内核页面迁移与反碎片机制</a> <ul>
<li>MIGRATE_UNMOVABLE</li>
<li>MIGRATE_RECLAIMABLE</li>
<li>MIGRATE_MOVABLE</li>
</ul>
</li>
</ul>
<p>__alloc_pages_nodemask 函数是 zoned buddy allocator 的分配入口, 它有快慢两条路径:</p>
<ul>
<li>get_page_from_freelist , 快路径<ul>
<li>1) if order == 0, 从 per-cpu 的指定 zone 指定 migratetype 的 cache list 里获取 page<ul>
<li>pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp</li>
<li>list = &amp;pcp-&gt;lists[migratetype]</li>
<li>page = list_entry(list-&gt;next, struct page, lru);</li>
</ul>
</li>
<li>2) __rmqueue_smallest : 在指定迁移类型下自底向上进行各阶遍历查找所需的空闲页面<ul>
<li>area = &amp;zone-&gt;free_area[current_order]</li>
<li>list = &amp;area-&gt;free_list[migratetype]</li>
<li>page = list_entry(list-&gt;next, struct page, lru);</li>
</ul>
</li>
<li>3) __rmqueue_cma, <a href="https://www.jeanleo.com/2018/09/07/%E3%80%90linux%E5%86%85%E5%AD%98%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88cma%EF%BC%89/" target="_blank" rel="noopener">连续内存分配器</a> 用于DMA映射框架下提升连续大块内存的申请</li>
<li>4) __rmqueue_fallback, 如果在指定迁移类型下分配失败，且类型不为MIGRATE_RESERVE时, 就在 fallbacks 数组里找到下一个 migratetype, 由此获得的阶号和迁移类型查找zone-&gt;free_area[]-&gt;free_list[]空闲页面管理链表</li>
</ul>
</li>
<li>__alloc_pages_slowpath, 慢路径<ul>
<li>略</li>
</ul>
</li>
</ul>
<p>从漏洞利用的角度, 我们希望将漏洞释放的物理页面尽可能快的被重新分配回来, 所以, 用来触发漏洞释放物理页面的场景和重新申请物理页面用来利用的场景, 这两种场景的 zone, migratetype 最好一致, 而且这两个场景的触发最好在同一个 cpu core 上.</p>
<p>比如, 触发漏洞时, 通过用户空间 mmap 一片地址, 然后访问这片地址触发物理内存分配, 这种分配大概率是从 ZONE_NORMAL 而来, 而且页面大概率是 MIGRATE_MOVABLE 的, 然后用 ftruncate 释放, 这些页面很可能会挂在当前 cpu 的 freelist 上.  所以, 漏洞利用的时候如果是在其他 cpu core 触发申请物理页面, 则可能申请不到目标页面, 或者, 触发申请物理页面的场景如果是某种 dma 设备, 那么也大概率命中不到目标页面.</p>
<h2 id="怎么实现提权"><a href="#怎么实现提权" class="headerlink" title="怎么实现提权"></a>怎么实现提权</h2><p>根据上述物理内存管理的分析, 选择使用文件的 page cache 用于重新申请目标物理页面, 在此基础上, 想办法实现提权</p>
<p>linux 上硬盘文件的内容在内核用 page cache 来维护, 如果漏洞触发后释放的页面被用于某个文件的 page cache, 则我们拥有了读写该文件的能力, 如果这个文件恰好是用户态的重要动态库文件, 正常情况下普通进程无法改写这种文件, 但通过漏洞普通进程可以改写它, 这样就可以通过修改动态库文件的代码段来提权.</p>
<p>上述利用思路的关键有3点:</p>
<ul>
<li>选择目标动态库文件</li>
<li>选择目标文件要改写的位置</li>
<li>提高目标位置所在页面的命中率</li>
</ul>
<p>这个动态库必须是能被高权限进程所使用<br>目标位置最好是页面对齐的, 这样目标位置可以以页面为单位加载进内存, 或者以页面为单位置换到硬盘<br>目标位置被调用的时机不能太频繁, 要不然修改操作会影响系统稳定性, 而且调用时机必须可以由普通进程触发</p>
<p>下面是一个符合上述条件的动态库和函数:</p>
<ul>
<li>libandroid_runtime.so 动态库</li>
<li>com_android_internal_os_Zygote_nativeForkAndSpecialize 函数<ul>
<li>这个函数被 zygote 调用, zygote 进程是一个特权进程</li>
<li>这个函数在 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) 文件的偏移是 0x157000, 这个偏移是页面对齐的</li>
<li>这个函数一般情况下不会被调用, 只有启动新的 app 时会被 zygote 调用, 可以由普通 app 触发 zygote 去执行</li>
</ul>
</li>
</ul>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>漏洞触发 race 后, 让释放的物理页面刚好被用于目标页面( libandroid_runtime.so 文件的 offset = 0x157000 这个页面), 再可以通过 UAF 地址注入 shellcode 到目标位置, 从而改写 com_android_internal_os_Zygote_nativeForkAndSpecialize 函数的代码逻辑, 最后发消息触发 zygote 去执行 shellcode</p>
<p><span id="raise_pagecache_hit"></span></p>
<h2 id="如何提高文件-page-cache-命中率"><a href="#如何提高文件-page-cache-命中率" class="headerlink" title="如何提高文件 page cache 命中率"></a>如何提高文件 page cache 命中率</h2><p>这节解决的问题是, 怎么控制 race 释放的页面刚好能被目标页面使用</p>
<p><a href="https://arxiv.org/pdf/1710.00551.pdf" target="_blank" rel="noopener">这篇论文</a> 的 section VIII-B 介绍了一种算法用于精确控制一个 file page cache 的加载 </p>
<ul>
<li>1) 打开一个大文件 a, mmap 到内存 </li>
<li>2) 打开目标文件 b, mmap 到内存</li>
<li>3) 在一个循环内, 执行: <ul>
<li>3.1) 按照 pagesize 逐页面读取 a 的内容<pre><code>这会导致内核申请大量 page cache 来装载文件 a, </code></pre>  从而迫使其他文件的 page cache 被置换到硬盘</li>
<li>3.2) 判断目标页面 X 是否在内存里, 如果不是, 跳转到 4.1</li>
</ul>
</li>
<li>4) 在一个循环内, 执行:<ul>
<li>4.1) 按照 pagesize 逐页面读取 b 的内容, 但遇到目标页面 X 则跳过<pre><code>这会导致目标文件除目标页面 X 之外其他页面被重新装载回内存</code></pre></li>
<li>4.2) 判断目标页面 X 是否在内存里, 如果是, 跳转到 3.1</li>
</ul>
</li>
<li>5) 如果读取完全部 b 的内容, 目标页面 X 仍然没有在内存里, 结束.</li>
</ul>
<p>通过上述算法, 可以让一个目标文件的目标页面 X 被置换到硬盘, 而该文件其他页面保留在内存里, 这样在漏洞触发之后, 再来访问目标页面, 则很大机会会分配刚刚释放的物理页面给目标页面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line"></span><br><span class="line">mincore 函数可以用来判断一个区域内的内存是在物理内存中或被交换出磁盘</span><br><span class="line">上述算法在 linux 的实现依赖于 mincore</span><br></pre></td></tr></table></figure>

<h2 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h2><p>我改了一份exploit 代码 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2018-18281" target="_blank" rel="noopener">在这里</a>, 主要包含下面几个文件:</p>
<ul>
<li>compile.sh</li>
<li>shellcode.s</li>
<li>exp.c</li>
<li>watchdog.c</li>
</ul>
<h3 id="compile-sh"><a href="#compile-sh" class="headerlink" title="compile.sh"></a>compile.sh</h3><p>这是编译脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  </span><br><span class="line">2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode </span><br><span class="line">3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode </span><br><span class="line">4) xxd -i arm_shellcode.bin &gt; arm_shellcode.h </span><br><span class="line">5) make</span><br></pre></td></tr></table></figure>
<p>1~3 是将汇编文件 arm_shellcode.s 编译成二进制并将可执行文件的代码段 (.text) 提取到文件 arm_shellcode.bin </p>
<p>4 使用 linux 的 xxd 工具将 arm_shellcode.bin 放进一个 c 语言分格的数组，后续在 c 代码里以数组变量的形式操作它</p>
<p>5 根据 Android.mk 编译可执行文件</p>
<h2 id="shellcode-s"><a href="#shellcode-s" class="headerlink" title="shellcode.s"></a>shellcode.s</h2><p>下面简单看一下 shellcode.s 汇编,不感兴趣可以略过</p>
<ul>
<li><p>shellcode.s 本身很简单: 读取文件 “/proc/self/attr/current” ，然后将读取的内容作为参数调用 sethostname 函数，从而更改系统的 hostname</p>
</li>
<li><p>因为普通 app 没有权限调用系统函数 ‘sethostname’, 本 exploit 通过注入 shellcode.s 到 libandroid_runtime.so, 然后触发 zygote 进程执行 shellcode.s 达到越权执行的目的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open file</span></span><br><span class="line">_start:</span><br><span class="line">mov x0, #<span class="number">-100</span></span><br><span class="line">adrp x1, _start</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> We are changing the page-relative alignment of the shellcode, so normal</span></span><br><span class="line"><span class="comment">// aarch64 RIP-relative addressing doesn't work.</span></span><br><span class="line">add x1, x1, attr_path-file_start</span><br><span class="line">mov x2, #<span class="number">0</span></span><br><span class="line">mov x8, #<span class="number">0x38</span></span><br><span class="line">svc #<span class="number">0</span></span><br><span class="line"></span><br><span class="line">attr_path:</span><br><span class="line">.ascii <span class="string">"/proc/self/attr/current\0"</span></span><br></pre></td></tr></table></figure>

<p>第一段汇编作用是 open 文件 “/proc/self/attr/current”, #0x38 是系统调用号，对应系统调用 __NR_openat (系统调用号定义： include/uapi/asm-generic/unistd.h), 将 0x38 放入 x8 寄存器，svc #0 指令触发软中断，进入内核系统调用, 根据 openat 函数的定义, x1 寄存器存放要打开的文件路径的地址, x0 和 x2 这里忽略.</p>
<p>这段汇编执行后，x0寄存器存放返回值，即打开文件的 fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from file</span></span><br><span class="line">sub sp, sp, #<span class="number">128</span></span><br><span class="line">mov x1, sp</span><br><span class="line">mov x2, #<span class="number">128</span></span><br><span class="line">mov x8, #<span class="number">0x3f</span></span><br><span class="line">svc #<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>第二段汇编执行 read 系统调用，读取 128 字节放入栈, #0x3f 对应系统调用 read, x0 存放要读取文件的 fd, x1 是栈顶指针 sp, 在此之前，sp 被移动了#128 字节，相当于一个 128 字节的栈数组作为 buf传给 read 函数第二个参数, x2 是要读取的长度, 这里是 128</p>
<p>这段汇编执行后, sp 指向的位置存放文件 ‘/proc/self/attr/current’ 的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shove file contents into hostname</span></span><br><span class="line">mov x1, x0</span><br><span class="line">mov x0, sp</span><br><span class="line">mov x8, #<span class="number">0xa1</span></span><br><span class="line">svc #<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第三段汇编执行 sethostname 系统调用, #0xa1 对应系统调用 sethostname, x0 即要更新的域名字符串, 这里放入 sp 指针， 即将上一步 read 函数读取的 buf 值作为 sethostname 的参数 name, x1 是长度, 这里值是上一步read 的返回值</p>
<p>这段汇编执行后, hostname 将被更新为文件 ‘/proc/self/attr/current’ 的内容</p>
<h2 id="watchdog-c"><a href="#watchdog-c" class="headerlink" title="watchdog.c"></a>watchdog.c</h2><p>这个文件的作用是不断调用 exp 可执行文件并监控 exploit 是否成功, 之所以需要这个主调程序是由于这个漏洞在触发的时候, 大部分情况会引发程序奔溃, 这时候需要一个看门狗程序不断重启它</p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><p>这个文件实现了 exploit 的主体功能</p>
<ul>
<li>kickout_victim_page 函数</li>
<li>idle_worker 线程</li>
<li>spinner 线程</li>
<li>nicer_spinner 线程</li>
<li>read_worker 线程</li>
<li>segv_handler 函数</li>
</ul>
<p>kickout_victim_page 函数实现了 <a href="#raise_pagecache_hit">如何提高文件 page cache 命中率</a> 的算法, 最开始执行</p>
<p>idle_worker 线程用于触发 mremap 调用, 先绑定到 c1, spinner 唤醒后重绑定 idle_worker 到 c3, 调度策略为 SCHED_IDLE , 其他线程都是普通调度策略</p>
<p>spinner 线程用于触发 fallocate (跟 ftruncate 效果类似) 调用, 绑定到 c2 </p>
<p>nicer_spinner 线程绑定到 c3, 用于抢占 idle_worker  的 cpu 使用权</p>
<p>read_worker 线程绑定到 c4, 用于监控目标内存, 一旦发现 race 成功触发, 则注入 shellcode 到目标内存</p>
<p>segv_handler 函数是段错误处理函数, 这里会再一次检测 shellcode 是否已经成功注入到目标文件, 如果是, 则通知 watchdog 停止重启 exp</p>
<p>执行 exploit 之前, libandroid_runtime.so 如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/lib64/libandroid_runtime.so</span><br><span class="line"></span><br><span class="line">root@jiayy:CVE-2018-18281<span class="comment"># xxd -s 0x157000 -l 100 libandroid_runtime.so </span></span><br><span class="line">00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.</span><br><span class="line">00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.</span><br><span class="line">00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T</span><br><span class="line">00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....&#123;E..OD..WC.</span><br><span class="line">00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.</span><br><span class="line">00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............&#123;...</span><br><span class="line">00157060: 9c01 0090</span><br></pre></td></tr></table></figure>

<p>执行 exploit 之后, libandroid_runtime.so 如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/lib64/libandroid_runtime.so</span><br><span class="line"></span><br><span class="line">root@jiayy:CVE-2018-18281<span class="comment"># xxd -s 0x157000 -l 100 libandroid_runtime.so </span></span><br><span class="line">00157000: 0000 20d4 0000 20d4 600c 8092 0100 0090  .. ... .`.......</span><br><span class="line">00157010: 2120 0191 0200 80d2 0807 80d2 0100 00d4  ! ..............</span><br><span class="line">00157020: ff03 02d1 e103 0091 0210 80d2 e807 80d2  ................</span><br><span class="line">00157030: 0100 00d4 e103 00aa e003 0091 2814 80d2  ............(...</span><br><span class="line">00157040: 0100 00d4 0000 0014 2f70 726f 632f 7365  ......../proc/se</span><br><span class="line">00157050: 6c66 2f61 7474 722f 6375 7272 656e 7400  lf/attr/current.</span><br><span class="line">00157060: eaff ff17                                ....</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1695" target="_blank" rel="noopener">mremap TLB flush too late with concurrent ftruncate</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.html" target="_blank" rel="noopener">Taking a page from the kernel’s book: A TLB issue in mremap</a></li>
<li><a href="http://140.120.7.21/LinuxRef/mmLinux/VmOutline/pagecache.html" target="_blank" rel="noopener">Swapping and the Page Cache</a></li>
<li><a href="https://lkml.org/lkml/2018/11/2/423" target="_blank" rel="noopener">patch 讨论</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/08/cve-2018-18281/" data-id="cmd5slr2c000f0lo1gfm1gmio" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../11/28/CVE-2019-13272/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PTRACE_TRACEME 本地提权漏洞解析
        
      </div>
    </a>
  
  
    <a href="../../../../2018/07/25/kdhack/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">开启Win10RS4ARM64远程内核调试之旅</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>