<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>Chrome OS基于EXT4 Encryption的用户数据安全保护机制 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="author : suezi(@suezi86) of IceSword Lab , Qihoo 360    概述 EXT4 Encryption简述 EXT4 Encryption详述 EXT4 Encryption的主要数据结构 使能EXT4 Encryption 添加master key的流程 Set Encryption Policy流程 creat file流程 open file流程">
<meta property="og:type" content="article">
<meta property="og:title" content="Chrome OS基于EXT4 Encryption的用户数据安全保护机制">
<meta property="og:url" content="http://yoursite.com/2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="author : suezi(@suezi86) of IceSword Lab , Qihoo 360    概述 EXT4 Encryption简述 EXT4 Encryption详述 EXT4 Encryption的主要数据结构 使能EXT4 Encryption 添加master key的流程 Set Encryption Policy流程 creat file流程 open file流程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-10-30T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.266Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2017-10-30T00:00:00.000Z" itemprop="datePublished">2017-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Chrome OS基于EXT4 Encryption的用户数据安全保护机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="http://weibo.com/suezi86" target="_blank">suezi(@suezi86)</a> of IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<ul>
<li><a href="#overview">概述</a></li>
<li><a href="#EXT4-Encryption-brief">EXT4 Encryption简述</a></li>
<li><a href="#EXT4-Encryption-detail">EXT4 Encryption详述</a><ul>
<li><a href="#EXT4-Encryption-datastruct">EXT4 Encryption的主要数据结构</a></li>
<li><a href="#Enable-EXT4-Encryption">使能EXT4 Encryption</a></li>
<li><a href="#Add-Master-Key">添加master key的流程</a></li>
<li><a href="#Set-Encryption-Policy">Set Encryption Policy流程</a></li>
<li><a href="#EXT4-Encryption-file-creat">creat file流程</a></li>
<li><a href="#EXT4-Encryption-file-open">open file流程</a></li>
<li><a href="#EXT4-Encryption-file-read">read file流程</a></li>
<li><a href="#EXT4-Encryption-file-read">write file流程</a></li>
</ul>
</li>
<li><a href="#end">结语</a></li>
<li><a href="#refer">参考资料</a></li>
</ul>
<h2 id="概述-回页首"><a href="#概述-回页首" class="headerlink" title="概述 回页首"></a>概述 <a href="#top">回页首</a></h2><p><span id="overview"></span></p>
<p>&emsp;  自2015年开发的EXT4 Encryption经过两年的验证性使用，Google终于在年初的时候将EXT4 Encryption 合并入Chrome OS用于保护用户的隐私数据，完成与eCryptfs同样的功能，简称该技术为Dircrypto。当前，Chrome OS仍是eCryptfs和Dircrypto两种技术并存，但优先采用Dircrypto，这表明Dircrypto将成为以后的主流趋势。本文试图阐述该技术的实现原理。<br>&emsp;  与eCryptfs一样，EXT4 Encryption用于完成文件（包括目录）和文件名的加密，以实现多用户系统中各个用户私有数据的安全，即使在设备丢失或被盗的情况下，用户隐私数据也不会轻易被人窥见。本文着重介绍文件内容加解密，文件名加解密留给读者自行研究，技术要点主要包括：加解密模型、密钥管理、EXT4 Encrytion功能的开/关及参数设定操作。</p>
<h2 id="EXT4-Encryption-简述-回页首"><a href="#EXT4-Encryption-简述-回页首" class="headerlink" title="EXT4 Encryption 简述 回页首"></a>EXT4 Encryption 简述 <a href="#top">回页首</a></h2><p><span id="EXT4-Encryption-brief"></span></p>
<p>&emsp;  创立eCryptfs十年之后，其主要的作者Michael Halcrow已从之前的IBM转向服务Google。Google在保护用户数据隐私方面具有强烈的需求，应用在其旗下的Android、Chrome OS及数据中心，此时采用的文件系统都是EXT4，eCryptfs属于堆叠在EXT4上的文件系统，性能必定弱于直接在EXT4实现加密，恰好EXT4的主要维护者是Google的Theodore Ts’o ，因此由Michael Halcrow主导、Theodore Ts’o协助开发完成EXT4 Encryption，目标在于“Harder，Better，Faster，Stronger”。<br>&emsp;  相比eCryptfs，EXT4 Encryption在内存使用上有所优化，表现在read page时，直接读入密文到page cache并在该page中解密；而eCryptfs首先需要调用EXT4接口完成读入密文到page cache，然后再解密该page到另外的page cache页，内存花销加倍。当然，write page时，两者都不能直接对当前page cache加密，因为cache的明文内容需要保留着后续使用。在对文件加密的控制策略上，两者都是基于目录，但相比eCryptfs使用的mount方法，EXT4 Encryption采用ioctl的策略显得更加方便和灵活。另外，在密钥管理方面，两者也不相同。<br>&emsp;  EXT4 Encryption加/解密文件的核心思想是：每个用户持有一个64 Bytes的master key，通过master key的描述（master key descriptor，实际使用时一般采用key signature加上”ext4:”前缀）进行识别，每个文件单独产生一个16 Bytes的随机密钥称为nonce，之后以nonce做为密钥，采用AES-128-ECB算法加密master key，产生derived key。加/解密文件时采用AES-256-XTS算法，密钥是derived key。存储文件时，将包含有格式版本、内容加密算法、文件名加密算法、旗标、master key描述、nonce等信息在内的数据保存在文件的xattr扩展属性中。而master key由用户通过一些加密手段进行存储，在激活EXT4 Encryption前通过keys的系统调用以“logon”类型传入内核keyring，即保证master只能被应用程序创建及更新但不能被应用程序读取。加密是基于目录树的形式进行，加密策略通过EXT4_IOC_SET_ENCRYPTION ioctl对某个目录进行下发，其子目录或文件自动继承父目录的属性，ioctl下发的内容包括策略版本号、文件内容加密模式、文件名加密模式、旗标、master key的描述。文件read操作时，从磁盘block中读入密文到page cache并在该page中完成解密，然后拷贝到应用程序；文件write时采用write page的形式写入磁盘，但不是在当前page cache中直接加密，而是将加密后的密文保存在另外的page中。<br>&emsp;  和eCryptfs一样，EXT4 Encryption在技术实现时利用了page cache机制的Buffered I/O,换而言之就是不支持Direct I/O。其加/解密的流程如图一所示。</p>
<center>          
![](ext4-encryption-encrypt-decrypt-flow.png "图一")   
图一 EXT4 Encryption加/解密流程
</center>

<p>图一中，在创建加密文件时通过get_random_bytes函数产生16 Bytes的随机数，将其做为nonce保存到文件的xattr属性中；当打开文件时取出文件的nonce和master key的描述，通过master key描述匹配到应用程序下发的master key；然后以nonce做为密钥，采用AES-128-ECB算法加密master key后产生derived key，加/解密文件时采用该derived key做为密钥，加密算法由用户通过ioctl下发并保存到xattr的”contents_encryption_mode”字段，目前版本仅支持AES-256-XTS；加/解密文件内容时调用kernel crypto API完成具体的加/解密功能。<br>&emsp;  下面分别从EXT4 Encryption使用的数据结构、内核使能EXT4 Encryption功能、如何添加master key到keyring、如何开启EXT4 Encryption功能、创建和打开加密文件、读取和解密文件、加密和写入加密文件等方面详细叙述。</p>
<h2 id="EXT4-Encryption详述-回页首"><a href="#EXT4-Encryption详述-回页首" class="headerlink" title="EXT4 Encryption详述 回页首"></a>EXT4 Encryption详述 <a href="#top">回页首</a></h2><p><span id="EXT4-Encryption-detail"></span></p>
<h3 id="EXT4-Encryption的主要数据结构-回页首"><a href="#EXT4-Encryption的主要数据结构-回页首" class="headerlink" title="EXT4 Encryption的主要数据结构 回页首"></a>EXT4 Encryption的主要数据结构 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-datastruct"></span></p>
<p>&emsp;  通过数据结构我们可以窥视到EXT4 Encryption的密钥信息的保存和使用方式，非常有利于理解该加密技术。涉及到主要数据结构如下：<br>&emsp;  master key的payload的数据表示如清单一所示，应用程序通过add_key系统调用将其和master key descriptor传入内核keyring。</p>
<h4 id="清单一-master-key"><a href="#清单一-master-key" class="headerlink" title="清单一 master key"></a>清单一 master key</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is passed in from userspace into the kernel keyring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_key</span> &#123;</span></span><br><span class="line">        __u32 mode;</span><br><span class="line">        <span class="keyword">char</span> raw[EXT4_MAX_KEY_SIZE];</span><br><span class="line">        __u32 <span class="built_in">size</span>;</span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>&emsp;  EXT4 Encryption的文件加密信息的数据存储结构如清单二结构体struct ext4_encryption_context所示，每个文件都对应保存着这样的一个数据结构在其xattr中，包含了加密版本、文件内容和文件名的加密算法、旗标、master key descriptor和随机密钥nonce。</p>
<h4 id="清单二-加密信息存储格式"><a href="#清单二-加密信息存储格式" class="headerlink" title="清单二 加密信息存储格式"></a>清单二 加密信息存储格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encryption context for inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Protector format:</span></span><br><span class="line"><span class="comment"> *  1 byte: Protector format (1 = this version)</span></span><br><span class="line"><span class="comment"> *  1 byte: File contents encryption mode</span></span><br><span class="line"><span class="comment"> *  1 byte: File names encryption mode</span></span><br><span class="line"><span class="comment"> *  1 byte: Reserved</span></span><br><span class="line"><span class="comment"> *  8 bytes: Master Key descriptor</span></span><br><span class="line"><span class="comment"> *  16 bytes: Encryption Key derivation nonce</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> format;</span><br><span class="line">	<span class="keyword">char</span> contents_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> filenames_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> flags;</span><br><span class="line">	<span class="keyword">char</span> master_key_descriptor[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">	<span class="keyword">char</span> nonce[EXT4_KEY_DERIVATION_NONCE_SIZE];</span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<p>&emsp;  设置EXT4 Encryption开启是通过对特定目录进行EXT4_IOC_SET_ENCRYPTION ioctl完成，具体策略使用清单三所示的struct ext4_encryption_policy 数据结构进行封装，包括版本号、文件内容的加密算法、文件名的加密算法、旗标、master key descriptor。每个加密文件保存的ext4_encryption_context信息均继承自该数据结构，子目录继承父目录的ext4_encryption_context。</p>
<h4 id="清单三-Encryption-policy"><a href="#清单三-Encryption-policy" class="headerlink" title="清单三 Encryption policy"></a>清单三 Encryption policy</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Policy provided via an ioctl on the topmost directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_policy</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> version;</span><br><span class="line">	<span class="keyword">char</span> contents_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> filenames_encryption_mode;</span><br><span class="line">	<span class="keyword">char</span> flags;</span><br><span class="line">	<span class="keyword">char</span> master_key_descriptor[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">&#125; __attribute__((__packed__));</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  open文件时将文件加密相关信息从xattr中读出并保存在清单四的struct ext4_crypt_info数据结构中，成员ci_ctfm用于调用kernel crypto，在文件open时做好key的初始化。从磁盘获取到加密信息后，将该数据结构保存到inode的内存表示struct ext4_inode_info中的i_crypt_info字段，方便后续的readpage、writepage时获取到相应数据进行加/解密操作。</p>
<h4 id="清单四-保存加-解密信息及调用接口的数据结构"><a href="#清单四-保存加-解密信息及调用接口的数据结构" class="headerlink" title="清单四 保存加/解密信息及调用接口的数据结构"></a>清单四 保存加/解密信息及调用接口的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>		ci_data_mode;</span><br><span class="line">	<span class="keyword">char</span>		ci_filename_mode;</span><br><span class="line">	<span class="keyword">char</span>		ci_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">ci_ctfm</span>;</span></span><br><span class="line">	<span class="keyword">char</span>		ci_master_key[EXT4_KEY_DESCRIPTOR_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  如清单五所示，采用struct ext4_crypto_ctx 表示在readpage、writepage时进行page加/解密的context。在writepage时因为涉及到cache机制，需要保存明文页，所以专门申请单独的bounce_page保存密文用于写入磁盘，用control_page来指向正常的明文页。在readpage时，通过bio从磁盘中读出数据到内存页，读页完成后通过queue_work的形式调用解密流程并将明文保存在当前页，因此context中存在work成员。另外，为了提高效率，在初始化阶段一次性申请了128个ext4_crypto_ctx的内存空间并通过free_list链表进行管理。</p>
<h4 id="清单五-用于表示加-解密page的context"><a href="#清单五-用于表示加-解密page的context" class="headerlink" title="清单五 用于表示加/解密page的context"></a>清单五 用于表示加/解密page的context</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypto_ctx</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bounce_page</span>;</span>       <span class="comment">/* Ciphertext page */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">control_page</span>;</span>      <span class="comment">/* Original page  */</span></span><br><span class="line">		&#125; w;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">		&#125; r;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>;</span>     <span class="comment">/* Free list */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">char</span> flags;                      <span class="comment">/* Flags */</span></span><br><span class="line">	<span class="keyword">char</span> mode;                       <span class="comment">/* Encryption mode for tfm */</span></span><br><span class="line">&#125;;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="使能EXT4-Encryption-回页首"><a href="#使能EXT4-Encryption-回页首" class="headerlink" title="使能EXT4 Encryption 回页首"></a>使能EXT4 Encryption <a href="#top">回页首</a></h3><p><span id="Enable-EXT4-Encryption"></span></p>
<p>&emsp;  Linux kernel具有良好的模块化设计，EXT4 Encryption属于一个EXT4 FS中一个可选的模块，在编译kernel前需通过配置选项使能该功能，如下：<br>CONFIG_EXT4_FS_SECURITY=y<br>CONFIG_EXT4_FS_ENCRYPTION=y</p>
<h3 id="添加master-key的流程-回页首"><a href="#添加master-key的流程-回页首" class="headerlink" title="添加master key的流程 回页首"></a>添加master key的流程 <a href="#top">回页首</a></h3><p><span id="Add-Master-Key"></span></p>
<p>&emsp;  将master key添加到内核keyring属于EXT4 Encryption的第一步，该步骤通过add_key系统调用完成，master key在不同的Linux发行版有不同的产生及保存方法，这里以Chrome OS为例。<br>&emsp;  Chrome OS在cryptohomed守护进程中完成master key的获取和添加到keyring。因为兼容eCryptfs和EXT4 Encryption（为了跟Chrome OS保持一致，后续以Dircrypto代替EXT4 Encryption的称呼），而eCryptfs属于前辈，eCryptfs通过mount的方式完成加密文件的开启，为了保持一致性，cryptohomed同样是在mount的准备过程中解密出master key和开启Dircrypto，此master key即eCryptfs加密模式时用的FEK，master key descriptor即FEK的key signature，所以本节介绍Dircrypto流程时所谓的mount流程，望读者能够理解，在Dircrypto模式下，mount不是真正“mount”，千万不要混淆。cryptohomed的mount流程如下：    </p>
<ol>
<li>cryptohomed在D-Bus上接收到持（包含用户名和密码）有效用户证书的mount请求，当然D-Bus请求也是有权限控制的；    </li>
<li>假如是用户首次登陆，将进行：<br>a．    建立/home/.shadow/[salt_hash_of_username]目录，采用SHA1算法和系统的salt对用户名进行加密，生成salt_hash_of_username，简称s_h_o_u;<br>b．    生成vault keyset /home/.shadow/[salt_hash_of_username]/master.0和/home/.shadow/[salt_hash_of_username]/master.0.sum。master.0加密存储了包含有FEK和FNEK的内容以及非敏感信息如salt、password rounds等；master.0.sum是对master.0文件内容的校验和。    </li>
<li>采用通过mount请求传入的用户证书解密keyset。当TPM可用时优先采用TPM解密，否则采用Scrypt库，当TPM可用后再自动切换回使用TPM。cryptohome使用TPM仅仅是为了存储密钥，由TPM封存的密钥仅能被TPM自身使用，这可用缓解密钥被暴力破解，增强保护用户隐私数据的安全。TPM的首次初始化由cryptohomed完成。这里默认TPM可正常使用，其解密机制如下图二所示，其中：<br>UP：User Passkey，用户登录口令<br>EVKK：Ecrypted vault keyset key，保存在master.0中的”tpm_key”字段<br>IEVKK：Intermediate vault keyset key，解密过程生成的中间文件，属于EVKK的解密后产物，也是RSA解密的输入密文<br>TPM_CHK: TPM-wrapped system-wide Cryptohome key，保存在/home/.shadow/cryptohome.key，TPM init时加载到TPM<br>VKK：Vault keyset key<br>VK：Vault Keyset，包含FEK和FNEK<br>EVK：Encrypted vault keyset，保存在master.0里”wrapped_keyset”字段</li>
</ol>
<center>          
![](tpm-decrypt-VK.png "图二")   
图二 TPM解密VK的流程
</center>

<p>图二中的UP（由发起mount的D-Bus请求中通过key参数传入）做为一个AES key用于解密EVKK，解密后得到的IEVKK；然后将IEVKK做为RSA的密文送入TPM，使用TPM_CHK做为密钥进行解密，解密后得到VKK；最后生成的VKK是一个AES key，用于解密master.0里的EVK，得到包含有FEK和FNEK明文的VK。经过三层解密，终于拿到关键的FEK，此FEK在Dircrypto模式下当做master key使用，FEK signature即做master key descriptor使用。<br>&emsp;  最后通过add_key系统调用将master key及master key descriptor（在keyring中为了方便区分，master key descriptor由key sign加上前缀”ext4:”组成）添加到keyring，如下清单六代码所示</p>
<h4 id="清单六-Chrome-OS传入master-key的核心代码"><a href="#清单六-Chrome-OS传入master-key的核心代码" class="headerlink" title="清单六 Chrome OS传入master key的核心代码"></a>清单六 Chrome OS传入master key的核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_serial_t</span> <span class="title">AddKeyToKeyring</span><span class="params">(<span class="keyword">const</span> brillo::SecureBlob&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> brillo::SecureBlob&amp; key_descriptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//参数中的key即是master key，key_descriptor即sig</span></span><br><span class="line">  <span class="keyword">if</span> (key.<span class="built_in">size</span>() &gt; EXT4_MAX_KEY_SIZE ||</span><br><span class="line">      key_descriptor.<span class="built_in">size</span>() != EXT4_KEY_DESCRIPTOR_SIZE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Invalid arguments: key.size() = "</span> &lt;&lt; key.<span class="built_in">size</span>()</span><br><span class="line">               &lt;&lt; <span class="string">"key_descriptor.size() = "</span> &lt;&lt; key_descriptor.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在upstart中已经通过add_key添加dircrypt的会话keyring</span></span><br><span class="line">  <span class="keyword">key_serial_t</span> keyring = keyctl_search(</span><br><span class="line">      KEY_SPEC_SESSION_KEYRING, <span class="string">"keyring"</span>, kKeyringName, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (keyring == kInvalidKeySerial) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"keyctl_search failed"</span>;</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化struct ext4_encryption_key</span></span><br><span class="line">  ext4_encryption_key ext4_key = &#123;&#125;;</span><br><span class="line">  ext4_key.mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">  <span class="built_in">memcpy</span>(ext4_key.raw, key.char_data(), key.<span class="built_in">size</span>());</span><br><span class="line">  ext4_key.<span class="built_in">size</span> = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//key_name就是最后的master key description，由”ext4:”+sig两部分组成</span></span><br><span class="line">  <span class="comment">//kernel在request_key时同样是将”ext4:”+sig两部分组成master key description</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key_name = kKeyNamePrefix + base::ToLowerASCII(</span><br><span class="line">      base::HexEncode(key_descriptor.data(), key_descriptor.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="comment">// kKeyType是“logon”，不允许应用程序获取密钥的内容</span></span><br><span class="line">  <span class="keyword">key_serial_t</span> key_serial = add_key(kKeyType, key_name.c_str(), &amp;ext4_key,</span><br><span class="line">                                    <span class="keyword">sizeof</span>(ext4_key), keyring);</span><br><span class="line">  <span class="keyword">if</span> (key_serial == kInvalidKeySerial) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to insert key into keyring"</span>;</span><br><span class="line">    <span class="keyword">return</span> kInvalidKeySerial;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key_serial;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="Set-Encryption-Policy流程-回页首"><a href="#Set-Encryption-Policy流程-回页首" class="headerlink" title="Set Encryption Policy流程 回页首"></a>Set Encryption Policy流程 <a href="#top">回页首</a></h3><p><span id="Set-Encryption-Policy"></span></p>
<p>&emsp;  通过对目标目录的文件描述符进行ioctl 的 EXT4_IOC_SET_ENCRYPTION_POLICY 操作即完成了EXT4 Encryption的加/解密功能的开启，该步骤在完成添加master key后进行，Chrome OS中的相关代码如下清单七所示，通过struct ext4_encryption_policy指定了策略的版本号、文件内容和文件名的加密算法、旗标、master key的识别描述符。</p>
<h4 id="清单七-Chrome-OS-set-encryption-policy的核心代码"><a href="#清单七-Chrome-OS-set-encryption-policy的核心代码" class="headerlink" title="清单七 Chrome OS set encryption policy的核心代码"></a>清单七 Chrome OS set encryption policy的核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetDirectoryKey</span><span class="params">(<span class="keyword">const</span> base::FilePath&amp; dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> brillo::SecureBlob&amp; key_descriptor)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(EXT4_KEY_DESCRIPTOR_SIZE),</span><br><span class="line">            key_descriptor.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">/*这里的dir代表要开启EXT4 Encryption的目录 */</span></span><br><span class="line">  <span class="function">base::ScopedFD <span class="title">fd</span><span class="params">(HANDLE_EINTR(<span class="built_in">open</span>(dir.value().c_str(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                      O_RDONLY | O_DIRECTORY)))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!fd.is_valid()) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Ext4: Invalid directory"</span> &lt;&lt; dir.value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/*初始化struct ext4_encryption_policy对象 </span></span><br><span class="line"><span class="comment">   * 指定文件内容的加密算法是AES_256_XTS</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ext4_encryption_policy policy = &#123;&#125;;</span><br><span class="line">  policy.version = <span class="number">0</span>;</span><br><span class="line">  policy.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">  policy.filenames_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">  policy.flags = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// key_descriptor即FEK 的key sig</span></span><br><span class="line">  <span class="built_in">memcpy</span>(policy.master_key_descriptor, key_descriptor.data(),</span><br><span class="line">         EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">  <span class="comment">/*通过ioctl完成设置*/</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd.<span class="built_in">get</span>(), EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;policy) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to set the encryption policy of "</span> &lt;&lt; dir.value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  内核对EXT4_IOC_SET_ENCRYPTION_POLICY的ioctl在ext4_ioctl函数中完成响应，从应用程序中接收ext4_encryption_policy，解析其参数，若是首次对该目录进行加密设置则生成一个ext4_encryption_context 数据结构保存包括版本号、文件内容的加密算法、文件名的加密算法、旗标、master key descriptor、nonce在内的所有信息到目录对应inode的xattr中。从此开始，以该目录做为EXT Encryption加密的根目录，其下文件和子目录的除了nonce需要再次单独产生外，其余加密属性均继承自该目录。若非首次对该目录进行EXT4 Encryption设置，则重点比较当前设置是否与先前的设置一致。首先介绍首次设置的情形， ext4_ioctl的函数调用关系如图三所示。</p>
<center>          
![](ext4-ioctl-firsttime.png "图三")   
图三 首次进行EXT4 Encryption设置的函数调用关系
</center>

<p>&emsp;  应用程序进行ioctl系统调用经过VFS，最终调用ext4_ioctl函数，借助图三的函数调用可看到进行EXT4 Encryption policy设置时都进行了什么操作。首先判断目录所在的文件系统是否支持EXT4 Encryption操作，具体在ext4_has_feature_encrypt 函数中通过判断superblock的s_es-&gt;s_feature_incompat是否支持ENCRYPT属性；然后利用copy_from_user函数从用户空间拷贝ext4_encryption_policy到内核空间；紧接着在ext4_process_policy函数里将ext4_encryption_policy转换成ext4_encryption_context保存到inode的attr；最后将加密目录对应的inode的修改保存到磁盘。重点部分在ext4_process_policy函数，主要分三大步骤，第一步还是进行照例检查校验，包括：访问权限、ext4_encryption_policy的版本号、目标目录是否为空目录、目标目录是否已经存在ext4_encryption_context；第二步为目标目录生成ext4_encryption_context并保存到xattr；最后提交修改的保存请求。第一步的具体操作表现在函数操作上如下：<br>● inode_owner_or_capable() 完成DAC方面的权限检查<br>● 对ext4_encryption_policy的版本号version进行检查，当前仅支持版本0<br>● ext4_inode_has_encryption_context()尝试读取目标目录对应的inode的xattr的EXT4 Encryption字段”c”，看是否存在内容，若存在内容，则说明目标目录在先前已经进行过EXT4 Encryption设置<br>● S_ISDIR()校验目标目录是否真的是目录<br>● ext4_empty_dir()判断目标目录是否为空目录，在首次设置EXT4 Encryption时，仅支持对空目录进行操作。这点有别于eCryptfs，eCryptfs加密文件所在的目录下支持非加密和加密文件的同时存在；而EXT4 Encryption要么是全加密，要么是全非加密。<br>&emsp;  第二步在ext4_create_encryption_context_from_policy函数中完成，具体如下：<br>● ext4_convert_inline_data()对inline data做处理<br>● ext4_valid_contents_enc_mode()校验ext4_encryption_policy的文件内容加密模式是否为AES_256_XTS，当前仅支持该算法的内容加密<br>● ext4_valid_filenames_enc_mode()校验ext4_encryption_policy的文件名加密模式是否为AES_256_CTS，当前仅支持该算法的内容名加密<br>● 对ext4_encryption_policy的flags做检验<br>● get_random_bytes()产生16 Bytes的随机数，赋值给ext4_encryption_context的nonce，其他如master key descriptor、flags、文件内容加密模式、文件名加密模式等值，从ext4_encryption_policy中获取，完成目标目录对应的ext4_encryption_context的初始化<br>● ext4_xattr_set()将用于目标目录的ext4_encryption_context保存到inode的xattr<br>● ext4_set_inode_flag()将目标目录对应inode的i_flags设置成EXT4_INODE_ENCRYPT，表明其属性。后续在文件open、read、write时通过该标志进行判断<br>&emsp;  最后使用ext4_journal_start、ext4_mark_inode_dirty、ext4_journal_stop等函数完成xattr数据回写到磁盘的请求。<br>&emsp;  若非首次对目标目录进行EXT4 Encryption设置，请流程如图四所示，通过ext4_xattr_get函数读取对应inode的xattr的EXT4 Encryption字段”c”对应的内容，即保存的ext4_encryption_context，将其与ext4_encryption_policy的相应值进行对比，若不一致返回-EINVAL。        </p>
<center>          
![](ext4-ioctl-no-firsttime.png "图四")   
图四 非首次进行EXT4 Encryption设置的函数调用关系
</center>

<p>&emsp;  相比eCryptfs，此EXT4_IOC_SET_ENCRYPTION_POLICY的ioctl的作用类似eCryptfs的”mount –t ecryptfs ”操作。</p>
<h3 id="creat-file流程-回页首"><a href="#creat-file流程-回页首" class="headerlink" title="creat file流程 回页首"></a>creat file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-creat"></span></p>
<p>&emsp;  creat file流程特指应用程序通过creat()函数或open( , O_CREAT, )在已经通过EXT4_IOC_SET_ENCRYPTION_POLICY ioctl完成EXT4 Encryption设置的目录下新建普通文件的过程。希望通过介绍该过程，可以帮助读者了解如何创建加密文件，如何利用master key和nonce生成derived key。<br>&emsp;  应用程序使用creat()函数通过系统调用经由VFS，在申请到fd、初始化好nameidata 、struct file等等之后利用ext4_create()函数完成加密文件的创建，函数调用关系如图五所示。<br>&emsp;  创建加密文件的核心函数ext4_create()的函数调用关系如图六所示，函数主要功能是创建ext4 inode节点并初始化，这里只关注EXT4 Encryption部分。在创建时首先判断其所在目录inode的i_flags是否已经被设置了EXT4_INODE_ENCRYPT属性（该属性在EXT4_IOC_SET_ENCRYPTION_POLICY ioctl或者在EXT4 Encryption根目录下的任何地方新建目录/文件时完成i_flags设置），若是则表明需要进行EXT4 Encryption；接着读取新文件所在目录，即其父目录的xattr属性获取到ext4_encryption_context，再为新文件生成新的nonce，将nonce替换父目录的ext4_encryption_context中的nonce生成用于新文件的ext4_encryption_context并保存到新文件对应inode的xattr中；然后用ext4_encryption_context中的master key descriptor匹配到keyring中的master key，将ext4_encryption_context中的nonce做为密钥对master key进行AES-128-ECB加密，得到derived key；最后使用derived key和AES-256-XTS初始化kernel crypto API，将初始化好的tfm保存到 ext4_crypt_info 的ci_ctfm成员中，再将ext4_crypt_info保存到ext4_inode_info的i_crypt_info，后续对新文件进行读写操作时直接取出ci_ctfm做具体的加/解密即可。</p>
<center>          
![](creat-open-file.png "图五")   
图五 creat和open file函数调用关系
</center>

<center>          
![](ext4_create.png "图六")   
图六 ext4_create函数调用关系
</center>

<p>&emsp;  具体到图六中ext4_create函数调用关系中各个要点函数，完成的功能如下：<br>● ext4_encrypted_inode()判断文件父目录的inode的i_flags是否已经被设置了EXT4_INODE_ENCRYPT属性<br>● ext4_get_encryption_info()读取父目录的xattr属性获取到ext4_encryption_context，并为父目录生成derived key，初始化好tfm并保存到其ext4_inode_info的i_crypt_info<br>● ext4_encryption_info()确认父目录的ext4_inode_info的i_crypt_info已经初始化好<br>● ext4_inherit_context()为新文件创建ext4_encryption_context并保存到其xattr中，并为新文件生成derived key，初始化好tfm并保存到其ext4_inode_info的i_crypt_info<br>&emsp;  从上可看到ext4_get_encryption_info()和ext4_inherit_context()是最关键的部分，其代码如清单八和清单九所示，代码较长，但强烈建议耐心读完。</p>
<h4 id="清单八-ext4-get-encryption-info函数"><a href="#清单八-ext4-get-encryption-info函数" class="headerlink" title="清单八 ext4_get_encryption_info函数"></a>清单八 ext4_get_encryption_info函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_get_encryption_info</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode_info</span> *<span class="title">ei</span> = <span class="title">EXT4_I</span>(<span class="title">inode</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">crypt_info</span>;</span></span><br><span class="line">	<span class="keyword">char</span> full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +</span><br><span class="line">				 (EXT4_KEY_DESCRIPTOR_SIZE * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring_key</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_key</span> *<span class="title">master_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">ukp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext4_sb_info</span> *<span class="title">sbi</span> = <span class="title">EXT4_SB</span>(<span class="title">inode</span>-&gt;<span class="title">i_sb</span>);</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">ctfm</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cipher_str;</span><br><span class="line">	<span class="keyword">char</span> raw_key[EXT4_MAX_KEY_SIZE];</span><br><span class="line">	<span class="keyword">char</span> mode;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若ext4_inode_info中的i_crypt_info有值，说明先前已经初始化好</span></span><br><span class="line">	<span class="keyword">if</span> (ei-&gt;i_crypt_info)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!ext4_read_workqueue) &#123;</span><br><span class="line">	<span class="comment">/*为readpage时解密初始化read_workqueue，为ext4_crypto_ctx预先创建128个</span></span><br><span class="line"><span class="comment">	*cache，为writepage时用的bounce page创建内存池，为ext4_crypt_info创建slab</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		res = ext4_init_crypto();</span><br><span class="line">		<span class="keyword">if</span> (res)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*从xattr中读取加密模式、master key descriptor、nonce等加密相关信息到</span></span><br><span class="line"><span class="comment">	*ext4_encryption_context</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,</span><br><span class="line">				 EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,</span><br><span class="line">				 &amp;ctx, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!DUMMY_ENCRYPTION_ENABLED(sbi))</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">		ctx.filenames_encryption_mode =</span><br><span class="line">			EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">		ctx.flags = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (res != <span class="keyword">sizeof</span>(ctx))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	crypt_info = kmem_cache_alloc(ext4_crypt_info_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!crypt_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据获取到的ext4_encryption_context内容初始化ext4_crypt_info</span></span><br><span class="line">	crypt_info-&gt;ci_flags = ctx.flags;</span><br><span class="line">	crypt_info-&gt;ci_data_mode = ctx.contents_encryption_mode;</span><br><span class="line">	crypt_info-&gt;ci_filename_mode = ctx.filenames_encryption_mode;</span><br><span class="line">	crypt_info-&gt;ci_ctfm = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(crypt_info-&gt;ci_master_key, ctx.master_key_descriptor,</span><br><span class="line">	       <span class="keyword">sizeof</span>(crypt_info-&gt;ci_master_key));</span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">		mode = crypt_info-&gt;ci_data_mode;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISLNK(inode-&gt;i_mode))</span><br><span class="line">		mode = crypt_info-&gt;ci_filename_mode;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		BUG();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> EXT4_ENCRYPTION_MODE_AES_256_XTS:</span><br><span class="line">		cipher_str = <span class="string">"xts(aes)"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EXT4_ENCRYPTION_MODE_AES_256_CTS:</span><br><span class="line">		cipher_str = <span class="string">"cts(cbc(aes))"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: unsupported key mode %d (ino %u)\n"</span>,</span><br><span class="line">			    mode, (<span class="keyword">unsigned</span>) inode-&gt;i_ino);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (DUMMY_ENCRYPTION_ENABLED(sbi)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(raw_key, <span class="number">0x42</span>, EXT4_AES_256_XTS_KEY_SIZE);</span><br><span class="line">		<span class="keyword">goto</span> got_key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实际使用时将master key descriptor加上”ext4:”的前缀用于匹配master key</span></span><br><span class="line">	<span class="built_in">memcpy</span>(full_key_descriptor, EXT4_KEY_DESC_PREFIX,</span><br><span class="line">	       EXT4_KEY_DESC_PREFIX_SIZE);</span><br><span class="line">	<span class="built_in">sprintf</span>(full_key_descriptor + EXT4_KEY_DESC_PREFIX_SIZE,</span><br><span class="line">		<span class="string">"%*phN"</span>, EXT4_KEY_DESCRIPTOR_SIZE,</span><br><span class="line">		ctx.master_key_descriptor);</span><br><span class="line">	full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +</span><br><span class="line">			    (<span class="number">2</span> * EXT4_KEY_DESCRIPTOR_SIZE)] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用master key descriptor为匹配条件向keyring申请master key</span></span><br><span class="line">	keyring_key = request_key(&amp;key_type_logon, full_key_descriptor, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(keyring_key)) &#123;</span><br><span class="line">		res = PTR_ERR(keyring_key);</span><br><span class="line">		keyring_key = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//确保master key的type是logon类型，防止应用程序读取到key的内容</span></span><br><span class="line">	<span class="keyword">if</span> (keyring_key-&gt;type != &amp;key_type_logon) &#123;</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: key type must be logon\n"</span>);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">	<span class="comment">//从keyring中取出master key的payload</span></span><br><span class="line">	ukp = user_key_payload(keyring_key);</span><br><span class="line">	<span class="keyword">if</span> (ukp-&gt;datalen != <span class="keyword">sizeof</span>(struct ext4_encryption_key)) &#123;</span><br><span class="line">		res = -EINVAL;</span><br><span class="line">		up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取出master key的有效数据ext4_encryption_key</span></span><br><span class="line">	master_key = (struct ext4_encryption_key *)ukp-&gt;data;</span><br><span class="line">	BUILD_BUG_ON(EXT4_AES_128_ECB_KEY_SIZE !=</span><br><span class="line">		     EXT4_KEY_DERIVATION_NONCE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (master_key-&gt;<span class="built_in">size</span> != EXT4_AES_256_XTS_KEY_SIZE) &#123;</span><br><span class="line">		printk_once(KERN_WARNING</span><br><span class="line">			    <span class="string">"ext4: key size incorrect: %d\n"</span>,</span><br><span class="line">			    master_key-&gt;<span class="built_in">size</span>);</span><br><span class="line">		res = -ENOKEY;</span><br><span class="line">		up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以nonce做为密钥，采用AES_128_ECB算法，利用kernel crypto API加密master</span></span><br><span class="line"><span class="comment">	* key（master_key-&gt;raw），生成derived key保存在raw_key里</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,</span><br><span class="line">				  raw_key);</span><br><span class="line">	up_read(&amp;keyring_key-&gt;sem);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">got_key:</span><br><span class="line">	<span class="comment">//为AES_256_XTS加密算法申请tfm</span></span><br><span class="line">	ctfm = crypto_alloc_ablkcipher(cipher_str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ctfm || IS_ERR(ctfm)) &#123;</span><br><span class="line">		res = ctfm ? PTR_ERR(ctfm) : -ENOMEM;</span><br><span class="line">		printk(KERN_DEBUG</span><br><span class="line">		       <span class="string">"%s: error %d (inode %u) allocating crypto tfm\n"</span>,</span><br><span class="line">		       __func__, res, (<span class="keyword">unsigned</span>) inode-&gt;i_ino);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	crypt_info-&gt;ci_ctfm = ctfm;</span><br><span class="line">	crypto_ablkcipher_clear_flags(ctfm, ~<span class="number">0</span>);</span><br><span class="line">	crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctfm),</span><br><span class="line">			     CRYPTO_TFM_REQ_WEAK_KEY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向kernel crypto接口里设置加密用的key为derived key</span></span><br><span class="line">	res = crypto_ablkcipher_setkey(ctfm, raw_key,</span><br><span class="line">				       ext4_encryption_key_size(mode));</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将初始化好的ext4_crypt_info 实例crypt_info拷贝到inode的ext4_inode_info 的*i_crypt_info。</span></span><br><span class="line"><span class="comment">	*后续加/解密文件内容时直接取出ext4_inode_info的i_crypt_info，即可从中获取</span></span><br><span class="line"><span class="comment">	*到已经初始化好的tfm接口c_ctfm，用其直接加/解密</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (cmpxchg(&amp;ei-&gt;i_crypt_info, <span class="literal">NULL</span>, crypt_info) == <span class="literal">NULL</span>)</span><br><span class="line">		crypt_info = <span class="literal">NULL</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (res == -ENOKEY)</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">	key_put(keyring_key);</span><br><span class="line">	ext4_free_crypt_info(crypt_info);</span><br><span class="line">	memzero_explicit(raw_key, <span class="keyword">sizeof</span>(raw_key));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h4 id="清单九-ext4-inherit-context函数"><a href="#清单九-ext4-inherit-context函数" class="headerlink" title="清单九 ext4_inherit_context函数"></a>清单九 ext4_inherit_context函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_inherit_context</span><span class="params">(struct inode *parent, struct inode *child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_encryption_context</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">ci</span>;</span></span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确保其父目录inode对应的i_crypt_info已经初始化好</span></span><br><span class="line">	res = ext4_get_encryption_info(parent);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取父目录的保存在i_crypt_info的ext4_crypt_info信息</span></span><br><span class="line">	ci = EXT4_I(parent)-&gt;i_crypt_info;</span><br><span class="line">	<span class="keyword">if</span> (ci == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOKEY;</span><br><span class="line">	ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;</span><br><span class="line">	<span class="keyword">if</span> (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent-&gt;i_sb))) &#123;</span><br><span class="line">		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">		ctx.filenames_encryption_mode =</span><br><span class="line">			EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">		ctx.flags = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ctx.master_key_descriptor, <span class="number">0x42</span>,</span><br><span class="line">		       EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/*使用父目录的文件内容加密模式、文件名加密模式、master key descriptor、flags</span></span><br><span class="line"><span class="comment">	*初始化新文件的ext4_encryption_context</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		ctx.contents_encryption_mode = ci-&gt;ci_data_mode;</span><br><span class="line">		ctx.filenames_encryption_mode = ci-&gt;ci_filename_mode;</span><br><span class="line">		ctx.flags = ci-&gt;ci_flags;</span><br><span class="line">		<span class="built_in">memcpy</span>(ctx.master_key_descriptor, ci-&gt;ci_master_key,</span><br><span class="line">		       EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//产生16 bytes的随机数做为新文件的nonce</span></span><br><span class="line">	get_random_bytes(ctx.nonce, EXT4_KEY_DERIVATION_NONCE_SIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将初始化好的新文件的ext4_encryption_context保存到attr中</span></span><br><span class="line">	res = ext4_xattr_set(child, EXT4_XATTR_INDEX_ENCRYPTION,</span><br><span class="line">			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &amp;ctx,</span><br><span class="line">			     <span class="keyword">sizeof</span>(ctx), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">		<span class="comment">//设置新文件的inode的i_flags为EXT4_INODE_ENCRYPT</span></span><br><span class="line">		ext4_set_inode_flag(child, EXT4_INODE_ENCRYPT);</span><br><span class="line">		ext4_clear_inode_state(child, EXT4_STATE_MAY_INLINE_DATA);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*为新文件初始化好其inode对应的i_crypt_info，主要是完成其tfm的初始化</span></span><br><span class="line"><span class="comment">		*为后续的读写文件时调用kernel crypto进行加/解密做好准备</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		res = ext4_get_encryption_info(child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  简单的说，creat时完成两件事：一是创建ext4_encryption_context保存到文件的xattr；二是初始化好ext4_crypt_info 保存到inode的i_crypt_info，后续使用时取出tfm，利用kernel crypto API即完成了加/解密工作。</p>
<h3 id="open-file流程-回页首"><a href="#open-file流程-回页首" class="headerlink" title="open file流程 回页首"></a>open file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-open"></span></p>
<p>&emsp;  这里open file特指打开已存在的EXT4 Encryption加密文件。仅加密部分而言，该过程相比creat少了创建ext4_encryption_context保存到文件的xattr的操作，其余部分基本一致。从应用程序调用open()函数开始到最终调用到ext4_file_open()函数的函数调用关系如上图五所示。本节主要描述ext4_file_open()函数，其函数调用关系如图七。</p>
<center>          
![](ext4_file_open.png "图七")   
图七 ext4\_file\_open函数调用关系
</center>

<p>图七所示各函数主要完成的功能如下：<br>● ext4_encrypted_inode() 判断欲打开文件对应inode的i_flags是否设置成EXT4_INODE_ENCRYPT，若是，表明是加密文件<br>● ext4_get_encryption_info() 从文件inode的xattr取出文件加密算法、文件名加密算法、master key descriptor、 随机密钥nonce；之后生成加密文件内容使用的密钥derived key并初始化好kernel crypto接口tfm，将其以ext4_crypt_info 形式保存到inode的i_crypt_info。详细代码见清单八<br>● ext4_encryption_info()确保文件对应inode在内存中的表示ext4_inode_info中的i_crypt_info已经做好初始化<br>● ext4_encrypted_inode(dir)判断判断欲打开文件的父目录inode的i_flags是否设置成EXT4_INODE_ENCRYPT<br>● ext4_is_child_context_consistent_with_parent()判断文件和其父目录的加密context是否一致，关键是master key descriptor是否一致<br>● dquost_file_open() 调用通用的文件打开函数完成其余的操作<br>&emsp;  简单的说就是在open file的时候完成文件加/解密所需的所有context。</p>
<h3 id="read-file流程-回页首"><a href="#read-file流程-回页首" class="headerlink" title="read file流程 回页首"></a>read file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-read"></span></p>
<p>&emsp;  加密文件的解密工作主要是在read的时候进行。正常的Linux read支持Buffered I/O和Direct I/O两种模式，Buffered I/O利用内核的page cache机制，而Direct I/O需要应用程序自身准备和处理cache，当前版本的EXT4 Encryption不支持Direct I/O，其文件内容解密工作都在page cache中完成。自应用程序发起read操作到kernel对文件内容进行解密的函数调用关系如图八所示。</p>
<center>          
![](read.png "图八")   
图八 read 加密文件的函数调用关系
</center>

<p>&emsp;  ext4 文件读的主要实现在ext4_readpage函数，文件内容的AES-256-XTS解密理所当然也在该函数里，这里主要介绍文件内容解密部分，其函数调用关系如图九所示。ext4 读写通过bio进行封装，描述块数据传送时怎样进行填充或读取块给driver，包括描述磁盘和内存的位置，其内部有一个函数指针bi_end_io，当读取完成时会回调该函数，如图九所示，ext4将bi_end_io赋值为mpage_end_io。mpage_end_io通过queue_work的形式调用completion_pages函数，在该函数中再调用ext4_decrypt函数完成page的解密。ext4_decrypt函数的代码非常简单，如清单十所示。核心的加密和解密函数都在ext4_page_crypto()中完成，因为在open file的时候已经初始化好了kernel crypto接口，所以这里主要传入表明是加密还是解密的参数以及密文页和明文页地址，代码比较简单，如清单十一所示。</p>
<center>          
![](ext4_readpage.png "图九")   
图九 ext4_readpage函数调用关系
</center>

<h4 id="清单十-ext4-decrypt函数"><a href="#清单十-ext4-decrypt函数" class="headerlink" title="清单十 ext4_decrypt函数"></a>清单十 ext4_decrypt函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_decrypt</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BUG_ON(!PageLocked(page));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ext4_page_crypto(page-&gt;mapping-&gt;host, EXT4_DECRYPT,</span><br><span class="line">				page-&gt;index, page, page, GFP_NOFS);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h4 id="清单十一-ext4-page-crypto-函数"><a href="#清单十一-ext4-page-crypto-函数" class="headerlink" title="清单十一 ext4_page_crypto 函数"></a>清单十一 ext4_page_crypto 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_page_crypto</span><span class="params">(struct inode *inode, <span class="keyword">ext4_direction_t</span> rw, <span class="keyword">pgoff_t</span> index, struct page *src_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			    struct page *dest_page, <span class="keyword">gfp_t</span> gfp_flags)</span> </span>&#123;</span><br><span class="line">	u8 xts_tweak[EXT4_XTS_TWEAK_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ablkcipher_request</span> *<span class="title">req</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	DECLARE_EXT4_COMPLETION_RESULT(ecr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">dst</span>, <span class="title">src</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypt_info</span> *<span class="title">ci</span> = <span class="title">EXT4_I</span>(<span class="title">inode</span>)-&gt;<span class="title">i_crypt_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">crypto_ablkcipher</span> *<span class="title">tfm</span> = <span class="title">ci</span>-&gt;<span class="title">ci_ctfm</span>;</span> <span class="comment">//取出open时初始化好的tfm</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	req = ablkcipher_request_alloc(tfm, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (!req) &#123;</span><br><span class="line">		printk_ratelimited(KERN_ERR <span class="string">"%s: crypto_request_alloc() failed\n"</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	ablkcipher_request_set_callback(</span><br><span class="line">		req, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,</span><br><span class="line">		ext4_crypt_complete, &amp;ecr);</span><br><span class="line">	BUILD_BUG_ON(EXT4_XTS_TWEAK_SIZE &lt; <span class="keyword">sizeof</span>(index));</span><br><span class="line">	<span class="built_in">memcpy</span>(xts_tweak, &amp;index, <span class="keyword">sizeof</span>(index));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;xts_tweak[<span class="keyword">sizeof</span>(index)], <span class="number">0</span>, EXT4_XTS_TWEAK_SIZE - <span class="keyword">sizeof</span>(index));</span><br><span class="line"></span><br><span class="line">	sg_init_table(&amp;dst, <span class="number">1</span>);</span><br><span class="line">	sg_set_page(&amp;dst, dest_page, PAGE_CACHE_SIZE, <span class="number">0</span>);</span><br><span class="line">	sg_init_table(&amp;src, <span class="number">1</span>);</span><br><span class="line">	sg_set_page(&amp;src, src_page, PAGE_CACHE_SIZE, <span class="number">0</span>);</span><br><span class="line">	ablkcipher_request_set_crypt(req, &amp;src, &amp;dst, PAGE_CACHE_SIZE, xts_tweak);</span><br><span class="line">	<span class="keyword">if</span> (rw == EXT4_DECRYPT)</span><br><span class="line">		res = crypto_ablkcipher_decrypt(req);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		res = crypto_ablkcipher_encrypt(req);</span><br><span class="line">	<span class="keyword">if</span> (res == -EINPROGRESS || res == -EBUSY) &#123;</span><br><span class="line">		wait_for_completion(&amp;ecr.completion);</span><br><span class="line">		res = ecr.res;</span><br><span class="line">	&#125;</span><br><span class="line">	ablkcipher_request_free(req);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		printk_ratelimited( KERN_ERR <span class="string">"%s: crypto_ablkcipher_encrypt() returned %d\n"</span>, __func__, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="write-file流程-回页首"><a href="#write-file流程-回页首" class="headerlink" title="write file流程 回页首"></a>write file流程 <a href="#top">回页首</a></h3><p><span id="EXT4-Encryption-file-write"></span></p>
<p>&emsp;  在写入文件的时候会首先将page cache中的文件明文内容进行AES-256-XTS<br>加密，再通过bio写入磁盘，该工作主要在ext4_writepage()函数中完成，这里主要关注EXT4 Encryption部分，其函数调用关系如图十所示。</p>
<center>          
![](ext4_writepage.png "图十")   
图十 ext4_writepage函数调用关系
</center>

<p>&emsp;  图十中，首先照例通过ext4_encrypted_inode()函数利用i_flags是否等于EXT4_INODE_ENCRYPT来判断是否是加密文件；然后使用ext4_encrypt()函数申请新的内存页用于保存密文，完成内容的加密，具体代码见清单十二，函数返回密文页的地址保存在data_page变量；紧着通过io_submit_add_bh()封装写入buffer页到磁盘的请求，这里通过判断data_page页是否空来决定是写入明文页还是密文页，巧妙的兼容了加密和非加密两种模式；最后通过ext4_io_submit()提交bio写盘请求。</p>
<h4 id="清单十二-ext4-encrypt函数"><a href="#清单十二-ext4-encrypt函数" class="headerlink" title="清单十二 ext4_encrypt函数"></a>清单十二 ext4_encrypt函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">ext4_encrypt</span><span class="params">(struct inode *inode,</span></span></span><br><span class="line"><span class="function"><span class="params">			  struct page *plaintext_page,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">gfp_t</span> gfp_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ext4_crypto_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">ciphertext_page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!PageLocked(plaintext_page));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从cache中获取一个ext4_crypto_ctx内存空间</span></span><br><span class="line">	ctx = ext4_get_crypto_ctx(inode, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">		<span class="keyword">return</span> (struct page *) ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从内存池中申请一个内存页，命名为bounce page，用于保存密文内容，同时将</span></span><br><span class="line">	<span class="comment">//ext4_crypto_ctx的w.bounce_page指向该bounce page</span></span><br><span class="line">	<span class="comment">/* The encryption operation will require a bounce page. */</span></span><br><span class="line">	ciphertext_page = alloc_bounce_page(ctx, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ciphertext_page))</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	ctx-&gt;w.control_page = plaintext_page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用kernel crypto加密，将密文保存在bounce page</span></span><br><span class="line">	err = ext4_page_crypto(inode, EXT4_ENCRYPT, plaintext_page-&gt;index,</span><br><span class="line">			       plaintext_page, ciphertext_page, gfp_flags);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		ciphertext_page = ERR_PTR(err);</span><br><span class="line">	errout:</span><br><span class="line">		ext4_release_crypto_ctx(ctx);</span><br><span class="line">		<span class="keyword">return</span> ciphertext_page;</span><br><span class="line">	&#125;</span><br><span class="line">	SetPagePrivate(ciphertext_page);</span><br><span class="line">	set_page_private(ciphertext_page, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ctx);</span><br><span class="line">	lock_page(ciphertext_page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回密文页bounce page地址</span></span><br><span class="line">	<span class="keyword">return</span> ciphertext_page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>&emsp;  因为在open file的时候已经初始化好了kernel crypto 所需的加密算法、密钥设置，并保存了tfm到文件inode的内存表示ext4_inode_info的成员i_crypt_info中，所以在readpage/writepage时进行加/解密的操作变得很简单。</p>
<h2 id="结语-回页首"><a href="#结语-回页首" class="headerlink" title="结语 回页首"></a>结语 <a href="#top">回页首</a></h2><p><span id="end"></span></p>
<p>&emsp;  与eCryptfs类似，EXT4 Encryption建立在内核安全可信的基础上，核心安全组件是master key，若内核被攻破导致密钥泄露，EXT4 Encryption的安全性将失效。同样需要注意page cache中的明文页有可能被交换到磁盘的swap区。早期版本的Chrome OS禁用了swap功能，当前版本的swap采取的是zram机制，与传统的磁盘swap有本质区别。相比eCryptfs做为一个独立的内核加密模块，现在EXT4 Encryption原生的存在于EXT4文件系统中，在使用的便利性和性能上都优于eCryptfs，相信推广将会变得更加迅速。</p>
<h2 id="参考资料-回页首"><a href="#参考资料-回页首" class="headerlink" title="参考资料 回页首"></a>参考资料 <a href="#top">回页首</a></h2><p><span id="refer"></span></p>
<ol>
<li><a href="https://chromium.googlesource.com/chromiumos/third_party/kernel/+/v4.4.79" target="_blank" rel="noopener">Linux kernel-V4.4.79 sourcecode</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/" target="_blank" rel="noopener">Chromium OS platform-9653 sourcecode</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/ChromeOS-Userdata-Protection-Mechanism-Based-On-EXT4-Encryption/" data-id="cmd5slqzr00040lo1abyf92ll" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../12/rs4_dual_cr3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          随笔
        
      </div>
    </a>
  
  
    <a href="../ChromeOs-Userdata-Protection-Mechanism-Based-On-eCryptfs/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ChromeOS基于eCryptfs的用户数据安全保护机制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../fancybox/jquery.fancybox.css">

  
<script src="../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../js/script.js"></script>




  </div>
</body>
</html>